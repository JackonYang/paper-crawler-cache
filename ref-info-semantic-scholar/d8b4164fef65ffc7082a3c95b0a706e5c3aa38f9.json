{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747890"
                        ],
                        "name": "O. Strichman",
                        "slug": "O.-Strichman",
                        "structuredName": {
                            "firstName": "Ofer",
                            "lastName": "Strichman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Strichman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "119614910"
                        ],
                        "name": "M. Siegel",
                        "slug": "M.-Siegel",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Siegel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Siegel"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 15658777,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f044ee13be0a7049ed2255b029c768dcba337c98",
            "isKey": false,
            "numCitedBy": 48,
            "numCiting": 43,
            "paperAbstract": {
                "fragments": [],
                "text": "Translation validation is an alternative to the verification of translators (compilers, code generators). Rather than proving in advance that the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code produced on this run correctly implements the submitted source program. In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation. \n \nSince the validation process attempts to \"unravel\" the transformation effected by the translators, its task becomes increasingly more difficult (and necessary) with the increase of sophistication and variety of the optimizations methods employed by the translator. In this paper we address the practicability of translation validation for highly optimizing, industrial code generators from Signal, a widely used synchronous language, to C. We introduce new abstraction techniques as part of the automation of our approach."
            },
            "slug": "Translation-Validation:-From-SIGNAL-to-C-Pnueli-Strichman",
            "title": {
                "fragments": [],
                "text": "Translation Validation: From SIGNAL to C"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This paper addresses the practicability of translation validation for highly optimizing, industrial code generators from Signal, a widely used synchronous language, to C and introduces new abstraction techniques as part of the automation of this approach."
            },
            "venue": {
                "fragments": [],
                "text": "Correct System Design"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747890"
                        ],
                        "name": "O. Strichman",
                        "slug": "O.-Strichman",
                        "structuredName": {
                            "firstName": "Ofer",
                            "lastName": "Strichman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Strichman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "119614910"
                        ],
                        "name": "M. Siegel",
                        "slug": "M.-Siegel",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Siegel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Siegel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7986917,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bafdf991d57c42ebac181edcdd67aea00ae8907c",
            "isKey": false,
            "numCitedBy": 4,
            "numCiting": 13,
            "paperAbstract": {
                "fragments": [],
                "text": "Translation validation is an alternative to the verification of translators (compilers, code generators). Rather than proving in advance that the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code produced on this run correctly implements the submitted source program. In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation. \n \nIn this paper we demonstrate the feasibility of translation validation for industrial code generators from DC+ -a widely used intermediate format for synchronous languages- to C. We explain the compilation pattern from DC+ to C and advocate new abstraction techniques for a fragment of first order logic as part of the automation of our approach."
            },
            "slug": "Translation-Validation:-From-DC+-to-C*-Pnueli-Strichman",
            "title": {
                "fragments": [],
                "text": "Translation Validation: From DC+ to C*"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "The feasibility of translation validation for industrial code generators from DC+ -a widely used intermediate format for synchronous languages- to C is demonstrated and new abstraction techniques for a fragment of first order logic are advocated as part of the automation of this approach."
            },
            "venue": {
                "fragments": [],
                "text": "FM-Trends"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747890"
                        ],
                        "name": "O. Strichman",
                        "slug": "O.-Strichman",
                        "structuredName": {
                            "firstName": "Ofer",
                            "lastName": "Strichman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Strichman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "119614910"
                        ],
                        "name": "M. Siegel",
                        "slug": "M.-Siegel",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Siegel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Siegel"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 9192328,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d30135b8acf7bf25ad54c301ff4387628b41fb7e",
            "isKey": false,
            "numCitedBy": 69,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "Translation validations an alternative to the verification of translators (compilers, code generators). Rather than proving in advance that, the compiler always produces a target code which correctly implements the source code (compiler verification), each individual translation (i.e. a run of the compiler) is followed by a validation phase which verifies that the target code producted on this run correctly implements the submitted source program. In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation."
            },
            "slug": "Translation-Validation-for-Synchronous-Languages-Pnueli-Strichman",
            "title": {
                "fragments": [],
                "text": "Translation Validation for Synchronous Languages"
            },
            "tldr": {
                "abstractSimilarityScore": 51,
                "text": "In order to be a practical alternative to compiler verification, a key feature of this validation is its full automation."
            },
            "venue": {
                "fragments": [],
                "text": "ICALP"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1790411"
                        ],
                        "name": "G. Necula",
                        "slug": "G.-Necula",
                        "structuredName": {
                            "firstName": "George",
                            "lastName": "Necula",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Necula"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144577778"
                        ],
                        "name": "P. Lee",
                        "slug": "P.-Lee",
                        "structuredName": {
                            "firstName": "Peter",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Lee"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 988579,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bd881b522b9ec92f10cfdc3ffc68a2c33e386067",
            "isKey": false,
            "numCitedBy": 603,
            "numCiting": 63,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract : This paper describes a mechanism by which an operating system kernel can determine with certainty that it is safe to execute a binary supplied by an untrusted source. The kernel first defines a safety policy and makes it public. Then, using this policy, an application can provide binaries in a special form called proof-carrying code, or simply PCC. Each PCC binary contains, in addition to the native code, a formal proof that the code obeys the safety policy. The kernel can easily validate the proof without using cryptography and without consulting any external trusted entities. If the validation succeeds, the code is guaranteed to respect the safety policy without relying on run-time checks. The main practical difficulty of PCC is in generating the safety proofs. In order to gain some preliminary experience with this, we have written several network packet filters in hand-tuned DEC Alpha assembly language, and then generated PCC binaries for them using a special prototype assembler. The PCC binaries can be executed with no run-time over-head, beyond a one-time cost of 1 to 3 milliseconds for validating the enclosed proofs. The net result is that our packet filters are formally guaranteed to be safe and are faster than packet filters created using Berkeley Packet Filters, Software Fault Isolation, or safe languages such as Modula-3."
            },
            "slug": "Safe-kernel-extensions-without-run-time-checking-Necula-Lee",
            "title": {
                "fragments": [],
                "text": "Safe kernel extensions without run-time checking"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "PCC binaries can be executed with no run-time over-head, beyond a one-time cost of 1 to 3 milliseconds for validating the enclosed proofs, and are formally guaranteed to be safe and are faster than packet filters created using Berkeley Packet Filters, Software Fault Isolation, or safe languages such as Modula-3."
            },
            "venue": {
                "fragments": [],
                "text": "OSDI '96"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1685779"
                        ],
                        "name": "B. Alpern",
                        "slug": "B.-Alpern",
                        "structuredName": {
                            "firstName": "Bowen",
                            "lastName": "Alpern",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Alpern"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36114502"
                        ],
                        "name": "M. Wegman",
                        "slug": "M.-Wegman",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Wegman",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wegman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2386609"
                        ],
                        "name": "F. K. Zadeck",
                        "slug": "F.-K.-Zadeck",
                        "structuredName": {
                            "firstName": "F.",
                            "lastName": "Zadeck",
                            "middleNames": [
                                "Kenneth"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. K. Zadeck"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 18384941,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "237e9b0add47fc7660c0e6443d7918a904439f7f",
            "isKey": false,
            "numCitedBy": 488,
            "numCiting": 25,
            "paperAbstract": {
                "fragments": [],
                "text": "paper presents an algorithm for detecting when two computations produce equivalent values. The equivalence of programs, and hence the equivalence of values, is in general undecidable. Thus, the best one can hope to do is to give an efficient algorithm that detects a large subclass of all the possible equivalences in a program. Two variables are said to be equivalent at a point p if those variables contain the same values whenever control reaches p during any possible execution of the program. We will not examine all possible executions of the program. Instead, we will develop a static property called congruence. Congruence implies, but is not implied by, equivalence. Our approach is conservative in that any variables detected to be e:quivalent will in fact be equivalent, but not all equivalences are detected. Previous work has shown how to apply a technique c.alled value numbering in basic blocks [CS70]. Value numbering is essentially symbolic execution on straight-line programs (basic blocks). Symbolic execution implies that two expressions are assumed to be equal only when they consist of the same functions and the corresponding arguments of these functions are equal. An expression DAG is associated with each assignment statement. A hashing algorithm assigns a unique integer, the value number, to each different expression tree. Two variables that are assigned the same integer are guaranteed to be equivalent. After the code"
            },
            "slug": "Detecting-equality-of-variables-in-programs-Alpern-Wegman",
            "title": {
                "fragments": [],
                "text": "Detecting equality of variables in programs"
            },
            "tldr": {
                "abstractSimilarityScore": 57,
                "text": "An algorithm for detecting when two computations produce equivalent values by developing a static property called congruence, which is conservative in that any variables detected to be e:quivalent will in fact be equivalent, but not all equivalences are detected."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '88"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1770186"
                        ],
                        "name": "A. Benveniste",
                        "slug": "A.-Benveniste",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Benveniste",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Benveniste"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1705634"
                        ],
                        "name": "P. Guernic",
                        "slug": "P.-Guernic",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Guernic",
                            "middleNames": [
                                "Le"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Guernic"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33756802"
                        ],
                        "name": "C. Jacquemot",
                        "slug": "C.-Jacquemot",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Jacquemot",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Jacquemot"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 205066459,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "00106b56345414abba453c207548a4b162b94926",
            "isKey": false,
            "numCitedBy": 327,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Synchronous-Programming-with-Events-and-Relations:-Benveniste-Guernic",
            "title": {
                "fragments": [],
                "text": "Synchronous Programming with Events and Relations: the SIGNAL Language and Its Semantics"
            },
            "venue": {
                "fragments": [],
                "text": "Sci. Comput. Program."
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3304193"
                        ],
                        "name": "E. Shahar",
                        "slug": "E.-Shahar",
                        "structuredName": {
                            "firstName": "Elad",
                            "lastName": "Shahar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Shahar"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14859252,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d468ae8b9691dff0048d36117798d1ab229d0e9c",
            "isKey": false,
            "numCitedBy": 103,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "We describe a computer-aided verification system which combines deductive with algorithmic (model-checking) verification methods. The system, called tlv (for temporal verification system), is constructed as an additional layer superimposed on top of the cmu smv system, and can verify finite-state systems relative to linear temporal logic (ltl) as well as ctl specifications. The systems to be verified can be either hardware circuits written in the smv design language or finite-state reactive programs written in a simple programming language (spl)."
            },
            "slug": "A-Platform-for-Combining-Deductive-with-Algorithmic-Pnueli-Shahar",
            "title": {
                "fragments": [],
                "text": "A Platform for Combining Deductive with Algorithmic Verification"
            },
            "tldr": {
                "abstractSimilarityScore": 72,
                "text": "A computer-aided verification system which combines deductive with algorithmic (model-checking) verification methods, and can verify finite-state systems relative to linear temporal logic (ltl) as well as ctl specifications."
            },
            "venue": {
                "fragments": [],
                "text": "CAV"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144988710"
                        ],
                        "name": "B. Jonsson",
                        "slug": "B.-Jonsson",
                        "structuredName": {
                            "firstName": "Bengt",
                            "lastName": "Jonsson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Jonsson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 26394860,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5dff6ca48c1ab3f5863756134305f2586ff8721a",
            "isKey": false,
            "numCitedBy": 68,
            "numCiting": 28,
            "paperAbstract": {
                "fragments": [],
                "text": "In the stepwise development of a distributed system, the problem arises of verifying that a specification at a lower level of abstraction correctly implements a specification at a higher level of abstraction. Forward and backward simulation have been proposed as verification techniques for this problem. In this paper, we study forward and backward simulation in a framework where specifications are given as labeled transition systems with fairness requirements. We aim at clarifying the connection between simulations and the auxiliary variable constructions of Abadi and Lamport. In the paper, we also relax the earlier restriction that backward simulations be finitary. For a simple specification notation, similar to the action system formalism or Unity, we furthermore present proof rules that correspond to forward and backward simulations. Finally, we relate the forward and backward simulation techniques to subset-constructions that can be used in automata theory, e.g. for deciding language containment."
            },
            "slug": "Simulations-Between-Specifications-of-Distributed-Jonsson",
            "title": {
                "fragments": [],
                "text": "Simulations Between Specifications of Distributed Systems"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This paper aims at clarifying the connection between simulations and the auxiliary variable constructions of Abadi and Lamport, and relates the forward and backward simulation techniques to subset-constructions that can be used in automata theory, e.g. for deciding language containment."
            },
            "venue": {
                "fragments": [],
                "text": "CONCUR"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1686505"
                        ],
                        "name": "Z. Manna",
                        "slug": "Z.-Manna",
                        "structuredName": {
                            "firstName": "Zohar",
                            "lastName": "Manna",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Z. Manna"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 31485088,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ba6508eb538e5532c11c2cd80dca22beeefcf03d",
            "isKey": false,
            "numCitedBy": 1236,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "0: Preliminary Concepts.- 0.1 Fair Transition System.- 0.2 A Programming Language (SPL): Syntax.- 0.3 A Programming Language (SPL): Semantics.- 0.4 Modules.- 0.5 Temporal Logic.- 0.6 Specification of Properties.- 0.7 Overview of the Verification Framework.- Problems.- Bibliographic Remarks.- 1: Invariance: Proof Methods.- 1.1 Preliminary Notions.- 1.2 Invariance Rule.- 1.3 Finding Inductive Assertions: The Bottom-Up Approach.- 1.4 Finding Inductive Assertions: The Top-Down Approach.- 1.5 Refining Invariants.- Problems.- Bibliographic Remarks.- 2: Invariance: Applications.- 2.1 Parameterized Programs.- 2.2 Single-Resource Allocation.- 2.3 Multiple-Resource Allocation.- 2.4 Constructing Linear Invariants.- 2.5 Completeness.- 2.6 Finite-State Algorithmic Verification.- Problems.- Bibliographic Remarks.- 3: Precedence.- 3.1 Waiting-for Rule.- 3.2 Nested Waiting-for Rule.- 3.3 Verification Diagrams.- 3.4 Overtaking Analysis for a Resource Allocator.- * 3.5 Completeness.- * 3.6 Finite-State Algorithmic Verification.- Problems.- Bibliographic Remarks.- 4: General Safety.- 4.1 Invariance Rule for Past Formulas.- 4.2 Applications of the Past Invariance Rule.- 4.3 Compositional Verification.- 4.4 Causality Rule.- 4.5 Backward Analysis.- 4.6 Order-Preservation Properties.- 4.7 History Variables.- 4.8 Back-to Rule.- * 4.9 Completeness.- * 4.10 Finite-State Algorithmic Verification.- Problems.- Bibliographic Remarks.- 5: Algorithmic Verification of General Formulas.- 5.1 Satisfiability of a Temporal Formula.- 5.2 Satisfiability over a Finite-State Program.- 5.3 Validity over a Finite-State Program: Examples.- 5.4 Incremental Tableau Construction.- 5.5 Particle Tableaux.- Problems.- Bibliographic Remarks.- References.- Index to Symbols.- General Index."
            },
            "slug": "Temporal-verification-of-reactive-systems-safety-Manna-Pnueli",
            "title": {
                "fragments": [],
                "text": "Temporal verification of reactive systems - safety"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This paper presents a meta-language for estimating Satisfiability over a Finite-State Program: Examples and some examples of how such a program might be implemented in a number of different programming languages."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145832079"
                        ],
                        "name": "M. Abadi",
                        "slug": "M.-Abadi",
                        "structuredName": {
                            "firstName": "Mart\u00edn",
                            "lastName": "Abadi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Abadi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1679622"
                        ],
                        "name": "L. Lamport",
                        "slug": "L.-Lamport",
                        "structuredName": {
                            "firstName": "Leslie",
                            "lastName": "Lamport",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Lamport"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7927308,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "983c6d464e7e45c1320d9182a7ce39fef5575d1b",
            "isKey": false,
            "numCitedBy": 684,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "The-existence-of-refinement-mappings-Abadi-Lamport",
            "title": {
                "fragments": [],
                "text": "The existence of refinement mappings"
            },
            "venue": {
                "fragments": [],
                "text": "[1988] Proceedings. Third Annual Information Symposium on Logic in Computer Science"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145771081"
                        ],
                        "name": "D. Harel",
                        "slug": "D.-Harel",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Harel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Harel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 13380874,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "18493175642909909196e99b90a6af0bf3ef803b",
            "isKey": false,
            "numCitedBy": 7763,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Statecharts:-A-Visual-Formalism-for-Complex-Systems-Harel",
            "title": {
                "fragments": [],
                "text": "Statecharts: A Visual Formalism for Complex Systems"
            },
            "venue": {
                "fragments": [],
                "text": "Sci. Comput. Program."
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1802500"
                        ],
                        "name": "P. Caspi",
                        "slug": "P.-Caspi",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Caspi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Caspi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2862023"
                        ],
                        "name": "D. Pilaud",
                        "slug": "D.-Pilaud",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Pilaud",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Pilaud"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2578040"
                        ],
                        "name": "N. Halbwachs",
                        "slug": "N.-Halbwachs",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Halbwachs",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Halbwachs"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1723373"
                        ],
                        "name": "J. Plaice",
                        "slug": "J.-Plaice",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Plaice",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Plaice"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 18810875,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "58f4c5a8deb5a862adac4a44bd01eac2270b88fa",
            "isKey": false,
            "numCitedBy": 508,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "LUSTRE is a synchronous data-flow language for programming systems which interact with their environments in real-time. After an informal presentation of the language, we describe its semantics by means of structural inference rules. Moreover, we show how to use this semantics in order to generate efficient sequential code, namely, a finite state automaton which represents the control of the program. Formal rules for program transformation are also presented."
            },
            "slug": "LUSTRE:-a-declarative-language-for-real-time-Caspi-Pilaud",
            "title": {
                "fragments": [],
                "text": "LUSTRE: a declarative language for real-time programming"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "This work describes its semantics by means of structural inference rules and shows how to use this semantics in order to generate efficient sequential code, namely, a finite state automaton which represents the control of the program."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '87"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1679622"
                        ],
                        "name": "L. Lamport",
                        "slug": "L.-Lamport",
                        "structuredName": {
                            "firstName": "Leslie",
                            "lastName": "Lamport",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Lamport"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 5498471,
            "fieldsOfStudy": [
                "Computer Science",
                "Philosophy"
            ],
            "id": "1d93f38e3b26f413d9c40fe93d5337fe9975c4d2",
            "isKey": false,
            "numCitedBy": 2170,
            "numCiting": 85,
            "paperAbstract": {
                "fragments": [],
                "text": "The temporal logic of actions (TLA) is a logic for specifying and reasoning about concurrent systems. Systems and their properties are represented in the same logic, so the assertion that a system meets its specification and the assertion that one system implements another are both expressed by logical implication. TLA is very simple; its syntax and complete formal semantics are summarized in about a page. Yet, TLA is not just a logician's toy; it is extremely powerful, both in principle and in practice. This report introduces TLA and describes how it is used to specify and verify concurrent algorithms. The use of TLA to specify and reason about open systems will be described elsewhere."
            },
            "slug": "The-temporal-logic-of-actions-Lamport",
            "title": {
                "fragments": [],
                "text": "The temporal logic of actions"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This report introduces TLA and describes how it is used to specifying and verify concurrent algorithms and the use of TLA to specify and reason about open systems will be described elsewhere."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143607110"
                        ],
                        "name": "N. Shankar",
                        "slug": "N.-Shankar",
                        "structuredName": {
                            "firstName": "Natarajan",
                            "lastName": "Shankar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Shankar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1774977"
                        ],
                        "name": "Eli Singerman",
                        "slug": "Eli-Singerman",
                        "structuredName": {
                            "firstName": "Eli",
                            "lastName": "Singerman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Eli Singerman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2798612,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0949270a3ca414290909a326d9b26caa77e57ca7",
            "isKey": false,
            "numCitedBy": 23,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a compositional semantics of synchronous systems that captures both safety and progress properties of such systems. The fair synchronous transitions systems (Fsts) model we introduce in this paper extends the basic \u03b1Sts model [KP96] by introducing operations for parallel composition, for the restriction of variables, and by addressing fairness. We introduce a weak fairness (justice) condition which ensures that any communication deadlock in a system can only occur through the need for external synchronization. We present an extended version of linear time temporal logic (Eltl) for expressing and proving safety and liveness properties of synchronous specifications, and provide a sound and compositional proof system for it."
            },
            "slug": "Fair-Synchronous-Transition-Systems-and-Their-Pnueli-Shankar",
            "title": {
                "fragments": [],
                "text": "Fair Synchronous Transition Systems and Their Liveness Proofs"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "An extended version of linear time temporal logic (Eltl) is presented for expressing and proving safety and liveness properties of synchronous specifications, and a sound and compositional proof system for it is provided."
            },
            "venue": {
                "fragments": [],
                "text": "FTRTFT"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145390591"
                        ],
                        "name": "N. Lynch",
                        "slug": "N.-Lynch",
                        "structuredName": {
                            "firstName": "Nancy",
                            "lastName": "Lynch",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Lynch"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1678787"
                        ],
                        "name": "F. Vaandrager",
                        "slug": "F.-Vaandrager",
                        "structuredName": {
                            "firstName": "Frits",
                            "lastName": "Vaandrager",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Vaandrager"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1940991,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b7b53dd7e41e7a677b15b6ed8cbb00229d6d572a",
            "isKey": false,
            "numCitedBy": 175,
            "numCiting": 80,
            "paperAbstract": {
                "fragments": [],
                "text": "A general automaton model for timing-based systems is presented and is used as the context for developing a variety of simulation proof techniques for such systems. As a first step, a comprehensive overview of simulation techniques for simple untimed automata is given. In particular, soundness and completeness results for (1) refinements, (2) forward and backward simulations, (3) forward-backward and backward-forward simulations, and (4) history and prophecy relations are given. History and prophecy relations are new and are abstractions of the history variables of Owicki and Gries and the prophecy variables of Abadi and Lamport, respectively. As a subsequent step, it is shown how most of the results for untimed automata can be carried over to the setting of timed automata. In fact many of the results for the timed case are obtained as consequences of the analogous results for the untimed case."
            },
            "slug": "Forward-and-Backward-Simulations-for-Timing-Based-Lynch-Vaandrager",
            "title": {
                "fragments": [],
                "text": "Forward and Backward Simulations for Timing-Based Systems"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "A general automaton model for timing-based systems is presented and is used as the context for developing a variety of simulation proof techniques for such systems."
            },
            "venue": {
                "fragments": [],
                "text": "REX Workshop"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1750896"
                        ],
                        "name": "Y. Kesten",
                        "slug": "Y.-Kesten",
                        "structuredName": {
                            "firstName": "Yonit",
                            "lastName": "Kesten",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Kesten"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1686505"
                        ],
                        "name": "Z. Manna",
                        "slug": "Z.-Manna",
                        "structuredName": {
                            "firstName": "Zohar",
                            "lastName": "Manna",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Z. Manna"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 35906589,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7c698877cc3c5c3dcbe3daa356ab763fccac58cf",
            "isKey": false,
            "numCitedBy": 66,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "The paper presents temporal logic methods for proving simulation and refinement relations between programs. After introducing the notions of fair transition systems and the specification language of temporal logic, we present proof rules for verifying properties of programs. We then define the relations of simulation and refinement between programs and relate them to inclusion relations between computations and observations of the compared systems."
            },
            "slug": "Temporal-Verification-of-Simulation-and-Refinement-Kesten-Manna",
            "title": {
                "fragments": [],
                "text": "Temporal Verification of Simulation and Refinement"
            },
            "tldr": {
                "abstractSimilarityScore": 73,
                "text": "The paper presents temporal logic methods for proving simulation and refinement relations between programs and relates them to inclusion relations between computations and observations of the compared systems."
            },
            "venue": {
                "fragments": [],
                "text": "REX School/Symposium"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69048861"
                        ],
                        "name": "R. Cytron",
                        "slug": "R.-Cytron",
                        "structuredName": {
                            "firstName": "Ronald",
                            "lastName": "Cytron",
                            "middleNames": [
                                "Gary"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Cytron"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144704592"
                        ],
                        "name": "J. Ferrante",
                        "slug": "J.-Ferrante",
                        "structuredName": {
                            "firstName": "Jeanne",
                            "lastName": "Ferrante",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ferrante"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1685689"
                        ],
                        "name": "B. Rosen",
                        "slug": "B.-Rosen",
                        "structuredName": {
                            "firstName": "Barry",
                            "lastName": "Rosen",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Rosen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36114502"
                        ],
                        "name": "M. Wegman",
                        "slug": "M.-Wegman",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Wegman",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wegman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2386609"
                        ],
                        "name": "F. K. Zadeck",
                        "slug": "F.-K.-Zadeck",
                        "structuredName": {
                            "firstName": "F.",
                            "lastName": "Zadeck",
                            "middleNames": [
                                "Kenneth"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. K. Zadeck"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 13243943,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cd65db4d7091b8f42333ed755ed7150f14b3be5c",
            "isKey": false,
            "numCitedBy": 2354,
            "numCiting": 84,
            "paperAbstract": {
                "fragments": [],
                "text": "In optimizing compilers, data structure choices directly influence the power and efficiency of practical program optimization. A poor choice of data structure can inhibit optimization or slow compilation to the point that advanced optimization features become undesirable. Recently, static single assignment form and the control dependence graph have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. Although both of these structures are attractive, the difficulty of their construction and their potential size have discouraged their use. We present new algorithms that efficiently compute these data structures for arbitrary control flow graphs. The algorithms use {\\em dominance frontiers}, a new concept that may have other applications. We also give analytical and experimental evidence that all of these data structures are usually linear in the size of the original program. This paper thus presents strong evidence that these structures can be of practical use in optimization."
            },
            "slug": "Efficiently-computing-static-single-assignment-form-Cytron-Ferrante",
            "title": {
                "fragments": [],
                "text": "Efficiently computing static single assignment form and the control dependence graph"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "New algorithms that efficiently compute static single assignment form and control dependence graph data structures for arbitrary control flow graphs are presented and it is given that all of these data structures are usually linear in the size of the original program."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1802500"
                        ],
                        "name": "P. Caspi",
                        "slug": "P.-Caspi",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Caspi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Caspi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2862023"
                        ],
                        "name": "D. Pilaud",
                        "slug": "D.-Pilaud",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Pilaud",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Pilaud"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2578040"
                        ],
                        "name": "N. Halbwachs",
                        "slug": "N.-Halbwachs",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Halbwachs",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Halbwachs"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1723373"
                        ],
                        "name": "J. Plaice",
                        "slug": "J.-Plaice",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Plaice",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Plaice"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 209399818,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "893b9e21f01df1f14a922d2e4eb863be9ecb25d2",
            "isKey": false,
            "numCitedBy": 658,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents the language LUSTRE, whose main application field is the programming of automatic control and signal processing systems. In this field, design is tra- ditionally driven by means of two types of tools. First, specifications are often systems of equations (differential or finite difference equations, boolean equations, . . .). Second, implementations are often nets of operators connected with wires (switches, gates, analog diagrams). Such tools present several ad&tag- as a basis for"
            },
            "slug": "LUSTRE:-A-declarative-language-for-programming-Caspi-Pilaud",
            "title": {
                "fragments": [],
                "text": "LUSTRE: A declarative language for programming synchronous systems*"
            },
            "tldr": {
                "abstractSimilarityScore": 82,
                "text": "This paper presents the language LUSTRE, whose main application field is the programming of automatic control and signal processing systems, and uses it as a basis for designing and programming these systems."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1765456"
                        ],
                        "name": "S. Cook",
                        "slug": "S.-Cook",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Cook",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Cook"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7573663,
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "id": "1a8d2e5bb9c646d85308fbd6ce33fce8765e2c26",
            "isKey": false,
            "numCitedBy": 6591,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "It is shown that any recognition problem solved by a polynomial time-bounded nondeterministic Turing machine can be \u201creduced\u201d to the problem of determining whether a given propositional formula is a tautology. Here \u201creduced\u201d means, roughly speaking, that the first problem can be solved deterministically in polynomial time provided an oracle is available for solving the second. From this notion of reducible, polynomial degrees of difficulty are defined, and it is shown that the problem of determining tautologyhood has the same polynomial degree as the problem of determining whether the first of two given graphs is isomorphic to a subgraph of the second. Other examples are discussed. A method of measuring the complexity of proof procedures for the predicate calculus is introduced and discussed."
            },
            "slug": "The-complexity-of-theorem-proving-procedures-Cook",
            "title": {
                "fragments": [],
                "text": "The complexity of theorem-proving procedures"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "It is shown that any recognition problem solved by a polynomial time-bounded nondeterministic Turing machine can be \u201creduced\u201d to the problem of determining whether a given propositional formula is a tautology."
            },
            "venue": {
                "fragments": [],
                "text": "STOC"
            },
            "year": 1971
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1686505"
                        ],
                        "name": "Z. Manna",
                        "slug": "Z.-Manna",
                        "structuredName": {
                            "firstName": "Zohar",
                            "lastName": "Manna",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Z. Manna"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 34600346,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b570e945deb4ca308830be2810c45100854ec16a",
            "isKey": false,
            "numCitedBy": 3940,
            "numCiting": 144,
            "paperAbstract": {
                "fragments": [],
                "text": "Reactive systems are computing systems which are interactive, such as real-time systems, operating systems, concurrent systems and control systems. These are among the most difficult computing systems to program. Temporal logic is a formal tool/language which yields excellent results in specifying reactive systems, and this volume (the first of two), offers an introduction to temporal logic and to the computational model for reactive programs which has been developed by the authors."
            },
            "slug": "The-Temporal-Logic-of-Reactive-and-Concurrent-Manna-Pnueli",
            "title": {
                "fragments": [],
                "text": "The Temporal Logic of Reactive and Concurrent Systems"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This volume offers an introduction to temporal logic and to the computational model for reactive programs which has been developed by the authors."
            },
            "venue": {
                "fragments": [],
                "text": "Springer New York"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48622893"
                        ],
                        "name": "H. Rice",
                        "slug": "H.-Rice",
                        "structuredName": {
                            "firstName": "H.",
                            "lastName": "Rice",
                            "middleNames": [
                                "Gordon"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Rice"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 120980829,
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "id": "664a7d3c60b753a34f1601a7378ca952ea92e9a8",
            "isKey": false,
            "numCitedBy": 699,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "1. Introduction. In this paper we consider classes whose elements are re-cursively enumerable sets of non-negative integers. No discussion of recur-sively enumerable sets can avoid the use of such classes, so that it seems desirable to know some of their properties. We give our attention here to the properties of complete recursive enumerability and complete recursiveness (which may be intuitively interpreted as decidability). Perhaps our most interesting result (and the one which gives this paper its name) is the fact that no nontrivial class is completely recursive. We assume familiarity with a paper of Kleene [5](2), and with ideas which are well summarized in the first sections of a paper of Post \u00cd7]."
            },
            "slug": "Classes-of-recursively-enumerable-sets-and-their-Rice",
            "title": {
                "fragments": [],
                "text": "Classes of recursively enumerable sets and their decision problems"
            },
            "tldr": {
                "abstractSimilarityScore": 75,
                "text": "This paper considers classes whose elements are re-cursively enumerable sets of non-negative integers whose properties are complete recursive enumerability and complete recursiveness."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1953
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143606221"
                        ],
                        "name": "J. Ban\u00e2tre",
                        "slug": "J.-Ban\u00e2tre",
                        "structuredName": {
                            "firstName": "Jean-Pierre",
                            "lastName": "Ban\u00e2tre",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ban\u00e2tre"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 40224256,
            "fieldsOfStudy": [
                "Engineering"
            ],
            "id": "ce7b7223d0fab7b54897a77d873380d444152cd5",
            "isKey": false,
            "numCitedBy": 164,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "A monolithically integrated semiconductor circuit, provided for coupling arrangements having symmetrical cross points, comprising two through switching NPN transistors, and a composite circuit for switching through the switching transistors. The composite circuit includes a double collector PNP transistor, with one collector connected to the base of a first NPN transistor and the other collector connected to the base of a second NPN transistor. The emitter of the double collector transistor is connected to the collector of both NPN transistors and also, via a first resistor to a voltage source. The base of the double collector transistor is connected, via a component causing a constant drop in voltage, to the voltage source, and also via a second resistor, to a trigger stage. The emitters of the NPN transistor are connected, respectively, to the bases of the two through switching transistors."
            },
            "slug": "Parallel-Program-Design-Ban\u00e2tre",
            "title": {
                "fragments": [],
                "text": "Parallel Program Design"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "A monolithically integrated semiconductor circuit, provided for coupling arrangements having symmetrical cross points, comprising two through switching NPN transistors, and a composite circuit for switching through the switching transistors."
            },
            "venue": {
                "fragments": [],
                "text": "Research Directions in High-Level Parallel Programming Languages"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "5876979"
                        ],
                        "name": "W. Ackermann",
                        "slug": "W.-Ackermann",
                        "structuredName": {
                            "firstName": "Wilhelm",
                            "lastName": "Ackermann",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Ackermann"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 118843348,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "03302e6153b33e5476df7ae654357151cac0c4ef",
            "isKey": false,
            "numCitedBy": 374,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Solvable-Cases-Of-The-Decision-Problem-Ackermann",
            "title": {
                "fragments": [],
                "text": "Solvable Cases Of The Decision Problem"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1954
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1686505"
                        ],
                        "name": "Z. Manna",
                        "slug": "Z.-Manna",
                        "structuredName": {
                            "firstName": "Zohar",
                            "lastName": "Manna",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Z. Manna"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6590516,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ed80e5937f2371dc57bbd24228410ce6e74599aa",
            "isKey": false,
            "numCitedBy": 753,
            "numCiting": 145,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Temporal-Verification-of-Reactive-Systems-Manna-Pnueli",
            "title": {
                "fragments": [],
                "text": "Temporal Verification of Reactive Systems"
            },
            "venue": {
                "fragments": [],
                "text": "Springer New York"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1742667"
                        ],
                        "name": "A. Cimatti",
                        "slug": "A.-Cimatti",
                        "structuredName": {
                            "firstName": "Alessandro",
                            "lastName": "Cimatti",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Cimatti"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720285"
                        ],
                        "name": "Fausto Giunchiglia",
                        "slug": "Fausto-Giunchiglia",
                        "structuredName": {
                            "firstName": "Fausto",
                            "lastName": "Giunchiglia",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Fausto Giunchiglia"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2375263"
                        ],
                        "name": "P. Pecchiari",
                        "slug": "P.-Pecchiari",
                        "structuredName": {
                            "firstName": "Paolo",
                            "lastName": "Pecchiari",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Pecchiari"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50378412"
                        ],
                        "name": "B. Pietra",
                        "slug": "B.-Pietra",
                        "structuredName": {
                            "firstName": "Bruno",
                            "lastName": "Pietra",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Pietra"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48732532"
                        ],
                        "name": "J. Profeta",
                        "slug": "J.-Profeta",
                        "structuredName": {
                            "firstName": "Joseph",
                            "lastName": "Profeta",
                            "middleNames": [
                                "A."
                            ],
                            "suffix": "III"
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Profeta"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143767165"
                        ],
                        "name": "Dario Romano",
                        "slug": "Dario-Romano",
                        "structuredName": {
                            "firstName": "Dario",
                            "lastName": "Romano",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dario Romano"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145919532"
                        ],
                        "name": "P. Traverso",
                        "slug": "P.-Traverso",
                        "structuredName": {
                            "firstName": "Paolo",
                            "lastName": "Traverso",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Traverso"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46806278"
                        ],
                        "name": "Ting Yu",
                        "slug": "Ting-Yu",
                        "structuredName": {
                            "firstName": "Ting",
                            "lastName": "Yu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ting Yu"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 42078252,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6b3470705265984a7f2e2ca87eba19b7b632ded8",
            "isKey": false,
            "numCitedBy": 29,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "Vframe is one of Ansaldo's software driven vital architectures for safety critical products. This paper describes a project whose result is the development of an \u201cembedded verifier\u201d, i.e. a system integrated within Vframe and able to certify the correctness of one of Vframe components, a compiler. The embedded verifier satisfies two precise requirements. First, the compiler must be certified in a fully automatic and efficient way. Second, the embedded verifier must be itself certified, in a way which can be easily understood and validated by end users."
            },
            "slug": "A-Provably-Correct-Embedded-Verifier-for-the-of-Cimatti-Giunchiglia",
            "title": {
                "fragments": [],
                "text": "A Provably Correct Embedded Verifier for the Certification of Safety Critical Software"
            },
            "tldr": {
                "abstractSimilarityScore": 54,
                "text": "This paper describes a project whose result is the development of an \u201cembedded verifier\u201d, i.e. a system integrated within Vframe and able to certify the correctness of one of Vframe components, a compiler."
            },
            "venue": {
                "fragments": [],
                "text": "CAV"
            },
            "year": 1997
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Temporal veriication of simulation and reenement"
            },
            "venue": {
                "fragments": [],
                "text": "Decade of Concurrency, volume 803 of Lect. Notes in Comp. Sci"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Synchronous Programming Language Esterel , Design, Semantics, Implementation"
            },
            "venue": {
                "fragments": [],
                "text": "The Synchronous Programming Language Esterel , Design, Semantics, Implementation"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The existence of reenement mappings"
            },
            "venue": {
                "fragments": [],
                "text": "Theoretical Computer Science"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Intl. Conference on Computer Aided Veriication (CAV'96), Lect. Notes in Comp. Sci., pages 184{195"
            },
            "venue": {
                "fragments": [],
                "text": "Intl. Conference on Computer Aided Veriication (CAV'96), Lect. Notes in Comp. Sci., pages 184{195"
            },
            "year": 1996
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Simulations between speciications of distributed systems"
            },
            "venue": {
                "fragments": [],
                "text": "CONCUR '91"
            },
            "year": 1991
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {},
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 30,
        "totalPages": 3
    },
    "page_url": "https://www.semanticscholar.org/paper/Translation-Validation-Pnueli-Siegel/d8b4164fef65ffc7082a3c95b0a706e5c3aa38f9?sort=total-citations"
}