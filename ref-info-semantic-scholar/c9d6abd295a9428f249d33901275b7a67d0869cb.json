{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8887400"
                        ],
                        "name": "J. Lo",
                        "slug": "J.-Lo",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Lo",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Lo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2010354"
                        ],
                        "name": "S. Eggers",
                        "slug": "S.-Eggers",
                        "structuredName": {
                            "firstName": "Susan",
                            "lastName": "Eggers",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Eggers"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1775477"
                        ],
                        "name": "J. Emer",
                        "slug": "J.-Emer",
                        "structuredName": {
                            "firstName": "Joel",
                            "lastName": "Emer",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Emer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36105267"
                        ],
                        "name": "H. Levy",
                        "slug": "H.-Levy",
                        "structuredName": {
                            "firstName": "Henry",
                            "lastName": "Levy",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Levy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39731062"
                        ],
                        "name": "Rebecca L. Stamm",
                        "slug": "Rebecca-L.-Stamm",
                        "structuredName": {
                            "firstName": "Rebecca",
                            "lastName": "Stamm",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Rebecca L. Stamm"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1740142"
                        ],
                        "name": "D. Tullsen",
                        "slug": "D.-Tullsen",
                        "structuredName": {
                            "firstName": "Dean",
                            "lastName": "Tullsen",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Tullsen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 5153803,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2c310c190d98940734f5bd601f94503bbac2b1b4",
            "isKey": false,
            "numCitedBy": 282,
            "numCiting": 54,
            "paperAbstract": {
                "fragments": [],
                "text": "To achieve high performance, contemporary computer systems rely on two forms of parallelism: instruction-level parallelism (ILP) and thread-level parallelism (TLP). Wide-issue super-scalar processors exploit ILP by executing multiple instructions from a single program in a single cycle. Multiprocessors (MP) exploit TLP by executing different threads in parallel on different processors. Unfortunately, both parallel processing styles statically partition processor resources, thus preventing them from adapting to dynamically changing levels of ILP and TLP in a program. With insufficient TLP, processors in an MP will be idle; with insufficient ILP, multiple-issue hardware on a superscalar is wasted. This article explores parallel processing on an alternative architecture, simultaneous multithreading (SMT), which allows multiple threads to complete for and share all of the processor's resources every cycle.\nThe most compelling reason for running parallel applications on an SMT processor is its ability to use thread-level parallelism and instruction-level parallelism interchangeably. By permitting multiple threads to share the processor's functional units simultaneously, the processor can use both ILP and TLP to accommodate variations in parallelism. When a program has only a single thread, all of the SMT processor's resources can be dedicated to that thread; when more TLP exists, this parallelism can compensate for a lack of per-thread ILP. \nWe examine two alternative on-chip parallel architectures for the next generation of processors. We compare SMT and small-scale, on-chip multiprocessors in their ability to exploit both ILP and TLP. First, we identify the hardware bottlenecks that prevent multiprocessors from effectively exploiting ILP. Then, we show that because of its dynamic resource sharing, SMT avoids these inefficiencies and benefits from being able to run more threads on a single processor. The use of TLP is especially advantageous when per-thread ILP is limited. The ease of adding additional thread contexts on an SMT (relative to adding additional processors on an MP) allows simultaneous multithreading to expose more parallelism, further increasing functional unit utilization and attaining a 52% average speedup (versus a four-processor, single-chip multiprocessor with comparable execution resources). This study also addresses an often-cited concern regarding the use of thread-level parallelism or multithreading: interference in the memory system and branch prediction hardware.\nWe find the multiple threads cause interthread interference in the caches and place greater demands on the memory system, thus increasing average memory latencies. By exploiting threading-level parallelism, however, SMT hides these additional latencies, so that they only have a small impact on total program performance. We also find that for parallel applications, the additional threads have minimal effects on branch prediction."
            },
            "slug": "Converting-thread-level-parallelism-to-parallelism-Lo-Eggers",
            "title": {
                "fragments": [],
                "text": "Converting thread-level parallelism to instruction-level parallelism via simultaneous multithreading"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This article identifies the hardware bottlenecks that prevent multiprocessors from effectively exploiting ILP and TLP, and shows that because of its dynamic resource sharing, SMT avoids these inefficiencies and benefits from being able to run more threads on a single processor."
            },
            "venue": {
                "fragments": [],
                "text": "TOCS"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50378473"
                        ],
                        "name": "Hiroaki Hirata",
                        "slug": "Hiroaki-Hirata",
                        "structuredName": {
                            "firstName": "Hiroaki",
                            "lastName": "Hirata",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Hiroaki Hirata"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2361817"
                        ],
                        "name": "K. Kimura",
                        "slug": "K.-Kimura",
                        "structuredName": {
                            "firstName": "Kozo",
                            "lastName": "Kimura",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kimura"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50000814"
                        ],
                        "name": "Satoshi Nagamine",
                        "slug": "Satoshi-Nagamine",
                        "structuredName": {
                            "firstName": "Satoshi",
                            "lastName": "Nagamine",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Satoshi Nagamine"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2964047"
                        ],
                        "name": "Y. Mochizuki",
                        "slug": "Y.-Mochizuki",
                        "structuredName": {
                            "firstName": "Yoshiyuki",
                            "lastName": "Mochizuki",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Mochizuki"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48664421"
                        ],
                        "name": "A. Nishimura",
                        "slug": "A.-Nishimura",
                        "structuredName": {
                            "firstName": "Akio",
                            "lastName": "Nishimura",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Nishimura"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2625487"
                        ],
                        "name": "Y. Nakase",
                        "slug": "Y.-Nakase",
                        "structuredName": {
                            "firstName": "Yoshimori",
                            "lastName": "Nakase",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Nakase"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2052780858"
                        ],
                        "name": "T. Nishizawa",
                        "slug": "T.-Nishizawa",
                        "structuredName": {
                            "firstName": "Teiji",
                            "lastName": "Nishizawa",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Nishizawa"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 79,
                                "start": 74
                            }
                        ],
                        "text": "Figure 1b shows a sequence from a multithreaded architecture, such as the Tera.1 Multithreaded processors contain hardware state (a program counter and registers) for several threads."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 82,
                                "start": 79
                            }
                        ],
                        "text": "Figure 1b shows a sequence from a multithreaded architecture, such as the Tera.(1) Multithreaded processors contain hardware state (a program counter and registers) for several threads."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 2806090,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bd4d17ae3ffa793ecdcc63e095d95092d1957e38",
            "isKey": false,
            "numCitedBy": 158,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": "In this paper, we propose a multithreaded processor architecture which improves machine throughput. In our processor architecture, instructions from different threads (not a single thread) are issued simultaneously to multiple functional units, and these instructions can begin execution unless there are functional unit conflicts. This parallel execution scheme greatly improves the utilization of the functional unit. Simulation results show that by executing two and four threads in parallel on a nine-functional-unit processor, a 2.02 and a 3.72 times speed-up, respectively, can be achieved over a conventional RISC processor. Our architecture is also applicable to the efficient execution of a single loop. In order to control functional unit conflicts between loop iterations, we have developed a new static code scheduling technique. Another loop execution scheme, by using the multiple control flow mechanism of our architecture, makes it possible to parallelize loops which are difficult to parallelize in vector or VLIW machines."
            },
            "slug": "An-Elementary-Processor-Architecture-with-Issuing-Hirata-Kimura",
            "title": {
                "fragments": [],
                "text": "An Elementary Processor Architecture with Simultaneous Instruction Issuing from Multiple Threads"
            },
            "tldr": {
                "abstractSimilarityScore": 54,
                "text": "A multithreaded processor architecture which improves machine throughput and control functional unit conflicts between loop iterations, and a new static code scheduling technique which makes it possible to parallelize loops which are difficult to parallelizing in vector or VLIW machines."
            },
            "venue": {
                "fragments": [],
                "text": "[1992] Proceedings the 19th Annual International Symposium on Computer Architecture"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "51938248"
                        ],
                        "name": "Stephem W. Keckler",
                        "slug": "Stephem-W.-Keckler",
                        "structuredName": {
                            "firstName": "Stephem",
                            "lastName": "Keckler",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stephem W. Keckler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "80724002"
                        ],
                        "name": "W. Dally",
                        "slug": "W.-Dally",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Dally",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Dally"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1872767,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "655f25a016d6f1b9a5d1c160ca675059289c18f9",
            "isKey": false,
            "numCitedBy": 119,
            "numCiting": 35,
            "paperAbstract": {
                "fragments": [],
                "text": "The technology to implement a single-chip node composed of 4 high-performance floating-point ALUs will be available by 1995. This paper presents processor coupling, a mechanism for controlling multiple ALUs to exploit both instruction-level and inter- thread parallelism, by using compile time and runtime scheduling. The compiler statically schedules individual threads to discover available inter-thread instruction-level parallelism. The runtime scheduling mechanism interleaves threads, exploiting inter-thread parallelism to maintain high ALU utilization. ALUs are assigned to threads on a cycle by cycle basis, and several threads can be active concurrently. We provide simulation results demonstrating that, on four simple numerical benchmarks, processor coupling achieves better performance than purely statically scheduled or multi-processor machine organizations. We examine how performance is affected by restricted communication between ALUs and by long memory latencies. We also present an implementation and feasibility study of a processor coupled node."
            },
            "slug": "Processor-Coupling:-Integrating-Compile-Time-and-Keckler-Dally",
            "title": {
                "fragments": [],
                "text": "Processor Coupling: Integrating Compile Time and Runtime Scheduling for Parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "Simulation results demonstrating that, on four simple numerical benchmarks, processor coupling achieves better performance than purely statically scheduled or multi-processor machine organizations are provided."
            },
            "venue": {
                "fragments": [],
                "text": "[1992] Proceedings the 19th Annual International Symposium on Computer Architecture"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1740142"
                        ],
                        "name": "D. Tullsen",
                        "slug": "D.-Tullsen",
                        "structuredName": {
                            "firstName": "Dean",
                            "lastName": "Tullsen",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Tullsen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2010354"
                        ],
                        "name": "S. Eggers",
                        "slug": "S.-Eggers",
                        "structuredName": {
                            "firstName": "Susan",
                            "lastName": "Eggers",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Eggers"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1775477"
                        ],
                        "name": "J. Emer",
                        "slug": "J.-Emer",
                        "structuredName": {
                            "firstName": "Joel",
                            "lastName": "Emer",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Emer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36105267"
                        ],
                        "name": "H. Levy",
                        "slug": "H.-Levy",
                        "structuredName": {
                            "firstName": "Henry",
                            "lastName": "Levy",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Levy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8887400"
                        ],
                        "name": "J. Lo",
                        "slug": "J.-Lo",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Lo",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Lo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39731062"
                        ],
                        "name": "Rebecca L. Stamm",
                        "slug": "Rebecca-L.-Stamm",
                        "structuredName": {
                            "firstName": "Rebecca",
                            "lastName": "Stamm",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Rebecca L. Stamm"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1402376,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "13cfa3d9647a88f9420666ae0b6c7deac1031c32",
            "isKey": false,
            "numCitedBy": 683,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": "Simultaneous multithreading is a technique that permits multiple independent threads to issue multiple instructions each cycle. In previous work we demonstrated the performance potential of simultaneous multithreading, based on a somewhat idealized model. In this paper we show that the throughput gains from simultaneous multithreading can be achieved without extensive changes to a conventional wide-issue superscalar, either in hardware structures or sizes. We present an architecture for simultaneous multithreading that achieves three goals: (1) it minimizes the architectural impact on the conventional superscalar design, (2) it has minimal performance impact on a single thread executing alone, and (3) it achieves significant throughput gains when running multiple threads. Our simultaneous multithreading architecture achieves a throughput of 5.4 instructions per cycle, a 2.5-fold improvement over an unmodified superscalar with similar hardware resources. This speedup is enhanced by an advantage of multithreading previously unexploited in other architectures: the ability to favor for fetch and issue those threads most efficiently using the processor each cycle, thereby providing the \"best\" instructions to the processor."
            },
            "slug": "Exploiting-Choice:-Instruction-Fetch-and-Issue-on-Tullsen-Eggers",
            "title": {
                "fragments": [],
                "text": "Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading Processor"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This paper presents an architecture for simultaneous multithreading that minimizes the architectural impact on the conventional superscalar design, has minimal performance impact on a single thread executing alone, and achieves significant throughput gains when running multiple threads."
            },
            "venue": {
                "fragments": [],
                "text": "23rd Annual International Symposium on Computer Architecture (ISCA'96)"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2858862"
                        ],
                        "name": "M. Gulati",
                        "slug": "M.-Gulati",
                        "structuredName": {
                            "firstName": "Manu",
                            "lastName": "Gulati",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Gulati"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1689483"
                        ],
                        "name": "N. Bagherzadeh",
                        "slug": "N.-Bagherzadeh",
                        "structuredName": {
                            "firstName": "Nader",
                            "lastName": "Bagherzadeh",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Bagherzadeh"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 67,
                                "start": 64
                            }
                        ],
                        "text": "In addition to our previous work on SMT, Gulati and Bagherzadeh [4] also proposed extensions to superscalar processors to implement simultaneous multithreading."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1760177,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cd189393b7d7c8d88487699e49eaf89672e8cd4e",
            "isKey": false,
            "numCitedBy": 65,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes a technique for improving the performance of a superscalar processor through multithreading. The technique exploits the instruction-level parallelism available both inside each individual stream, and across streams. The former is exploited through out-of-order execution of instructions within a stream, and the latter through execution of instructions from different streams simultaneously. Aspects of multithreaded superscalar design, such as fetch policy, cache performance, instruction scheduling, and functional unit utilization are studied. We analyze performance based on the simulation of a superscalar architecture and show that it is possible to provide support for multiple streams with minimal extra hardware, yet achieving significant performance gain (20-55%) across a range of benchmarks."
            },
            "slug": "Performance-study-of-a-multithreaded-superscalar-Gulati-Bagherzadeh",
            "title": {
                "fragments": [],
                "text": "Performance study of a multithreaded superscalar microprocessor"
            },
            "tldr": {
                "abstractSimilarityScore": 64,
                "text": "This paper describes a technique for improving the performance of a superscalar processor through multithreading and shows that it is possible to provide support for multiple streams with minimal extra hardware, yet achieving significant performance gain across a range of benchmarks."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. Second International Symposium on High-Performance Computer Architecture"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1740142"
                        ],
                        "name": "D. Tullsen",
                        "slug": "D.-Tullsen",
                        "structuredName": {
                            "firstName": "Dean",
                            "lastName": "Tullsen",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Tullsen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2010354"
                        ],
                        "name": "S. Eggers",
                        "slug": "S.-Eggers",
                        "structuredName": {
                            "firstName": "Susan",
                            "lastName": "Eggers",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Eggers"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36105267"
                        ],
                        "name": "H. Levy",
                        "slug": "H.-Levy",
                        "structuredName": {
                            "firstName": "Henry",
                            "lastName": "Levy",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Levy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 6,
                                "start": 2
                            }
                        ],
                        "text": ", [11] we evaluated the potential of SMT , comparing performance of SMT with superscalars, multithreaded processors, and multiprocessors, using a more abstract processor model and an older (SPEC92) workload."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 37853,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e157c785bdaf68c208f00e559ee4980837df153b",
            "isKey": false,
            "numCitedBy": 1730,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper examines simultaneous multithreading, a technique permitting several independent threads to issue instructions to a superscalar's multiple functional units in a single cycle. We present several models of simultaneous multithreading and compare them with alternative organizations: a wide superscalar, a fine-grain multithreaded processor, and single-chip, multiple-issue multiprocessing architectures. Our results show that both (single-threaded) superscalar and fine-grain multithreaded architectures are limited in their ability to utilize the resources of a wide-issue processor. Simultaneous multithreading has the potential to achieve 4 times the throughput of a superscalar, and double that of fine-grain multi-threading. We evaluate several cache configurations made possible by this type of organization and evaluate tradeoffs between them. We also show that simultaneous multithreading is an attractive alternative to single-chip multiprocessors; simultaneous multithreaded processors with a variety of organizations outperform corresponding conventional multiprocessors with similar execution resources. While simultaneous multithreading has excellent potential to increase processor utilization, it can add substantial complexity to the design. We examine many of these complexities and evaluate alternative organizations in the design space."
            },
            "slug": "Simultaneous-multithreading:-Maximizing-on-chip-Tullsen-Eggers",
            "title": {
                "fragments": [],
                "text": "Simultaneous multithreading: Maximizing on-chip parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "Simultaneous multithreading has the potential to achieve 4 times the throughput of a superscalar, and double that of fine-grain multi-threading, and is an attractive alternative to single-chip multiprocessors."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings 22nd Annual International Symposium on Computer Architecture"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7490723,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cbd57131407afdcf0c6acf42e02bd70d6de461d8",
            "isKey": false,
            "numCitedBy": 686,
            "numCiting": 129,
            "paperAbstract": {
                "fragments": [],
                "text": "Growing interest in ambitious multiple-issue machines and heavilypipelined machines requires a careful examination of how much instructionlevel parallelism exists in typical programs. Such an examination is complicated by the wide variety of hardware and software techniques for increasing the parallelism that can be exploited, including branch prediction, register renaming, and alias analysis. By performing simulations based on instruction traces, we can model techniques at the limits of feasibility and even beyond. This paper presents the results of simulations of 18 different test programs under 375 different models of available parallelism analysis. This paper replaces Technical Note TN-15, an earlier version of the same material."
            },
            "slug": "Limits-of-instruction-level-parallelism-Wall",
            "title": {
                "fragments": [],
                "text": "Limits of instruction-level parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "The results of simulations of 18 different test programs under 375 different models of available parallelism analysis are presented, showing how simulations based on instruction traces can model techniques at the limits of feasibility and even beyond."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS IV"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2579638"
                        ],
                        "name": "Jenn-Yuan Tsai",
                        "slug": "Jenn-Yuan-Tsai",
                        "structuredName": {
                            "firstName": "Jenn-Yuan",
                            "lastName": "Tsai",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jenn-Yuan Tsai"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1699961"
                        ],
                        "name": "P. Yew",
                        "slug": "P.-Yew",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Yew",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Yew"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 158,
                                "start": 155
                            }
                        ],
                        "text": "Threads can also be used in a speculative manner to exploit both task-level and instruction-level parallelism, as in the Multiscalar [8] and superthreaded [9] architectures."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 15300837,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "218f8bc27e6db8e57998aab532128c4e534d56ca",
            "isKey": false,
            "numCitedBy": 172,
            "numCiting": 33,
            "paperAbstract": {
                "fragments": [],
                "text": "This peeper presents a new concurrent multiple-threaded architectural model, called superthreading, for exploiting thread-level parallelism on a processor. This architectural model adopts a thread pipelining execution model that allows threads with data dependences and control dependences to be executed in parallel. The basic idea of thread pipelining is to compute and forward recurrence data and possible dependent store addresses to the next thread as soon as possible, so the next thread can start execution and perform run-time data dependence checking. Thread pipelining also forces contiguous threads to perform their memory write-backs in order, which enables the compiler to fork threads with control speculation. With run-time support for data dependence checking and control speculation, the superthreaded architectural model can exploit loop-level parallelism from a broad range of applications."
            },
            "slug": "The-superthreaded-architecture:-thread-pipelining-Tsai-Yew",
            "title": {
                "fragments": [],
                "text": "The superthreaded architecture: thread pipelining with run-time data dependence checking and control speculation"
            },
            "tldr": {
                "abstractSimilarityScore": 93,
                "text": "This peeper presents a new concurrent multiple-threaded architectural model, called superthreading, for exploiting thread-level parallelism on a processor that adopts a thread pipelining execution model that allows threads with data dependences and control dependences to be executed in parallel."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 1996 Conference on Parallel Architectures and Compilation Technique"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1754655"
                        ],
                        "name": "G. Sohi",
                        "slug": "G.-Sohi",
                        "structuredName": {
                            "firstName": "Gurindar",
                            "lastName": "Sohi",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Sohi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2258797"
                        ],
                        "name": "S. E. Breach",
                        "slug": "S.-E.-Breach",
                        "structuredName": {
                            "firstName": "Scott",
                            "lastName": "Breach",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. E. Breach"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717864"
                        ],
                        "name": "T. N. Vijaykumar",
                        "slug": "T.-N.-Vijaykumar",
                        "structuredName": {
                            "firstName": "T.",
                            "lastName": "Vijaykumar",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. N. Vijaykumar"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 136,
                                "start": 133
                            }
                        ],
                        "text": "Threads can also be used in a speculative manner to exploit both task-level and instruction-level parallelism, as in the Multiscalar [8] and superthreaded [9] architectures."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1835985,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "839da2548f8bc9c5fc3909b5631b72de07e99cbc",
            "isKey": false,
            "numCitedBy": 542,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": "Multiscalar processors use a new, aggressive implementation paradigm for extracting large quantities of instruction level parallelism from ordinary high level language programs. A single program is divided into a collection of tasks by a combination of software and hardware. The tasks are distributed to a number of parallel processing units which reside within a processor complex. Each of these units fetches and executes instructions belonging to its assigned task. The appearance of a single logical register file is maintained with a copy in each parallel processing unit. Register results are dynamically routed among the many parallel processing units with the help of compiler-generated masks. Memory accesses may occur speculatively without knowledge of preceding loads or stores. Addresses are disambiguated dynamically, many in parallel, and processing waits only for true data dependences. This paper presents the philosophy of the multiscalar paradigm, the structure of multiscalar programs, and the hardware architecture of a multiscalar processor. The paper also discusses performance issues in the multiscalar model, and compares the multiscalar paradigm with other paradigms. Experimental results evaluating the performance of a sample of multiscalar organizations are also presented."
            },
            "slug": "Multiscalar-processors-Sohi-Breach",
            "title": {
                "fragments": [],
                "text": "Multiscalar processors"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "The philosophy of the multiscalar paradigm, the structure ofMultiscalar programs, and the hardware architecture of a multiscalars processor are presented."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings 22nd Annual International Symposium on Computer Architecture"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746638"
                        ],
                        "name": "K. Olukotun",
                        "slug": "K.-Olukotun",
                        "structuredName": {
                            "firstName": "Kunle",
                            "lastName": "Olukotun",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Olukotun"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1759625"
                        ],
                        "name": "B. A. Nayfeh",
                        "slug": "B.-A.-Nayfeh",
                        "structuredName": {
                            "firstName": "Basem",
                            "lastName": "Nayfeh",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. A. Nayfeh"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145633620"
                        ],
                        "name": "Lance Hammond",
                        "slug": "Lance-Hammond",
                        "structuredName": {
                            "firstName": "Lance",
                            "lastName": "Hammond",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lance Hammond"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2105626962"
                        ],
                        "name": "Kenneth G. Wilson",
                        "slug": "Kenneth-G.-Wilson",
                        "structuredName": {
                            "firstName": "Kenneth",
                            "lastName": "Wilson",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kenneth G. Wilson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "123790204"
                        ],
                        "name": "Kunyung Chang",
                        "slug": "Kunyung-Chang",
                        "structuredName": {
                            "firstName": "Kunyung",
                            "lastName": "Chang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kunyung Chang"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 5,
                                "start": 2
                            }
                        ],
                        "text": ", [6] investigated design tradeof fs for a single-chip multiprocessor and compared the performance and estimated area of this architecture with superscalars."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 6595171,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "62f56f5881ec45685e22dae63b22a4b19e4eda1a",
            "isKey": false,
            "numCitedBy": 861,
            "numCiting": 54,
            "paperAbstract": {
                "fragments": [],
                "text": "Advances in IC processing allow for more microprocessor design options. The increasing gate density and cost of wires in advanced integrated circuit technologies require that we look for new ways to use their capabilities effectively. This paper shows that in advanced technologies it is possible to implement a single-chip multiprocessor in the same area as a wide issue superscalar processor. We find that for applications with little parallelism the performance of the two microarchitectures is comparable. For applications with large amounts of parallelism at both the fine and coarse grained levels, the multiprocessor microarchitecture outperforms the superscalar architecture by a significant margin. Single-chip multiprocessor architectures have the advantage in that they offer localized implementation of a high-clock rate processor for inherently sequential applications and low latency interprocessor communication for parallel applications."
            },
            "slug": "The-case-for-a-single-chip-multiprocessor-Olukotun-Nayfeh",
            "title": {
                "fragments": [],
                "text": "The case for a single-chip multiprocessor"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "It is shown that in advanced technologies it is possible to implement a single-chip multiprocessor in the same area as a wide issue superscalar processor, and it is found that for applications with little parallelism the performance of the two microarchitectures is comparable."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS VII"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143896454"
                        ],
                        "name": "Mary W. Hall",
                        "slug": "Mary-W.-Hall",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Hall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mary W. Hall"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2158004198"
                        ],
                        "name": "Jennifer M. Anderson",
                        "slug": "Jennifer-M.-Anderson",
                        "structuredName": {
                            "firstName": "Jennifer",
                            "lastName": "Anderson",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jennifer M. Anderson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "119749490"
                        ],
                        "name": "Brian R. Murphy",
                        "slug": "Brian-R.-Murphy",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Murphy",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Brian R. Murphy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40063567"
                        ],
                        "name": "Shih-Wei Liao",
                        "slug": "Shih-Wei-Liao",
                        "structuredName": {
                            "firstName": "Shih-Wei",
                            "lastName": "Liao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Shih-Wei Liao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1678618"
                        ],
                        "name": "E. Bugnion",
                        "slug": "E.-Bugnion",
                        "structuredName": {
                            "firstName": "Edouard",
                            "lastName": "Bugnion",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Bugnion"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 9539062,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "024abe25f1dc77f18672f44c1c020be3e57cc3fe",
            "isKey": false,
            "numCitedBy": 638,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "This article describes automatic parallelization techniques in the SUIF (Stanford University Intermediate Format) compiler that result in good multiprocessor performance for array-based numerical programs. Parallelizing compilers for multiprocessors face many hurdles. However, SUIF's robust analysis and memory optimization techniques enabled speedups on three fourths of the NAS and SPECfp95 benchmark programs."
            },
            "slug": "Maximizing-Multiprocessor-Performance-with-the-SUIF-Hall-Anderson",
            "title": {
                "fragments": [],
                "text": "Maximizing Multiprocessor Performance with the SUIF Compiler"
            },
            "tldr": {
                "abstractSimilarityScore": 87,
                "text": "Automatic parallelization techniques in the SUIF (Stanford University Intermediate Format) compiler that result in good multiprocessor performance for array-based numerical programs."
            },
            "venue": {
                "fragments": [],
                "text": "Digit. Tech. J."
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2908362"
                        ],
                        "name": "Marco Fillo",
                        "slug": "Marco-Fillo",
                        "structuredName": {
                            "firstName": "Marco",
                            "lastName": "Fillo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Marco Fillo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715863"
                        ],
                        "name": "S. Keckler",
                        "slug": "S.-Keckler",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Keckler",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Keckler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "80724002"
                        ],
                        "name": "W. Dally",
                        "slug": "W.-Dally",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Dally",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Dally"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1803049"
                        ],
                        "name": "N. Carter",
                        "slug": "N.-Carter",
                        "structuredName": {
                            "firstName": "Nicholas",
                            "lastName": "Carter",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Carter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47658417"
                        ],
                        "name": "Andrew Chang",
                        "slug": "Andrew-Chang",
                        "structuredName": {
                            "firstName": "Andrew",
                            "lastName": "Chang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Andrew Chang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "21732846"
                        ],
                        "name": "Yevgeny Gurevich",
                        "slug": "Yevgeny-Gurevich",
                        "structuredName": {
                            "firstName": "Yevgeny",
                            "lastName": "Gurevich",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yevgeny Gurevich"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2158228302"
                        ],
                        "name": "W. S. Lee",
                        "slug": "W.-S.-Lee",
                        "structuredName": {
                            "firstName": "Whay",
                            "lastName": "Lee",
                            "middleNames": [
                                "Sing"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. S. Lee"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 14
                            }
                        ],
                        "text": "The M-Machine [3] utilizes multithreading in a dif ferent manner , relying on two levels of parallelism, called H-threads and V -threads."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 757366,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3b6ac6ef9b6ccb1f7b51de9e52dfc6047d699dad",
            "isKey": false,
            "numCitedBy": 132,
            "numCiting": 135,
            "paperAbstract": {
                "fragments": [],
                "text": "The M-Machine is an experimental multicomputer being developed to test architectural concepts motivated by the constraints of modern semiconductor technology and the demands of programming systems. The M-Machine computing nodes are connected with a 3-D mesh network; each node is a multithreaded processor incorporating 9 function units, on-chip cache, and local memory. The multiple function units are used to exploit both instruction-level and thread-level parallelism. A user accessible message passing system yields fast communication and synchronization between nodes. Rapid access to remote memory is provided transparently to the user with a combination of hardware and software mechanisms. This paper presents the architecture of the M-Machine and describes how its mechanisms attempt to maximize both single thread performance and overall system throughput. The architecture is complete and the MAP chip, which will serve as the M-Machine processing node, is currently being implemented."
            },
            "slug": "The-M-machine-multicomputer-Fillo-Keckler",
            "title": {
                "fragments": [],
                "text": "The M-machine multicomputer"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "The architecture of the M-Machine is presented and how its mechanisms attempt to maximize both single thread performance and overall system throughput are described."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 28th Annual International Symposium on Microarchitecture"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40334310"
                        ],
                        "name": "Kenneth M. Wilson",
                        "slug": "Kenneth-M.-Wilson",
                        "structuredName": {
                            "firstName": "Kenneth",
                            "lastName": "Wilson",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kenneth M. Wilson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746638"
                        ],
                        "name": "K. Olukotun",
                        "slug": "K.-Olukotun",
                        "structuredName": {
                            "firstName": "Kunle",
                            "lastName": "Olukotun",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Olukotun"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8373823"
                        ],
                        "name": "M. Rosenblum",
                        "slug": "M.-Rosenblum",
                        "structuredName": {
                            "firstName": "Mendel",
                            "lastName": "Rosenblum",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Rosenblum"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 128,
                                "start": 124
                            }
                        ],
                        "text": "suggest placing recently accessed data in a small associative buf f r, which is accessed when the main cache ports are busy [12]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6009747,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0b05aaa2b9ca62c3c4143918547c5b32b9509d4f",
            "isKey": false,
            "numCitedBy": 66,
            "numCiting": 71,
            "paperAbstract": {
                "fragments": [],
                "text": "The memory bandwidth demands of modern microprocessors require the use of a multi-ported cache to achieve peak performance. However, multi-ported caches are costly to implement. In this paper we propose techniques for improving the bandwidth of a single cache port by using additional buffering in the processor, and by taking maximum advantage of a wider cache port. We evaluate these techniques using realistic applications that include the operating system. Our techniques using a single-ported cache achieve 91% of the performance of a dual-ported cache."
            },
            "slug": "Increasing-Cache-Port-Efficiency-for-Dynamic-Wilson-Olukotun",
            "title": {
                "fragments": [],
                "text": "Increasing Cache Port Efficiency for Dynamic Superscalar Microprocessors"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The authors' techniques for improving the bandwidth of a single cache port by using additional buffering in the processor, and by taking maximum advantage of a wider cache port achieve 91% of the performance of a dual-ported cache."
            },
            "venue": {
                "fragments": [],
                "text": "23rd Annual International Symposium on Computer Architecture (ISCA'96)"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40458921"
                        ],
                        "name": "K. Farkas",
                        "slug": "K.-Farkas",
                        "structuredName": {
                            "firstName": "Keith",
                            "lastName": "Farkas",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Farkas"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144037335"
                        ],
                        "name": "P. Chow",
                        "slug": "P.-Chow",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Chow",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Chow"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715454"
                        ],
                        "name": "N. Jouppi",
                        "slug": "N.-Jouppi",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Jouppi",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Jouppi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1745667"
                        ],
                        "name": "Z. Vranesic",
                        "slug": "Z.-Vranesic",
                        "structuredName": {
                            "firstName": "Zvonko",
                            "lastName": "Vranesic",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Z. Vranesic"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2590011,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a64e755eec37d6bf8990c95cd184f5a256e793ad",
            "isKey": false,
            "numCitedBy": 281,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "The multicluster architecture that we introduce offers a decentralized, dynamically scheduled architecture, in which the register files, dispatch queue, and functional units of the architecture are distributed across multiple clusters, and each cluster is assigned a subset of the architectural registers. The motivation for the multicluster architecture is to reduce the clock cycle time, relative to a single-cluster architecture with the same number of hardware resources, by reducing the size and complexity of components on critical timing paths. Resource partitioning, however, introduces instruction-execution overhead and may reduce the number of concurrently executing instructions. To counter these two negative by-products of partitioning, we developed a static instruction scheduling algorithm. We describe this algorithm, and using trace-driven simulations of SPEC92 benchmarks, evaluate its effectiveness. This evaluation indicates that for the configurations considered the multicluster architecture may have significant performance advantages at feature sizes below 0.35 /spl mu/m, and warrants further investigation."
            },
            "slug": "The-multicluster-architecture:-reducing-cycle-time-Farkas-Chow",
            "title": {
                "fragments": [],
                "text": "The multicluster architecture: reducing cycle time through partitioning"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A static instruction scheduling algorithm is developed that for the configurations considered the multicluster architecture may have significant performance advantages at feature sizes below 0.35 /spl mu/m, and warrants further investigation."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of 30th Annual International Symposium on Microarchitecture"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69923030"
                        ],
                        "name": "K. Gharachodoo",
                        "slug": "K.-Gharachodoo",
                        "structuredName": {
                            "firstName": "K.",
                            "lastName": "Gharachodoo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Gharachodoo"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 60542021,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "57405299173ec8210f0f13613c24dee7db0661de",
            "isKey": false,
            "numCitedBy": 146,
            "numCiting": 131,
            "paperAbstract": {
                "fragments": [],
                "text": "The memory consistency model for a shared-memory multiprocessor specifies the behavior of memory with respect to read and write operations from multiple processors. As such, the memory model influences many aspects of system design, including the design of programming languages, compilers, and the underlying hardware. Relaxed models that impose fewer memory ordering constraints offer the potential for higher performance by allowing hardware and software to overlap and reorder memory operations. However, fewer ordering guarantees can compromise programmability and portability. Many of the previously proposed models either fail to provide reasonable programming semantics or are biased toward programming ease at the cost of sacrificing performance. Furthermore, the lack of consensus on an acceptable model hinders software portability across different systems. This dissertation focuses on providing a balanced solution that directly addresses the trade-off between programming ease and performance. To address programmability, we propose an alternative method for specifying memory behavior that presents a higher level abstraction to the programmer. We show that with only a few types of information supplied by the programmer, an implementation can exploit the full range of optimizations enabled by previous models. Furthermore, the same information enables automatic and efficient portability across a wide range of implementations. To expose the optimizations enabled by a model, we have developed a formal framework for specifying the low-level ordering constraints that must be enforced by an implementation. Based on these specifications, we present a wide range of architecture and compiler implementation techniques for efficiently supporting a given model. Finally, we evaluate the performance benefits of exploiting relaxed models based on detailed simulations of realistic parallel applications. Our results show that the optimizations enabled by relaxed models are extremely effective in hiding virtually the full latency of writes in architectures with blocking reads (i.e., processor stalls on reads), with gains as high as 80%. Architectures with nonblocking reads can further exploit relaxed models to hide a substantial fraction of the read latency as well, leading to a larger overall performance benefit. Furthermore, these optimizations complement gains from other latency hiding techniques such as prefetching and multiple contexts. We believe that the combined benefits in hardware and software will make relaxed models universal in future multiprocessors, as is already evidenced by their adoption in several commercial systems."
            },
            "slug": "Memory-consistency-models-for-shared-memory-Gharachodoo",
            "title": {
                "fragments": [],
                "text": "Memory consistency models for shared memory multiprocessors"
            },
            "tldr": {
                "abstractSimilarityScore": 37,
                "text": "The results show that the optimizations enabled by relaxed models are extremely effective in hiding virtually the full latency of writes in architectures with blocking reads, with gains as high as 80%."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 59736987,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f0692dd6e23eb7cceb09ffcf5757ab645381819e",
            "isKey": false,
            "numCitedBy": 24,
            "numCiting": 113,
            "paperAbstract": {
                "fragments": [],
                "text": "The Western Research Laboratory (WRL) is a computer systems research group that was founded by Digital Equipment Corporation in 1982. Our focus is computer science research relevant to the design and application of high performance scientific computers. We test our ideas by designing, building, and using real systems. The systems we build are research prototypes; they are not intended to become products. Our research is directed towards mainstream high-performance computer systems. Our prototypes are intended to foreshadow the future computing environments used by many Digital customers. The long-term goal of WRL is to aid and accelerate the development of high-performance uni-and multi-processors. The research projects within WRL will address various aspects of high-performance computing. We believe that significant advances in computer systems do not come from any single technological advance. Technologies, both hardware and software, do not all advance at the same pace. System design is the art of composing systems which use each level of technology in an appropriate balance. A major advance in overall system performance will require reexamination of all aspects of the system. We do work in the design, fabrication and packaging of hardware; language processing and scaling issues in system software design; and the exploration of new applications areas that are opening up with the advent of higher performance systems. Researchers at WRL cooperate closely and move freely among the various levels of system design. This allows us to explore a wide range of tradeoffs to meet system goals. We publish the results of our work in a variety of journals, conferences, research reports, and technical notes. This document is a technical note. We use this form for rapid distribution of technical material. Usually this represents research in progress. Research reports are normally accounts of completed research and may include material from earlier technical notes. Research reports and technical notes may be ordered from us. You may mail your order to: UUCP: decwrl!wrl-techreports To obtain more details on ordering by electronic mail, send a message to one of these addresses with the word ''help'' in the Subject line; you will receive detailed instructions. Abstract Full exploitation of instruction-level parallelism by superscalar and similar architectures requires speculative execution, in which we are willing to issue a potential future instruction early even though an intervening branch may send us in another direction entirely. Speculative execution can be based either on branch prediction, where we explore the most \u2026"
            },
            "slug": "Speculative-Execution-and-Instruction-Level-Wall",
            "title": {
                "fragments": [],
                "text": "Speculative Execution and Instruction-Level Parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "The Western Research Laboratory (WRL) is a computer systems research group that was founded by Digital Equipment Corporation in 1982 and aims to aid and accelerate the development of high-performance uni-and multi-processors."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1695693"
                        ],
                        "name": "K. Gharachorloo",
                        "slug": "K.-Gharachorloo",
                        "structuredName": {
                            "firstName": "Kourosh",
                            "lastName": "Gharachorloo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Gharachorloo"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 85437822,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1dcf2bf27c87cec1cb0fa8ff9311a5738b8b513e",
            "isKey": false,
            "numCitedBy": 73,
            "numCiting": 104,
            "paperAbstract": {
                "fragments": [],
                "text": "The memory consistency model for a shared-memory multiprocessor specifies the behavior of memory with respect to read and write operations from multiple processors. As such, the memory model influences many aspects of system design, including the design of programming languages, compilers, and the underlying hardware. Relaxed models that impose fewer memory ordering constraints offer the potential for higher performance by allowing hardware and software to overlap and reorder memory operations. However, fewer ordering guarantees can compromise programmability and portability. Many of the previously proposed models either fail to provide reasonable programming semantics or are biased toward programming ease at the cost of sacrificing performance. Furthermore, the lack of consensus on an acceptable model hinders software portability across different systems. \nThis dissertation focuses on providing a balanced solution that directly addresses the trade-off between programming ease and performance. To address programmability, we propose an alternative method for specifying memory behavior that presents a higher level abstraction to the programmer. We show that with only a few types of information supplied by the programmer, an implementation can exploit the full range of optimizations enabled by previous models. Furthermore, the same information enables automatic and efficient portability across a wide range of implementations. \nTo expose the optimizations enabled by a model, we have developed a formal framework for specifying the low-level ordering constraints that must be enforced by an implementation. Based on these specifications, we present a wide range of architecture and compiler implementation techniques for efficiently supporting a given model. Finally, we evaluate the performance benefits of exploiting relaxed models based on detailed simulations of realistic parallel applications. Our results show that the optimizations enabled by relaxed models are extremely effective in hiding virtually the full latency of writes in architectures with blocking reads (i.e., processor stalls on reads), with gains as high as 80%. Architectures with non-blocking reads can further exploit relaxed models to hide a substantial fraction of the read latency as well, leading to a larger overall performance benefit. Furthermore, these optimizations complement gains from other latency hiding techniques such as prefetching and multiple contexts. \nWe believe that the combined benefits in hardware and software will make relaxed models universal in future multiprocessors, as is already evidenced by their adoption in several commercial systems."
            },
            "slug": "Memory-consistency-models-for-shared-memory-Gharachorloo",
            "title": {
                "fragments": [],
                "text": "Memory consistency models for shared-memory multiprocessors"
            },
            "tldr": {
                "abstractSimilarityScore": 37,
                "text": "The results show that the optimizations enabled by relaxed models are extremely effective in hiding virtually the full latency of writes in architectures with blocking reads, with gains as high as 80%."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40458921"
                        ],
                        "name": "K. Farkas",
                        "slug": "K.-Farkas",
                        "structuredName": {
                            "firstName": "Keith",
                            "lastName": "Farkas",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Farkas"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715454"
                        ],
                        "name": "N. Jouppi",
                        "slug": "N.-Jouppi",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Jouppi",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Jouppi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144037335"
                        ],
                        "name": "P. Chow",
                        "slug": "P.-Chow",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Chow",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Chow"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14344496,
            "fieldsOfStudy": [
                "Business",
                "Computer Science"
            ],
            "id": "192819a5aa7acafbfb8f7a710e07220fd537be2f",
            "isKey": false,
            "numCitedBy": 136,
            "numCiting": 94,
            "paperAbstract": {
                "fragments": [],
                "text": "We have investigated the register file requirements of dynamically scheduled processors using register renaming and dispatch queues running the SPEC92 benchmarks. We looked at processors capable of issuing either four or eight instructions per cycle and found that in most cases implementing precise exceptions requires a relatively small number of additional registers compared to imprecise exceptions. Systems with aggressive non-blacking load support were able to achieve performance similar to processors with perfect memory systems at the cost of some additional registers. Given our machine assumptions, we found that the performance of a four-issue machine with a 32-entry dispatch queue tends to saturate around 80 registers. For an eight-issue machine with a 64-entry dispatch queue performance does not saturate until about 128 registers. Assuming the machine cycle time is proportional to the register file cycle time, the 8-issue machine yields only 20% higher performance than the 4-issue machine due in part to the cycle time impact of additional hardware."
            },
            "slug": "Register-file-design-considerations-in-dynamically-Farkas-Jouppi",
            "title": {
                "fragments": [],
                "text": "Register file design considerations in dynamically scheduled processors"
            },
            "tldr": {
                "abstractSimilarityScore": 73,
                "text": "This work has investigated the register file requirements of dynamically scheduled processors using register renaming and dispatch queues running the SPEC92 benchmarks and found that in most cases implementing precise exceptions requires a relatively small number of additional registers compared to imprecise exceptions."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. Second International Symposium on High-Performance Computer Architecture"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1921334"
                        ],
                        "name": "Robert Alverson",
                        "slug": "Robert-Alverson",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Alverson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Robert Alverson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "153281265"
                        ],
                        "name": "D. Callahan",
                        "slug": "D.-Callahan",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Callahan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Callahan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36481290"
                        ],
                        "name": "D. Cummings",
                        "slug": "D.-Cummings",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Cummings",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Cummings"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3126100"
                        ],
                        "name": "Brian D. Koblenz",
                        "slug": "Brian-D.-Koblenz",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Koblenz",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Brian D. Koblenz"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145516797"
                        ],
                        "name": "Allan Porterfield",
                        "slug": "Allan-Porterfield",
                        "structuredName": {
                            "firstName": "Allan",
                            "lastName": "Porterfield",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Allan Porterfield"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1731660"
                        ],
                        "name": "Burton J. Smith",
                        "slug": "Burton-J.-Smith",
                        "structuredName": {
                            "firstName": "Burton",
                            "lastName": "Smith",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Burton J. Smith"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 52
                            }
                        ],
                        "text": "Multithreaded architectures, for example, the T era [2], contain hardware state -- a program counter and registers -- for several threads."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 77,
                                "start": 74
                            }
                        ],
                        "text": "Multithreaded architectures have also been widely investigated; the T era [2] is a fine-grain multithreaded processor , which issues up to three operations each cycle."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1857820,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "108b3a24274af0aab079bd94ab7c1ee6543563d4",
            "isKey": false,
            "numCitedBy": 423,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "The Tera architecture was designed with several ma jor goals in mind. First, it needed to be suitable for very high speed implementations, i. e., admit a short clock period and be scalable to many processors. This goal will be achieved; a maximum configuration of the first implementation of the architecture will have 256 processors, 512 memory units, 256 I/O cache units, 256 I/O processors, and 4096 interconnection network nodes and a clock period less than 3 nanoseconds. The abstract architecture is scalable essentially without limit (although a particular implementation is not, of course). The only requirement is that the number of instruction streams increase more rapidly than the number of physical processors. Although this means that speedup is sublinear in the number of instruction streams, it can still increase linearly with the number of physical pro cessors. The price/performance ratio of the system is unmatched, and puts Tera\u2019s high performance within economic reach. Second, it was important that the architecture be applicable to a wide spectrum of problems. Programs that do not vectoriae well, perhaps because of a preponderance of scalar operations or too-frequent conditional branches, will execute efficiently as long as there is sufficient parallelism to keep the processors busy. Virtually any parallelism available in the total computational workload can be turned into speed, from operation level parallelism within program basic blocks to multiuser timeand space-sharing. The architecture"
            },
            "slug": "The-Tera-computer-system-Alverson-Callahan",
            "title": {
                "fragments": [],
                "text": "The Tera computer system"
            },
            "tldr": {
                "abstractSimilarityScore": 90,
                "text": "The Tera architecture was designed with several goals in mind; it needed to be suitable for very high speed implementations, i."
            },
            "venue": {
                "fragments": [],
                "text": "ICS"
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3196444"
                        ],
                        "name": "S. Adve",
                        "slug": "S.-Adve",
                        "structuredName": {
                            "firstName": "Sarita",
                            "lastName": "Adve",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Adve"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1695693"
                        ],
                        "name": "K. Gharachorloo",
                        "slug": "K.-Gharachorloo",
                        "structuredName": {
                            "firstName": "Kourosh",
                            "lastName": "Gharachorloo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Gharachorloo"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 221106145,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e0bc77d18ab2e097395ce77b8c050f53f420542d",
            "isKey": false,
            "numCitedBy": 1192,
            "numCiting": 119,
            "paperAbstract": {
                "fragments": [],
                "text": "The memory consistency model of a system affects performance, programmability, and portability. We aim to describe memory consistency models in a way that most computer professionals would understand. This is important if the performance-enhancing features being incorporated by system designers are to be correctly and widely used by programmers. Our focus is consistency models proposed for hardware-based shared memory systems. Most of these models emphasize the system optimizations they support, and we retain this system-centric emphasis. We also describe an alternative, programmer-centric view of relaxed consistency models that describes them in terms of program behavior, not system optimizations."
            },
            "slug": "Shared-Memory-Consistency-Models:-A-Tutorial-Adve-Gharachorloo",
            "title": {
                "fragments": [],
                "text": "Shared Memory Consistency Models: A Tutorial"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This work describes an alternative, programmer-centric view of relaxed consistency models that describes them in terms of program behavior, not system optimizations, and most of these models emphasize the system optimizations they support."
            },
            "venue": {
                "fragments": [],
                "text": "Computer"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1754655"
                        ],
                        "name": "G. Sohi",
                        "slug": "G.-Sohi",
                        "structuredName": {
                            "firstName": "Gurindar",
                            "lastName": "Sohi",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Sohi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47716476"
                        ],
                        "name": "M. Franklin",
                        "slug": "M.-Franklin",
                        "structuredName": {
                            "firstName": "Manoj",
                            "lastName": "Franklin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Franklin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 108,
                                "start": 105
                            }
                        ],
                        "text": "For caches, the age-old technique of interleaving, augmented with multiple independently-addressed banks [7], can increase the number of simultaneous accesses without also increasing the number of cache ports."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 17343682,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a8fff0734b157fce19f3357d0a78eb31de5f3e02",
            "isKey": false,
            "numCitedBy": 214,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper considers the design of a data memory hierarchy, with a level 1 (L1) data cache at the top, to support the data bandwidth demands of a future-generation superscalar processor capable of issuing about ten instructions per clock cycle. It introduces the notion of cache bandwidfh \u2014 the bandwidth with which a cache can accept requests from the processor \u2014 and shows how the bandwidth of a standard, blocking cache, can degrade greatly because of its inability to overlap the service of misses. Non-blocking or lockup-free caches are discussed as a way of reducing the bandwidth degradation due to misses. To improve the data bandwidth to greater than 1 request per cycle, multi-port, interleaved caches are introduced. Simulation results from a cycle-by-cycle simulator, using the MIPS R2000 instruction set, suggest that memory hierarchies with blocking L 1 caches will be unable to support the bandwidth demands of futuregeneration superscalar processors. Multi-port, nonblocking (MPNB) L1 caches introduced in this paper for the top of the data memory hierarchy appear to be capable of supporting such data bandwidth demands."
            },
            "slug": "High-bandwidth-data-memory-systems-for-superscalar-Sohi-Franklin",
            "title": {
                "fragments": [],
                "text": "High-bandwidth data memory systems for superscalar processors"
            },
            "tldr": {
                "abstractSimilarityScore": 63,
                "text": "Multi-port, nonblocking (MPNB) L1 caches introduced in this paper for the top of the data memory hierarchy appear to be capable of supporting the bandwidth demands of futuregeneration superscalar processors."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS IV"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2934890"
                        ],
                        "name": "D. Scales",
                        "slug": "D.-Scales",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Scales",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Scales"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1695693"
                        ],
                        "name": "K. Gharachorloo",
                        "slug": "K.-Gharachorloo",
                        "structuredName": {
                            "firstName": "Kourosh",
                            "lastName": "Gharachorloo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Gharachorloo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144539358"
                        ],
                        "name": "A. Aggarwal",
                        "slug": "A.-Aggarwal",
                        "structuredName": {
                            "firstName": "Anshul",
                            "lastName": "Aggarwal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Aggarwal"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16123404,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "10d03c1519dd1642bc27ad109ec341d96bde859d",
            "isKey": false,
            "numCitedBy": 79,
            "numCiting": 97,
            "paperAbstract": {
                "fragments": [],
                "text": "Commercial SMP nodes are an attractive building block for software distributed shared memory systems. The advantages of using SMP nodes include fast communication among processors within the same node and potential gains from clustering where remote data fetched by one processor is used by other processors on the same node. This paper describes a major extension to the Shasta distributed shared memory system to run efficiently on a cluster of SMP nodes. The Shasta system keeps shared data coherent across nodes at a fine granularity by inserting inline code that checks the cache state of shared data before each load or store in an application. However allowing processors to share memory within the same SMP is complicated by race conditions that arise because the inline state check is non-atomic with respect to the actual load or store of shared data. We present a novel protocol that avoids such race conditions without the use of costly synchronization in the inline checking code. To characterize the benefits of using SMP nodes in the context of Shasta, we present detailed performance results for nine SPLASH-2 applications running on a cluster of Alpha multiprocessors."
            },
            "slug": "Fine-grain-software-distributed-shared-memory-on-Scales-Gharachorloo",
            "title": {
                "fragments": [],
                "text": "Fine-grain software distributed shared memory on SMP clusters"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A novel protocol is presented that avoids race conditions that arise because the inline state check is non-atomic with respect to the actual load or store of shared data in the Shasta distributed shared memory system."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings 1998 Fourth International Symposium on High-Performance Computer Architecture"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109033280"
                        ],
                        "name": "Robert P. Wilson",
                        "slug": "Robert-P.-Wilson",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Wilson",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Robert P. Wilson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "152803377"
                        ],
                        "name": "R. French",
                        "slug": "R.-French",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "French",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. French"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47003853"
                        ],
                        "name": "Christopher S. Wilson",
                        "slug": "Christopher-S.-Wilson",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "Wilson",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christopher S. Wilson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2158004198"
                        ],
                        "name": "Jennifer M. Anderson",
                        "slug": "Jennifer-M.-Anderson",
                        "structuredName": {
                            "firstName": "Jennifer",
                            "lastName": "Anderson",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jennifer M. Anderson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3051001"
                        ],
                        "name": "S. Tjiang",
                        "slug": "S.-Tjiang",
                        "structuredName": {
                            "firstName": "Steven",
                            "lastName": "Tjiang",
                            "middleNames": [
                                "W.",
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Tjiang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40063567"
                        ],
                        "name": "Shih-Wei Liao",
                        "slug": "Shih-Wei-Liao",
                        "structuredName": {
                            "firstName": "Shih-Wei",
                            "lastName": "Liao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Shih-Wei Liao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35146927"
                        ],
                        "name": "C. Tseng",
                        "slug": "C.-Tseng",
                        "structuredName": {
                            "firstName": "Chau-Wen",
                            "lastName": "Tseng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Tseng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143896454"
                        ],
                        "name": "Mary W. Hall",
                        "slug": "Mary-W.-Hall",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Hall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mary W. Hall"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772133"
                        ],
                        "name": "J. Hennessy",
                        "slug": "J.-Hennessy",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Hennessy",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Hennessy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "The SPEC programs were parallelized with the SUIF compiler [13], using parallelization policies that were developed for shared memory machines."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 2219157,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2d9df5f8030bdd1e124374854ade5aec6c051a84",
            "isKey": false,
            "numCitedBy": 624,
            "numCiting": 16,
            "paperAbstract": {
                "fragments": [],
                "text": "Compiler infrastructures that support experimental research are crucial to the advancement of high-performance computing. New compiler technology must be implemented and evaluated in the context of a complete compiler, but developing such an infrastructure requires a huge investment in time and resources. We have spent a number of years building the SUIF compiler into a powerful, flexible system, and we would now like to share the results of our efforts.SUIF consists of a small, clearly documented kernel and a toolkit of compiler passes built on top of the kernel. The kernel defines the intermediate representation, provides functions to access and manipulate the intermediate representation, and structures the interface between compiler passes. The toolkit currently includes C and Fortran front ends, a loop-level parallelism and locality optimizer, an optimizing MIPS back end, a set of compiler development tools, and support for instructional use.Although we do not expect SUIF to be suitable for everyone, we think it may be useful for many other researchers. We thus invite you to use SUIF and welcome your contributions to this infrastructure. Directions for obtaining the SUIF software are included at the end of this paper."
            },
            "slug": "SUIF:-an-infrastructure-for-research-on-and-Wilson-French",
            "title": {
                "fragments": [],
                "text": "SUIF: an infrastructure for research on parallelizing and optimizing compilers"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The SUIF compiler is built into a powerful, flexible system that may be useful for many other researchers and the authors invite you to use and welcome your contributions to this infrastructure."
            },
            "venue": {
                "fragments": [],
                "text": "SIGP"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2934890"
                        ],
                        "name": "D. Scales",
                        "slug": "D.-Scales",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Scales",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Scales"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1695693"
                        ],
                        "name": "K. Gharachorloo",
                        "slug": "K.-Gharachorloo",
                        "structuredName": {
                            "firstName": "Kourosh",
                            "lastName": "Gharachorloo",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Gharachorloo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1780447"
                        ],
                        "name": "C. Thekkath",
                        "slug": "C.-Thekkath",
                        "structuredName": {
                            "firstName": "Chandramohan",
                            "lastName": "Thekkath",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Thekkath"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2224483,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a6cabdb795939a8834ac2991004339fe56673608",
            "isKey": false,
            "numCitedBy": 362,
            "numCiting": 87,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes Shasta, a system that supports a shared address space in software on clusters of computers with physically distributed memory. A unique aspect of Shasta compared to most other software distributed shared memory systems is that shared data can be kept coherent at a fine granularity. In addition, the system allows the coherence granularity to vary across different shared data structures in a single application. Shasta implements the shared address space by transparently rewriting the application executable to intercept loads and stores. For each shared load or store, the inserted code checks to see if the data is available locally and communicates with other processors if necessary. The system uses numerous techniques to reduce the run-time overhead of these checks. Since Shasta is implemented entirely in software, it also provides tremendous flexibility in supporting different types of cache coherence protocols. We have implemented an efficient cache coherence protocol that incorporates a number of optimizations, including support for multiple communication granularities and use of relaxed memory models. This system is fully functional and runs on a cluster of Alpha workstations.The primary focus of this paper is to describe the techniques used in Shasta to reduce the checking overhead for supporting fine granularity sharing in software. These techniques include careful layout of the shared address space, scheduling the checking code for efficient execution on modern processors, using a simple method that checks loads using only the value loaded, reducing the extra cache misses caused by the checking code, and combining the checks for multiple loads and stores. To characterize the effect of these techniques, we present detailed performance results for the SPLASH-2 applications running on an Alpha processor. Without our optimizations, the checking overheads are excessively high, exceeding 100% for several applications. However, our techniques are effective in reducing these overheads to a range of 5% to 35% for almost all of the applications. We also describe our coherence protocol and present some preliminary results on the parallel performance of several applications running on our workstation cluster. Our experience so far indicates that once the cost of checking memory accesses is reduced using our techniques, the Shasta approach is an attractive software solution for supporting a shared address space with fine-grain access to data."
            },
            "slug": "Shasta:-a-low-overhead,-software-only-approach-for-Scales-Gharachorloo",
            "title": {
                "fragments": [],
                "text": "Shasta: a low overhead, software-only approach for supporting fine-grain shared memory"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "The primary focus of this paper is to describe the techniques used in Shasta to reduce the checking overhead for supporting fine granularity sharing in software, including careful layout of the shared address space and scheduling the checking code for efficient execution on modern processors."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS VII"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1843326"
                        ],
                        "name": "S. Palacharla",
                        "slug": "S.-Palacharla",
                        "structuredName": {
                            "firstName": "Subbarao",
                            "lastName": "Palacharla",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Palacharla"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715454"
                        ],
                        "name": "N. Jouppi",
                        "slug": "N.-Jouppi",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Jouppi",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Jouppi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144961917"
                        ],
                        "name": "James E. Smith",
                        "slug": "James-E.-Smith",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Smith",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "James E. Smith"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 582958,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0afece5039c2522cc7ff60b89407381be3b6f3a0",
            "isKey": false,
            "numCitedBy": 915,
            "numCiting": 135,
            "paperAbstract": {
                "fragments": [],
                "text": "The performance tradeoff between hardware complexity and clock speed is studied. First, a generic superscalar pipeline is defined. Then the specific areas of register renaming, instruction window wakeup and selection logic, and operand bypassing are analyzed. Each is modeled and Spice simulated for feature sizes of 0.8&micro;m, 0.35&micro;m, and 0.18&micro;m. Performance results and trends are expressed in terms of issue width and window size. Our analysis indicates that window wakeup and selection logic as well as operand bypass logic are likely to be the most critical in the future.A microarchitecture that simplifies wakeup and selection logic is proposed and discussed. This implementation puts chains of dependent instructions into queues, and issues instructions from multiple queues in parallel. Simulation shows little slowdown as compared with a completely flexible issue window when performance is measured in clock cycles. Furthermore, because only instructions at queue heads need to be awakened and selected, issue logic is simplified and the clock cycle is faster --- consequently overall performance is improved. By grouping dependent instructions together, the proposed microarchitecture will help minimize performance degradation due to slow bypasses in future wide-issue machines."
            },
            "slug": "Complexity-Effective-Superscalar-Processors-Palacharla-Jouppi",
            "title": {
                "fragments": [],
                "text": "Complexity-Effective Superscalar Processors"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "A microarchitecture that simplifies wakeup and selection logic is proposed and discussed, which will help minimize performance degradation due to slow bypasses in future wide-issue machines."
            },
            "venue": {
                "fragments": [],
                "text": "Conference Proceedings. The 24th Annual International Symposium on Computer Architecture"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144906845"
                        ],
                        "name": "J. Ousterhout",
                        "slug": "J.-Ousterhout",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Ousterhout",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ousterhout"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1561851,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5c22ae5e24bad5b9fc0da45c8e0885a51dc014d7",
            "isKey": false,
            "numCitedBy": 488,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "This note evaluates several hardware platforms and operating systems using a set of benchmarks that test memory bandwidth and various operating system features such as kernel entry/exit and file systems. The overall conclusion is that operating system performance does not seem to be improving at the same rate as the base speed of the underlying hardware. Copyright \uf6d9 1989 Digital Equipment Corporation d i g i t a l Western Research Laboratory 100 Hamilton Avenue Palo Alto, California 94301 USA"
            },
            "slug": "Why-Aren't-Operating-Systems-Getting-Faster-As-Fast-Ousterhout",
            "title": {
                "fragments": [],
                "text": "Why Aren't Operating Systems Getting Faster As Fast as Hardware?"
            },
            "tldr": {
                "abstractSimilarityScore": 95,
                "text": "This note evaluates several hardware platforms and operating systems using a set of benchmarks that test memory bandwidth and various operating system features such as kernel entry/exit and file systems to conclude that operating system performance does not seem to be improving at the same rate as the base speed of the underlying hardware."
            },
            "venue": {
                "fragments": [],
                "text": "USENIX Summer"
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698456"
                        ],
                        "name": "B. Calder",
                        "slug": "B.-Calder",
                        "structuredName": {
                            "firstName": "Brad",
                            "lastName": "Calder",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Calder"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145647573"
                        ],
                        "name": "D. Grunwald",
                        "slug": "D.-Grunwald",
                        "structuredName": {
                            "firstName": "Dirk",
                            "lastName": "Grunwald",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Grunwald"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2257959"
                        ],
                        "name": "Amitabh Srivastava",
                        "slug": "Amitabh-Srivastava",
                        "structuredName": {
                            "firstName": "Amitabh",
                            "lastName": "Srivastava",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amitabh Srivastava"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 61578095,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e28f457c74c34611b81ab7068032fca6f480d29a",
            "isKey": false,
            "numCitedBy": 47,
            "numCiting": 63,
            "paperAbstract": {
                "fragments": [],
                "text": "Profile-based optimizations are being used with increasing frequency. Profile information can be used to improve instruction scheduling, code layout, and to increase instruction level parallelism. These optimizations have been shown to be effective when they are applied to the same program from which the profile was gathered. However it is an open question how profile-based optimizations should be applied to library subroutines. If many programs use libraries in the same way, it may be possible to \"preoptimize\" a library or to use an optimized shared library. This study examines the use of commonly used libraries among 43 C and FORTRAN programs to see if the libraries have common behavior across different programs. We examine the behavior of the most commonly used Unix libraries on Digital Unix. We found that libraries have very predictable behavior between applications. This implies that profile-based compiler optimizations may be effective far libraries across different applications. Therefore, one can use profile optimizations on shared and non-shared libraries before they are shipped, allowing a program using those libraries to take advantage of profile-based optimizations without having to gather any profiles. All results in this study are shown using branch misprediction rates. We feel this metric indicates the likelihood that programs have similar behavior and allows comparison to earlier branch prediction studies."
            },
            "slug": "Performance-issues-in-correlated-branch-prediction-Calder-Grunwald",
            "title": {
                "fragments": [],
                "text": "Performance issues in correlated branch prediction schemes"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This study examines the use of commonly used libraries among 43 C and FORTRAN programs to see if the libraries have common behavior across different programs and found that libraries have very predictable behavior between applications."
            },
            "venue": {
                "fragments": [],
                "text": "MICRO 1995"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715454"
                        ],
                        "name": "N. Jouppi",
                        "slug": "N.-Jouppi",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Jouppi",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Jouppi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1702209"
                        ],
                        "name": "S. Wilton",
                        "slug": "S.-Wilton",
                        "structuredName": {
                            "firstName": "Steven",
                            "lastName": "Wilton",
                            "middleNames": [
                                "J.",
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Wilton"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 11653648,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e12c87edebaff8ee57af3186cfd603c0d2653c59",
            "isKey": false,
            "numCitedBy": 175,
            "numCiting": 74,
            "paperAbstract": {
                "fragments": [],
                "text": "The performance of two-level on-chip caching is investigated for a range of technology and architecture assumptions. The area and access time of each level of cache is modeled in detail. The results indicate that for most workloads, two-level cache configurations (with a set-associative second level) perform marginally better than single-level cache configurations that require the same chip area once the first-level cache sizes are 64 KB or larger. Two-level configurations become even more important in systems with no off-chip cache and in systems in which the memory cells in the first-level caches are multiported and hence larger than those in the second-level cache. Finally, a new replacement policy called two-level exclusive caching is introduced. Two-level exclusive caching improves the performance of two-level caching organizations by increasing the effective associativity and capacity.<<ETX>>"
            },
            "slug": "Tradeoffs-in-two-level-on-chip-caching-Jouppi-Wilton",
            "title": {
                "fragments": [],
                "text": "Tradeoffs in two-level on-chip caching"
            },
            "tldr": {
                "abstractSimilarityScore": 49,
                "text": "Two-level exclusive caching improves the performance of two-level caching organizations by increasing the effective associativity and capacity."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of 21 International Symposium on Computer Architecture"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2411667"
                        ],
                        "name": "S. McFarling",
                        "slug": "S.-McFarling",
                        "structuredName": {
                            "firstName": "Scott",
                            "lastName": "McFarling",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. McFarling"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 12788916,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6de10426a24dc37e7a26c679cf025bb99f79e352",
            "isKey": false,
            "numCitedBy": 152,
            "numCiting": 77,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes a method of determining which procedures to merge for machines with instruction caches. The method uses profile information, the structure of the program, the cache size, and the cache miss penalty to guide the choice. Optimization for the cache is assumed to follow procedure merging. The method weighs the benefit of removing calls with the increase in the instruction cache miss rate. Better performance is achieved than previous schemes that do not consider the cache. Merging always results in a savings, unlike simpler schemes that can make programs slower once cache effects are considered. The new method also has better performance even when parameters to simpler algorithms are varied to get the best performance. This report is a preprint of a paper that will be presented at the ACM SIGPLAN \u201991 Conference on Programming Language Design and Implementation, Toronto, Ontario, Canada, June 26-28, 1991. Copyright \uf6d9 1990 ACM."
            },
            "slug": "Procedure-merging-with-instruction-caches-McFarling",
            "title": {
                "fragments": [],
                "text": "Procedure merging with instruction caches"
            },
            "tldr": {
                "abstractSimilarityScore": 97,
                "text": "This paper describes a method of determining which procedures to merge for machines with instruction caches that uses profile information, the structure of the program, the cache size, and the cache miss penalty to guide the choice."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '91"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2074103781"
                        ],
                        "name": "M. Nelson",
                        "slug": "M.-Nelson",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Nelson",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Nelson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2074103781"
                        ],
                        "name": "M. Nelson",
                        "slug": "M.-Nelson",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Nelson",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Nelson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 59899902,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5f68225001c70562f0c143e4f996f89a126d35b6",
            "isKey": false,
            "numCitedBy": 26,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper examines the behavior of mechanisms for providing variablesize file data caches. It presents the results of running virtual-memoryand file-intensive benchmarks on the Sprite operating system [OCD88]; the benchmarks are designed to simulate real-life applications that represent the worst case for variable-size cache mechanisms. The results indicate that variable-size cache mechanisms work well when virtualmemoryand file-intensive programs are run in sequence; the cache is able to change in size in order to provide overall performance no worse than that provided by a small fixed-size cache. However, when interactive programs are run concurrently with file-intensive programs, variable-size cache mechanisms perform very poorly if file pages and virtual-memory pages are treated equally. In order to guarantee good interactive response, virtual memory pages must be given preference over file pages."
            },
            "slug": "Virtual-Memory-vs.-The-File-System-Nelson-Nelson",
            "title": {
                "fragments": [],
                "text": "Virtual Memory vs. The File System"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "The results indicate that variable-size cache mechanisms work well when virtualmemoryand file-intensive programs are run in sequence; the cache is able to change in size in order to provide overall performance no worse than that provided by a small fixed-size caches."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 29014312,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7b3e8c323ceb4e5dba18d7eb715602c0362503fa",
            "isKey": false,
            "numCitedBy": 123,
            "numCiting": 103,
            "paperAbstract": {
                "fragments": [],
                "text": "Modifying code after the compiler has generated it can be useful for both optimization and instrumentation. Several years ago we designed the Mahler system, which uses link-time code modification for a variety of tools on our experimental Titan workstations. Killian\u2019s Pixie tool works even later, translating a fully-linked MIPS executable file into a new version with instrumentation added. Recently we wanted to develop a hybrid of the two, that would let us experiment with both optimization and instrumentation on a standard workstation, preferably without requiring us to modify the normal compilers and linker. This paper describes prototypes of two hybrid systems, closely related to Mahler and Pixie. We implemented basic-block counting in both, and compare the resulting time and space expansion to those of Mahler and Pixie."
            },
            "slug": "Systems-for-Late-Code-Modification-Wall",
            "title": {
                "fragments": [],
                "text": "Systems for Late Code Modification"
            },
            "tldr": {
                "abstractSimilarityScore": 48,
                "text": "This paper describes prototypes of two hybrid systems, closely related to Mahler and Pixie, that let us experiment with both optimization and instrumentation on a standard workstation, preferably without requiring us to modify the normal compilers and linker."
            },
            "venue": {
                "fragments": [],
                "text": "Code Generation"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2411667"
                        ],
                        "name": "S. McFarling",
                        "slug": "S.-McFarling",
                        "structuredName": {
                            "firstName": "Scott",
                            "lastName": "McFarling",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. McFarling"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7832831,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d112129bf94030addd8a1f7390f374f99979753e",
            "isKey": false,
            "numCitedBy": 887,
            "numCiting": 70,
            "paperAbstract": {
                "fragments": [],
                "text": "One of the key factors determining computer performance is the degree to which the implementation can take advantage of instruction-level parallelism. Perhaps the most critical limit to this parallelism is the presence of conditional branches that determine which instructions need to be executed next. To increase parallelism, several authors have suggested ways of predicting the direction of conditional branches with hardware that uses the history of previous branches. The different proposed predictors take advantage of different observed patterns in branch behavior. This paper presents a method of combining the advantages of these different types of predictors. The new method uses a history mechanism to keep track of which predictor is most accurate for each branch so that the most accurate predictor can be used. In addition, this paper describes a method of increasing the usefulness of branch history by hashing it together with the branch address. Together, these new techniques are shown to outperform previously known approaches both in terms of maximum prediction accuracy and the prediction accuracy for a given predictor size. Specifically, prediction accuracy reaches 98.1% correct versus 97.1% correct for the most accurate previously known approach. Also, this new approach is typically at least a factor of two smaller than other schemes for a given prediction accuracy. Finally, this new approach allows predictors with a single level of history array access to outperform schemes with multiple levels of history for all but the largest predictor sizes. Copyright \uf6d9 1993 Digital Equipment Corporation"
            },
            "slug": "Combining-Branch-Predictors-McFarling",
            "title": {
                "fragments": [],
                "text": "Combining Branch Predictors"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This paper describes a method of increasing the usefulness of branch history by hashing it together with the branch address and shows that this new approach allows predictors with a single level of history array access to outperform schemes with multiple levels of history for all but the largest predictor sizes."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40654642"
                        ],
                        "name": "V. Srinivasan",
                        "slug": "V.-Srinivasan",
                        "structuredName": {
                            "firstName": "V.",
                            "lastName": "Srinivasan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Srinivasan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 11317947,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "8601381090d7f44632233a90412b654d3c1d82d6",
            "isKey": false,
            "numCitedBy": 43,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "File caching is essential to good performance in a distributed system, especially as processor speeds and memory sizes continue to scale rapidly while disk latencies do not. Stateless-server systems, such as NFS, cannot effectively manage client file caches. Stateful systems, such as Sprite, can use explicit cache consistency protocols to achieve high performance, without some of the inconsistencies possible in NFS. By modifying NFS to use the Sprite cache consistency protocols, we isolate the effects of the consistency mechanism from the other features of Sprite. We find dramatic improvements on some, although not all, benchmarks, suggesting that an explicit cache consistency protocol is necessary for both correctness and good performance. This report is an expanded version of a paper that has been submitted for publication elsewhere. Copyright \uf6d9 1989 Digital Equipment Corporation"
            },
            "slug": "Spritely-NFS:-Implementation-and-Performance-of-Srinivasan-Mogul",
            "title": {
                "fragments": [],
                "text": "Spritely NFS: Implementation and Performance of Cache-Consistency Protocols"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "By modifying NFS to use the Sprite cache consistency protocols, this work isolates the effects of the consistency mechanism from the other features of Sprite, suggesting that an explicit cache consistency protocol is necessary for both correctness and good performance."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3008774"
                        ],
                        "name": "A. Eustace",
                        "slug": "A.-Eustace",
                        "structuredName": {
                            "firstName": "Alan",
                            "lastName": "Eustace",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Eustace"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2257959"
                        ],
                        "name": "Amitabh Srivastava",
                        "slug": "Amitabh-Srivastava",
                        "structuredName": {
                            "firstName": "Amitabh",
                            "lastName": "Srivastava",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amitabh Srivastava"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1724015,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f9d9542434949a5a32b59fe4f587b536f5c53b04",
            "isKey": false,
            "numCitedBy": 186,
            "numCiting": 87,
            "paperAbstract": {
                "fragments": [],
                "text": "Code instrumentation is a powerful mechanism for understanding program behavior. Unfortunately, code instrumentation is extremely difficult, and therefore has been mostly relegated to building special purpose tools for use on standard industry benchmark suites. \n \nATOM (Analysis Tools with OM) provides a very flexible and efficient code instrumentation interface that allows powerful, high performance program analysis tools to be built with very little effort. This paper illustrates this flexibility by building five complete tools that span the interests of application programmers, computer architects, and compiler writers. \n \nThis flexibility does not come at the expense of performance. Because ATOM uses procedure calls as the interface between the application and the analysis routines, the performance of each tool is similar to or greatly exceeds the best known hand-crafted implementations."
            },
            "slug": "ATOM:-A-Flexible-Interface-for-Building-High-Tools-Eustace-Srivastava",
            "title": {
                "fragments": [],
                "text": "ATOM: A Flexible Interface for Building High Performance Program Analysis Tools"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This paper illustrates this flexibility by building five complete tools that span the interests of application programmers, computer architects, and compiler writers and the performance of each tool is similar to or greatly exceeds the best known hand-crafted implementations."
            },
            "venue": {
                "fragments": [],
                "text": "USENIX"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7976499,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "83c970a83e1949f59dc5964b4b61865213dce835",
            "isKey": false,
            "numCitedBy": 194,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "In previous work in global register allocation, the compiler colors a conflict graph constructed from liveness dataflow information, in order to allocate the same register to many variables that are not simultaneously live. If two procedures are in separately compiled modules, however, the compiler must do this allocation separately for each procedure. As a result, the two procedures might use different registers for the same global, or the same register for different locals.\nWe can remove these problems if we delay the register allocation until link time. Our compiler produces object modules that can be linked and run without global register allocation, but includes with each object module a body of information describing how the module uses variables and procedures. A link-time register allocator then decides which variables are used most frequently, selects registers for them, and rewrites the code to reflect the decision that these variables reside in registers rather than in memory. Construction of the call graph allows us to use the same register for locals of procedures that are not simultaneously active, giving us most of the advantages of a full-scale coloring without the expense.\nWhen we use our method for 52 registers, our benchmarks speed up by 10 to 25 percent. Even with only 8 registers, the speedup can be nearly that large if we use previously collected profile information to guide the allocation. We cannot do much better, because programs whose variables all fit in registers rarely speed up by more than 30%. Moreover, profiling shows us that we usually remove 60% to 90% of the loads and stores of scalar variables that the program performs during its execution, and often much more."
            },
            "slug": "Global-register-allocation-at-link-time-Wall",
            "title": {
                "fragments": [],
                "text": "Global register allocation at link time"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Construction of the call graph allows us to use the same register for locals of procedures that are not simultaneously active, giving us most of the advantages of a full-scale coloring without the expense."
            },
            "venue": {
                "fragments": [],
                "text": "SIGPLAN '86"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 17184912,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1c5ec0b4a0684c32d626f2bfefffb8bcba084826",
            "isKey": false,
            "numCitedBy": 104,
            "numCiting": 137,
            "paperAbstract": {
                "fragments": [],
                "text": "Packets on a LAN can be viewed as a series of references to and from the objects they address. The amount of locality in this reference stream may be critical to the efficiency of network implementations, if the locality can be exploited through caching or scheduling mechanisms. Most previous studies have treated network locality with an addressing granularity of networks or individual hosts. This paper describes some experiments tracing locality at a finer grain, looking at references to individual processes, and with fine-grained time resolution. Observations of typical LANs show high per-process locality; that is, packets to a host usually arrive for the process that most recently sent a packet, and often with little intervening delay."
            },
            "slug": "Network-locality-at-the-scale-of-processes-Mogul",
            "title": {
                "fragments": [],
                "text": "Network locality at the scale of processes"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This paper describes some experiments tracing locality at a finer grain, looking at references to individual processes, and with fine-grained time resolution."
            },
            "venue": {
                "fragments": [],
                "text": "TOCS"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145922660"
                        ],
                        "name": "K. Ramakrishnan",
                        "slug": "K.-Ramakrishnan",
                        "structuredName": {
                            "firstName": "K.",
                            "lastName": "Ramakrishnan",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Ramakrishnan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 215749380,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7d15a31ef08255b5e4b38fb7034a6960cb7ecdc0",
            "isKey": false,
            "numCitedBy": 514,
            "numCiting": 144,
            "paperAbstract": {
                "fragments": [],
                "text": "Most operating systems use interface interrupts to schedule network tasks. Interrupt-driven systems can provide low overhead and good latency at low offered load, but degrade significantly at higher arrival rates unless care is taken to prevent several pathologies. These are various forms ofreceive livelock, in which the system spends all of its time processing interrupts, to the exclusion of other necessary tasks. Under extreme conditions, no packets are delivered to the user application or the output of the system. To avoid livelock and related problems, an operating system must schedule network interrupt handling as carefully as it schedules process execution. We modified an interrupt-driven networking implementation to do so; this modification eliminates receive livelock without degrading other aspects of system performance. Our modifications include the use of polling when the system is heavily loaded, while retaining the use of interrupts ur.Jer lighter load. We present measurements demonstrating the success of our approach."
            },
            "slug": "Eliminating-receive-livelock-in-an-interrupt-driven-Mogul-Ramakrishnan",
            "title": {
                "fragments": [],
                "text": "Eliminating receive livelock in an interrupt-driven kernel"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This work modified an interrupt-driven networking implementation to do so, and eliminates receive livelock without degrading other aspects of system performance, including the use of polling when the system is heavily loaded, while retaining theUse of interrupts urJer lighter load."
            },
            "venue": {
                "fragments": [],
                "text": "TOCS"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2195149"
                        ],
                        "name": "K. J. Richardson",
                        "slug": "K.-J.-Richardson",
                        "structuredName": {
                            "firstName": "Kathy",
                            "lastName": "Richardson",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. J. Richardson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 8607961,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4595837422695ce51818800c2262ac5b7e01ea5c",
            "isKey": false,
            "numCitedBy": 19,
            "numCiting": 10,
            "paperAbstract": {
                "fragments": [],
                "text": "When investigating I/O behavior, the tracing environment, simulation systems, and simulation model determine what can be measured and simulated. Workloads generate a variety of disk I/O requests to access file information, execute programs, and perform computation. The system presented here includes information about I/O requests, allowing workload components to be characterized individually. The component characterization shows that I/O requests for data have vastly different reuse rates and access patterns. Disk files can be classified as accesses to inodes, directories, datafiles or executables. Inodes and directories are small, highly reused files. Datafiles and executables have more diverse characteristics. The smaller ones exhibit moderate reuse and have little sequential access, while the larger files tend to be accessed sequentially and not reused. Properly used, file type and file size information can improve cache performance. An attribute cache scheme illustrates the importance of I/O characterization to cache design. The scheme uses file information to cache I/O data selectively tailoring the cache scheme to the expected behavior of each file type. For a set of 11 measured workloads, a variable attribute cache scheme reduced the miss ratio 25\u201360% depending on cache size, and required only about 1/8 as much memory as a typical I/O cache implementation achieving the same miss ratio."
            },
            "slug": "Component-Characterization-for-I-/-O-Cache-Designs-Richardson",
            "title": {
                "fragments": [],
                "text": "Component Characterization for I / O Cache Designs"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The component characterization shows that I/O requests for data have vastly different reuse rates and access patterns, and an attribute cache scheme illustrates the importance ofI/O characterization to cache design."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143852866"
                        ],
                        "name": "Brad Chen",
                        "slug": "Brad-Chen",
                        "structuredName": {
                            "firstName": "Brad",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Brad Chen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39409879"
                        ],
                        "name": "A. Borg",
                        "slug": "A.-Borg",
                        "structuredName": {
                            "firstName": "Anita",
                            "lastName": "Borg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Borg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47740650"
                        ],
                        "name": "Jing Chen",
                        "slug": "Jing-Chen",
                        "structuredName": {
                            "firstName": "Jing",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jing Chen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2824008,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "175f8a2d978c1911c87909351ca3851235dc8154",
            "isKey": false,
            "numCitedBy": 25,
            "numCiting": 118,
            "paperAbstract": {
                "fragments": [],
                "text": "Systems for recording address traces of operating system activity have frequently relied on special-purpose hardware and microcode modifications for data collection [1, 2, 10, 11, 30, 32]. In the last decade, changes in computer systems design have made the implementation of such hardware and microcode-based tracing systems impractical. This paper documents the evolution of a group of software methods to collect system traces. The tools require no special-purpose hardware and no hardware modifications. We have applied these tools to three substantially different operating systems and two processor architectures. This paper describes the instrumentation techniques, the means used to assure the quality of the collected data, and our evaluation of correctness and accuracy of traces. Our experience shows that software methods can yield trace of very good quality, and can be used to measure complex software systems."
            },
            "slug": "Software-Methods-for-System-Address-Tracing:-and-Chen-Wall",
            "title": {
                "fragments": [],
                "text": "Software Methods for System Address Tracing: Implementation and Validation"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This paper describes the instrumentation techniques, the means used to assure the quality of the collected data, and the evaluation of correctness and accuracy of traces."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715454"
                        ],
                        "name": "N. Jouppi",
                        "slug": "N.-Jouppi",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Jouppi",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Jouppi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "152949389"
                        ],
                        "name": "J.Y.-F. Tang",
                        "slug": "J.Y.-F.-Tang",
                        "structuredName": {
                            "firstName": "J.Y.-F.",
                            "lastName": "Tang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J.Y.-F. Tang"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 62177849,
            "fieldsOfStudy": [
                "Engineering"
            ],
            "id": "bef4fe22ebfb8355a438ea9f42207289f0f5ed2d",
            "isKey": false,
            "numCitedBy": 42,
            "numCiting": 35,
            "paperAbstract": {
                "fragments": [],
                "text": "The authors describe the design of a CPU chip with a high ratio of sustained system to peak performance (0.80). Attaining a high ratio of sustained system performance to peak performance avoids wasting circuit design effort at an architectural level through inefficient use of machine resources. The chip contains 180K transistors on a 6.98*8.73-mm/sup 2/ die utilizing a 1.5- mu m CMOS process to obtain a sustained system performance of 20 MIPS. By keeping the design simple and regular both at an architectural and circuit level, and by using high-level tools on the complete design, a high sustained performance was obtained with relatively little design effort (2.5 man years). >"
            },
            "slug": "A-20-MIPS-sustained-32-bit-CMOS-microprocessor-with-Jouppi-Tang",
            "title": {
                "fragments": [],
                "text": "A 20-MIPS sustained 32-bit CMOS microprocessor with high ratio of sustained to peak performance"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16342889,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4837cc6aeacae093d15ac16f58e29d3a5bdb36b6",
            "isKey": false,
            "numCitedBy": 76,
            "numCiting": 125,
            "paperAbstract": {
                "fragments": [],
                "text": "The Internet has experienced exponential growth in the use of the World-Wide Web, and rapid growth in the use of other Internet services such as USENET news and electronic mail. These applications qualitatively differ from other network applications in the stresses they impose on busy server systems. Unlike traditional distributed systems, Internet servers must cope with huge user communities, short interactions, and long network latencies. Such servers require different kinds of operating system features to manage their resources effectively."
            },
            "slug": "Operating-systems-support-for-busy-Internet-servers-Mogul",
            "title": {
                "fragments": [],
                "text": "Operating systems support for busy Internet servers"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "The Internet has experienced exponential growth in the use of the World-Wide Web, and rapid growth inThe use of other Internet services such as USENET news and electronic mail."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings 5th Workshop on Hot Topics in Operating Systems (HotOS-V)"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15042093,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "77e43aff22b9d6f63a755d1e2294549428f1db01",
            "isKey": false,
            "numCitedBy": 68,
            "numCiting": 103,
            "paperAbstract": {
                "fragments": [],
                "text": "Some file systems can delay writing modified data to disk, in order to reduce disk traffic and overhead. Prudence dictates that such delays be bounded, in case the system crashes. We refer to an algorithm used to decide when to write delayed data back to disk as an update policy. Traditional UNIX\u00ae systems use a periodic update policy, writing back all delayed-write data once every 30 seconds. Periodic update is easy to implement but performs quite badly in some cases. This paper describes an approximate implementation of an interval periodic update policy, in which each individual delayed-write block is written when its age reaches a threshold. Interval periodic update adds little code to the kernel and can perform much better than periodic update. In particular, interval periodic update can avoid the huge variances in read response time caused by using periodic update with a large buffer cache."
            },
            "slug": "A-Better-Update-Policy-Mogul",
            "title": {
                "fragments": [],
                "text": "A Better Update Policy"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Imaging an approximate implementation of an interval periodic update policy, in which each individual delayed-write block is written when its age reaches a threshold, can avoid the huge variances in read response time caused by using periodic update with a large buffer cache."
            },
            "venue": {
                "fragments": [],
                "text": "USENIX Summer"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 10839924,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "488ba39476fa2be5747aa46d7124e9bd8cf65172",
            "isKey": false,
            "numCitedBy": 47,
            "numCiting": 88,
            "paperAbstract": {
                "fragments": [],
                "text": "NFS suffers from its lack of an explicit cache-consistency protocol. The Spritely NFS experiment, which grafted Sprite\u2019s cache-consistency protocol onto NFS, showed that this could improve NFS performance and consistency, but failed to address the issue of server crash recovery. Several crash recovery mechanisms have been implemented for use with network file systems, but most of these are too complex to fit easily into the NFS design. Spritely NFS now uses a simple recovery protocol that requires almost no client-side support, and guarantees consistent behavior even if the network is partitioned. This work demonstrates that one need not endure a stateless protocol for the sake of a simple implementation. This Research Report is a preprint of a paper to appear in Computing Systems. d i g i t a l Western Research Laboratory 250 University Avenue Palo Alto, California 94301 USA"
            },
            "slug": "Recovery-in-Spritely-NFS-Mogul",
            "title": {
                "fragments": [],
                "text": "Recovery in Spritely NFS"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This work demonstrates that one need not endure a stateless protocol for the sake of a simple implementation of NFS, and uses a simple recovery protocol that requires almost no client-side support, and guarantees consistent behavior even if the network is partitioned."
            },
            "venue": {
                "fragments": [],
                "text": "Comput. Syst."
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34788473"
                        ],
                        "name": "Robert N. Mayo",
                        "slug": "Robert-N.-Mayo",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Mayo",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Robert N. Mayo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1811389"
                        ],
                        "name": "H. Touati",
                        "slug": "H.-Touati",
                        "structuredName": {
                            "firstName": "Herv\u00e9",
                            "lastName": "Touati",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Touati"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 18733879,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f5c76feafaedb4fa188e61df7a13eba32e66537f",
            "isKey": false,
            "numCitedBy": 37,
            "numCiting": 112,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a technology mapper for full-custom ECL gates. These gates are characterized by high fanins and a regular structure. Full-custom gates differ from ECL library gates in that a full range of structures is available as a single form, rather than a large number of individual gates that sparsely cover the possible design space. This paper presents a complete Boolean matching algorithm and gives a proof of its correctness. We show that it can efficiently map logic into the general ECL gate form. We also show two variants of the algorithm, and show that they given poorer results with no savings in runtime. The mapper described in the paper is a necessary component of a CAD system for designing ECL microprocessors. Manual design of full-custom ECL gates would not be acceptable for control logic since it is a tedious, error prone, and lengthy activity. Nor would a gate-array style mapper and library with a limited number of gates be acceptable, because this makes less effective use of the inherent speed of the technology."
            },
            "slug": "Boolean-matching-for-full-custom-ECL-gates-Mayo-Touati",
            "title": {
                "fragments": [],
                "text": "Boolean matching for full-custom ECL gates"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "A complete Boolean matching algorithm is presented and it is shown that it can efficiently map logic into the general ECL gate form and a proof of its correctness is given."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of 1993 International Conference on Computer Aided Design (ICCAD)"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 856335,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b793c24b28059b805639b05191fab1dd1e5be680",
            "isKey": false,
            "numCitedBy": 287,
            "numCiting": 139,
            "paperAbstract": {
                "fragments": [],
                "text": "The success of the World-Wide Web is largely due to the simplicity, hence ease of implementation, of the Hypertext Transfer Protocol (HTTP). HTTP, however, makes inefficient use of network and server resources, and adds unnecessary latencies, by creating a new TCP connection for each request. Modifications to HTTP have been proposed that would transport multiple requests over each TCP connection. These modifications have led to debate over their actual impact on users, on servers, and on the network. This paper reports the results of log-driven simulations of several variants of the proposed modifications, which demonstrate the value of persistent connections."
            },
            "slug": "The-case-for-persistent-connection-HTTP-Mogul",
            "title": {
                "fragments": [],
                "text": "The case for persistent-connection HTTP"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "The results of log-driven simulations of several variants of the proposed modifications to HTTP demonstrate the value of persistent connections."
            },
            "venue": {
                "fragments": [],
                "text": "SIGCOMM '95"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31942437"
                        ],
                        "name": "S. Turrini",
                        "slug": "S.-Turrini",
                        "structuredName": {
                            "firstName": "Silvio",
                            "lastName": "Turrini",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Turrini"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 30317701,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "4580f9bb5b4bc68085bfe6ae2d2252a95f4fcd00",
            "isKey": false,
            "numCitedBy": 96,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "The carry-skip adder, because of its greater topological regularity and layout simplicity, is considered a good compromise in terms of area and performance. Some general rules have been suggested for its design, but they tend to overlook many important implementation details and cannot be applied to carry-skip adders with more than two levels of carry-skip or with different delays in the carry paths. The result is a nonoptimal distribution of groups and subgroups of the carry-skip circuits, degrading the worst-case delay of the adder. A new algorithm for determining the optimal distribution with no restriction on the number of skip levels is presented. Some results and conclusions are presented regularly in the realization of such an adder in bipolar ECL technology.<<ETX>>"
            },
            "slug": "Optimal-group-distribution-in-carry-skip-adders-Turrini",
            "title": {
                "fragments": [],
                "text": "Optimal group distribution in carry-skip adders"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "A new algorithm for determining the optimal distribution with no restriction on the number of skip levels is presented, resulting in a nonoptimal distribution of groups and subgroups of the carry-skip circuits, degrading the worst-case delay of the adder."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of 9th Symposium on Computer Arithmetic"
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1701191"
                        ],
                        "name": "L. Monier",
                        "slug": "L.-Monier",
                        "structuredName": {
                            "firstName": "Louis",
                            "lastName": "Monier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Monier"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2706613"
                        ],
                        "name": "R. Haddad",
                        "slug": "R.-Haddad",
                        "structuredName": {
                            "firstName": "Ramsey",
                            "lastName": "Haddad",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Haddad"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48015954"
                        ],
                        "name": "Jeremy Dion",
                        "slug": "Jeremy-Dion",
                        "structuredName": {
                            "firstName": "Jeremy",
                            "lastName": "Dion",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jeremy Dion"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 38524172,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5b99e749eb226d9879cc8319c4e5a613e698a660",
            "isKey": false,
            "numCitedBy": 19,
            "numCiting": 98,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a recursive method for generating layout for VLSI chips based on integrating layout directives in the netlist description. The method allows seamless integration of hand-drawn and synthesized layout, so that hand layout need only be used where the increase in density is justified. Layout is generated automatically with predictable results; small changes in the source result in small changes of the overall layout. The system is versatile enough to build dense BiCMOS VLSI microprocessor chips automatically."
            },
            "slug": "Recursive-layout-generation-Monier-Haddad",
            "title": {
                "fragments": [],
                "text": "Recursive layout generation"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "The method allows seamless integration of hand-drawn and synthesized layout, so that hand layout need only be used where the increase in density is justified, and is versatile enough to build dense BiCMOS VLSI microprocessor chips automatically."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings Sixteenth Conference on Advanced Research in VLSI"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1688158"
                        ],
                        "name": "C. Hankin",
                        "slug": "C.-Hankin",
                        "structuredName": {
                            "firstName": "Chris",
                            "lastName": "Hankin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Hankin"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 29865317,
            "fieldsOfStudy": [
                "Computer Science",
                "Economics"
            ],
            "id": "268cff34722ade3d769992f75a7e50638b95eff2",
            "isKey": false,
            "numCitedBy": 15,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper introduces a special section on program analysis tools. We start by defining what we mean by \u201cprogram analysis\u201d. We identify and briefly describe three approaches to program analysis. We then introduce the three contributed papers of the section."
            },
            "slug": "Program-analysis-tools-Hankin",
            "title": {
                "fragments": [],
                "text": "Program analysis tools"
            },
            "tldr": {
                "abstractSimilarityScore": 72,
                "text": "This paper introduces a special section on program analysis tools and identifies and briefly describes three approaches to program analysis, and introduces the three contributed papers of the section."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal on Software Tools for Technology Transfer"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 626080,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3a41891900c50e6d1b3f761505093154fa4735fd",
            "isKey": false,
            "numCitedBy": 177,
            "numCiting": 68,
            "paperAbstract": {
                "fragments": [],
                "text": "The behavior of the TCP protocol in simple situations is well-understood, but when multiple connections share a set of network resources the protocol can exhibit surprising phenomena. Earlier studies have identified several such phenomena, and have analyzed them using simulation or observation of contrived situations. This paper shows how, by analyzing traces of a busy segment of the Internet, it is possible to observe these pheonomena in \u201creal life\u201d and measure both their frequency and their effects on performance. A TCP implementation might use similar techniques to support rate-based congestion control."
            },
            "slug": "Observing-TCP-dynamics-in-real-networks-Mogul",
            "title": {
                "fragments": [],
                "text": "Observing TCP dynamics in real networks"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "By analyzing traces of a busy segment of the Internet, it is shown how it is possible to observe pheonomena of the TCP protocol in \u201creal life\u201d and measure both their frequency and their effects on performance."
            },
            "venue": {
                "fragments": [],
                "text": "SIGCOMM '92"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "102406066"
                        ],
                        "name": "J. Bartlett",
                        "slug": "J.-Bartlett",
                        "structuredName": {
                            "firstName": "Joel",
                            "lastName": "Bartlett",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Bartlett"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 60750690,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "292093fe3d69b340b9dd500d14bf848c46636f59",
            "isKey": false,
            "numCitedBy": 33,
            "numCiting": 70,
            "paperAbstract": {
                "fragments": [],
                "text": "In their quest to produce tools for the production of uniform graphical user interfaces, almost all designers of toolkits for the X window system have overlooked an important capability. The best way to improve many programs is not to replace text interfaces based on command line flags with graphical buttons, but to provide programs with a simple way to draw pictures. This report describes a graphics server, ezd, that sits between an application program and the X server and allows both existing and new programs easy access to structured graphics. Programs may draw, edit, and sense user events in terms of application-defined graphical objects. When run on workstations with 10 MIPS or faster processors, interactive response is excellent, indicating that ezd\u2019s simple structured graphics drawing model can be widely applied. The enthusiastic response of ezd\u2019s initial users and the variety of uses to which they have put it to suggest that there is a tremendous pent-up urge to draw with programs and that ezd has lowered the barriers to doing so."
            },
            "slug": "Don\u2019t-Fidget-with-Widgets,-Draw!-Bartlett",
            "title": {
                "fragments": [],
                "text": "Don\u2019t Fidget with Widgets, Draw!"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "A graphics server that sits between an application program and the X server and allows both existing and new programs easy access to structured graphics, ezd, is described, suggesting that there is a tremendous pent-up urge to draw with programs and that eZd has lowered the barriers to doing so."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31942437"
                        ],
                        "name": "S. Turrini",
                        "slug": "S.-Turrini",
                        "structuredName": {
                            "firstName": "Silvio",
                            "lastName": "Turrini",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Turrini"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 208901233,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "eb594c88e8ff9d3648e75fd311784c5672d39b09",
            "isKey": false,
            "numCitedBy": 13,
            "numCiting": 35,
            "paperAbstract": {
                "fragments": [],
                "text": "The Genetic Workbench (GWB) is a software system built with the intent of investigating evolutionary or non-standard algorithms applied to difficult combinatorial problems. The user is allowed to experiment with various techniques, operators, parameters, strategies and compare the results. In particular the optimal placements of connected components or modules on a plane has been considered, but some of the strategies implemented in the GWB can be applied to other permutation based problems as well. Techniques which generate the best results have also been compared with one of the best commercial tools available, TimberWolf ver. 7, which uses a special simulated annealing algorithm, to highlight the strengths and weaknesses of the different methods. Most of the strategies used in the GWB can be classified as evolutionary or rely on some implementation of a genetic algorithm; this is the reason why the qualifier genetic has been used to name the system. For the placement problem in particular, results of running standard benchmarks are also shown at the end of this report."
            },
            "slug": "Optimizations-and-Placement-with-the-Genetic-Turrini",
            "title": {
                "fragments": [],
                "text": "Optimizations and Placement with the Genetic Workbench"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "The optimal placements of connected components or modules on a plane has been considered, but some of the strategies implemented in the GWB can be applied to other permutation based problems as well."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2345160"
                        ],
                        "name": "R. Kao",
                        "slug": "R.-Kao",
                        "structuredName": {
                            "firstName": "Russell",
                            "lastName": "Kao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kao"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 9912775,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "409f15d635ab4204bcf2aebf4b24437aaee8d35b",
            "isKey": false,
            "numCitedBy": 41,
            "numCiting": 140,
            "paperAbstract": {
                "fragments": [],
                "text": "Rsim is an efficient logic plus timing simulator that employs the switched resistor transistor model and RC tree analysis to simulate efficiently MOS digital circuits at the transistor level. We investigate the incorporation of piecewise linear transistor models and generalized moments matching into this simulation framework. General piecewise linear models allow more accurate MOS models to be used to simulate circuits that are hard for Rsim. Additionally, they enable the simulator to handle circuits containing bipolar transistors such as ECL and BiCMOS. Nonetheless, the switched resistor model has proved to be efficient and accurate for a large class of MOS digital circuits. Therefore, it is retained as just one particular model available for use in this framework. The use of piecewise linear models requires the generalization of RC tree analysis. Unlike switched resistors, more general models may incorporate gain and floating capacitance. Additionally, we extend the analysis to handle non-tree topologies and feedback. Despite the increased generality, for many common MOS and ECL circuits the complexity remains linear. Thus, this timing analysis can be used to simulate, efficiently, those portions of the circuit that are well described by traditional switch level models, while simultaneously simulating, more accurately, those portions that are not. We present preliminary results from a prototype simulator, Mom. We demonstrate its use on a number of MOS, ECL, and BiCMOS circuits."
            },
            "slug": "Piecewise-Linear-Models-for-Switch-Level-Simulation-Kao",
            "title": {
                "fragments": [],
                "text": "Piecewise Linear Models for Switch-Level Simulation"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The incorporation of piecewise linear transistor models and generalized moments matching into this simulation framework is investigated and preliminary results from a prototype simulator, Mom.Rsim, are presented."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15590585,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cb6649102e5d87f6aef8f83ba19365d8c3db76bf",
            "isKey": false,
            "numCitedBy": 91,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "Internetworks that connect multiple organizations create potential security problems that cannot be solved simply by internal administrative procedures. Organizations would like to restrict inter-organization access to specific restricted hosts and applications, in order to limit the potential for damage and to reduce the number of systems that must be secured against attack. One way to restrict access is to prevent certain packets from entering or leaving an organization through its gateways. This paper describes simple, flexible, and moderately efficient mechanisms for screening the packets that flow through a Unix-based gateway. This research report is a preprint of a paper to appear at the Summer 1989 USENIX Technical Conference. Copyright \uf6d9 1989 Digital Equipment Corporation"
            },
            "slug": "Simple-and-Flexible-Datagram-Access-Controls-for-Mogul",
            "title": {
                "fragments": [],
                "text": "Simple and Flexible Datagram Access Controls for UNIX-based Gateways"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "Simple, flexible, and moderately efficient mechanisms for screening the packets that flow through a Unix-based gateway are described."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2345160"
                        ],
                        "name": "R. Kao",
                        "slug": "R.-Kao",
                        "structuredName": {
                            "firstName": "Russell",
                            "lastName": "Kao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144764327"
                        ],
                        "name": "M. Horowitz",
                        "slug": "M.-Horowitz",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Horowitz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Horowitz"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 17439896,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c53e30f85eee98c77e2b23344c8f0b08fb3ccacb",
            "isKey": false,
            "numCitedBy": 10,
            "numCiting": 64,
            "paperAbstract": {
                "fragments": [],
                "text": "Rsim is a switch-level simulator which can simulate large digital MOS integrated circuits with speedups of over three orders of magnitude over SPICE. Unfortunately, Rsim's simple switched-resistor model renders it incapable of simulating certain CMOS and most BiCMOS and ECL digital circuits. We observe that the switched-resistor model is just one particular piecewise linear model and that Rsim's simulation framework can accommodate more elaborate piecewise linear models. The resulting simulator, Mom, combines the efficiency of switch-level simulation with the ability to simulate a wider variety of circuits. We demonstrate Mom's efficiency and flexibility on a variety of circuits."
            },
            "slug": "Piecewise-linear-models-for-Rsim-Kao-Horowitz",
            "title": {
                "fragments": [],
                "text": "Piecewise linear models for Rsim"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This work observes that the switched-resistor model is just one particular piecewise linear model and that Rsim's simulation framework can accommodate more elaborate piecewiselinear models, and combines the efficiency of switch-level simulation with the ability to simulate a wider variety of circuits."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of 1993 International Conference on Computer Aided Design (ICCAD)"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715454"
                        ],
                        "name": "N. Jouppi",
                        "slug": "N.-Jouppi",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Jouppi",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Jouppi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2057805623"
                        ],
                        "name": "S. Menon",
                        "slug": "S.-Menon",
                        "structuredName": {
                            "firstName": "Suresh",
                            "lastName": "Menon",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Menon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1704733"
                        ],
                        "name": "S. Sidiropoulos",
                        "slug": "S.-Sidiropoulos",
                        "structuredName": {
                            "firstName": "Stefanos",
                            "lastName": "Sidiropoulos",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Sidiropoulos"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 58361524,
            "fieldsOfStudy": [
                "Engineering"
            ],
            "id": "aa38d87923d66eb3587f5bd5fb23f52b78f90c57",
            "isKey": false,
            "numCitedBy": 15,
            "numCiting": 95,
            "paperAbstract": {
                "fragments": [],
                "text": "Low-swing (<600mV) submicron BiCMOS circuits have many advantages over fullswing BiCMOS, CMOS, or small-swing bipolar circuits. We show that the optimal speed fan-in for low-swing BiCMOS logic circuits is generally in the range of 7 to 20, depending on the process characteristics and gate topology. This high fan-in means that the bipolar device parasitic capacitances primarily determine the circuit speed and speedpower products, instead of f as in the case of low fan-in mux/demux communication T circuits. SiGe HBT BiCMOS circuits are attractive for logic circuits not primarily for their higher f , but rather for their increased maximum device currents for a given T parasitic capacitance and for their smaller V , which can lower chip power dissipation. be Finally, for small-swing BiCMOS circuits to be competitive with CMOS they must also be built from the same lithography as CMOS circuits, have local interconnect for interdevice intra-gate wiring, and be built with a full-custom design methodology. Copyright \uf6d9 1994 Digital Equipment Corporation d i g i t a l Western Research Laboratory 250 University Avenue Palo Alto, California 94301 USA"
            },
            "slug": "Circuit-and-Process-Directions-for-Low-Voltage-Jouppi-Menon",
            "title": {
                "fragments": [],
                "text": "Circuit and Process Directions for Low-Voltage Swing Submicron BiCMOS"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "For small-swing BiCMOS circuits to be competitive with CMOS they must also be built from the same lithography as CMOS circuits, have local interconnect for interdevice intra-gate wiring, and be built with a full-custom design methodology."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2181321"
                        ],
                        "name": "W. Hamburgen",
                        "slug": "W.-Hamburgen",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Hamburgen",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Hamburgen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 9610530,
            "fieldsOfStudy": [
                "Physics"
            ],
            "id": "bcadd6a8e2f395930c8c2a476bb35f250a81fa5a",
            "isKey": false,
            "numCitedBy": 91,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "In a multi-board computer system, the volume allocated for heat removal is often a significant fraction of the total system volume. Cooling requirements can thus impact performance, reliability, cost, acoustic noise, and floorspace. This work addresses the volume costs or space requirements for removing heat with optimally designed finned heat sinks. Simple formulas applicable to both gas and liquid cooling problems provide upper bounds on the thermal resistance of an optimal heat sink, without explicitly designing the part. Conservative junction temperature estimates can thus be made without detailed design."
            },
            "slug": "Optimal-Finned-Heat-Sinks-Hamburgen",
            "title": {
                "fragments": [],
                "text": "Optimal Finned Heat Sinks"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48003495"
                        ],
                        "name": "P. Boyle",
                        "slug": "P.-Boyle",
                        "structuredName": {
                            "firstName": "Patrick",
                            "lastName": "Boyle",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Boyle"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 59649083,
            "fieldsOfStudy": [
                "Engineering"
            ],
            "id": "c3b71662153960b0c97461b064c453cf91710c29",
            "isKey": false,
            "numCitedBy": 20,
            "numCiting": 63,
            "paperAbstract": {
                "fragments": [],
                "text": "BIPS-0 is a fully-integrated bipolar processor chip with 100K ECL compatible inputs and outputs. Its external clock rate is about 100 MHz, with an on-chip clock rate of about 300 MHz. The BIPS-0 chip is packaged in a 504 pin plastic pin grid array (PPGA) which provides 5 power planes, and two stripline signal layers designed to offer 348 signal lines with a characteristic impedance of 50 \u03a9. The chip\u2019s signal input pads include 50 \u03a9 termination resistors. In a system, the BIPS-0 package may be placed in a standard 504 pin zero insertion force (ZIF) socket which is soldered into a standard printed circuit board. Using Time Domain Reflectometry (TDR) and Time Domain Transmission (TDT) techniques, the package trace impedance, impedance discontinuities due to the pins and bond wires, termination resistor resistance, signal edge rates, signal quality, crosstalk, and the performance degradation due to the ZIF socket were investigated. The results of this investigation will be used in the design of the package for BIPS-1 which will have an external clock rate of about 200 Mhz. Copyright \uf6d9 1992 Digital Equipment Corporation d i g i t a l Western Research Laboratory 250 University Avenue Palo Alto, California 94301 USA"
            },
            "slug": "Electrical-Evaluation-Of-The-BIPS-0-Package-Boyle",
            "title": {
                "fragments": [],
                "text": "Electrical Evaluation Of The BIPS-0 Package"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "102406066"
                        ],
                        "name": "J. Bartlett",
                        "slug": "J.-Bartlett",
                        "structuredName": {
                            "firstName": "Joel",
                            "lastName": "Bartlett",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Bartlett"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 23010385,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "551bf6db88cec1a33f46c44647a514ce20929f1b",
            "isKey": false,
            "numCitedBy": 26,
            "numCiting": 93,
            "paperAbstract": {
                "fragments": [],
                "text": "Ramonamap is an iterative map for database and communication services within our workgroup. Resources are represented as icons on the map, which preserves their actual (or implied) physical location and capitalizes on a user's understanding of maps. The map is interactive, giving the user control over the level of detail visible, allowing more information and services to appear than could be placed on a static map. The interactivity also allows users to change the map and add icon annotations. Since the map is continuously derived from an on-line database, changes and annotations are immediately shared by all users. As the database contains a wealth of information about the group, it also serves as a source for static maps for other purposes."
            },
            "slug": "Ramonamap\u2014an-example-of-graphical-groupware-Bartlett",
            "title": {
                "fragments": [],
                "text": "Ramonamap\u2014an example of graphical groupware"
            },
            "tldr": {
                "abstractSimilarityScore": 78,
                "text": "Ramonamap is an iterative map for database and communication services within the authors' workgroup, which preserves their actual (or implied) physical location and capitalizes on a user's understanding of maps."
            },
            "venue": {
                "fragments": [],
                "text": "UIST '94"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "102406066"
                        ],
                        "name": "J. Bartlett",
                        "slug": "J.-Bartlett",
                        "structuredName": {
                            "firstName": "Joel",
                            "lastName": "Bartlett",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Bartlett"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 18794418,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2254ae08aefdaa860c09ec8aad5dd5e69012c5b8",
            "isKey": false,
            "numCitedBy": 43,
            "numCiting": 84,
            "paperAbstract": {
                "fragments": [],
                "text": "In order to separate promises from practice in personal digital assistants (PDAs) and wireless communications, we decided to try to build a wireless PDA-based client to access the world wide web. Using equipment available in the winter of 1994, we were able to build a client that we call W4, the Wireless World Wide Web. In this paper we describe our initial design choices, implementation, experience with the device, and close with some thoughts about next steps in this area."
            },
            "slug": "Experience-with-a-wireless-world-wide-web-client-Bartlett",
            "title": {
                "fragments": [],
                "text": "Experience with a wireless world wide web client"
            },
            "tldr": {
                "abstractSimilarityScore": 53,
                "text": "W4, the Wireless World Wide Web is built, a wireless PDA-based client to access the world wide web that is able to separate promises from practice in personal digital assistants (PDAs) and wireless communications."
            },
            "venue": {
                "fragments": [],
                "text": "Digest of Papers. COMPCON'95. Technologies for the Information Superhighway"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2181321"
                        ],
                        "name": "W. Hamburgen",
                        "slug": "W.-Hamburgen",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Hamburgen",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Hamburgen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 109547257,
            "fieldsOfStudy": [
                "Materials Science"
            ],
            "id": "3559b9468e40598c816dd30f544e5d19c042d93b",
            "isKey": false,
            "numCitedBy": 40,
            "numCiting": 1,
            "paperAbstract": {
                "fragments": [],
                "text": "Many electronic assembly processes require dispensing small dots of heavily filled materials such as solder paste and loaded epoxies. Methods for rapidly optimizing processes that control the size and shape of such dots are reported. The approach taken was to separate the process that control the size and shape of such dots are reported. The approach taken was to separate the process of making a known quantity of material appear at the dispenser tip from the process of depositing that material on the workpiece. It was found that controlling dot mass depends primarily on understanding valve frequency response, and that the shape of the dot is primarily a function of the height from which it is released. The author describes how a paste dot is dispensed, presents data from a series of characterization experiments, and discusses how to apply what was learned to a broad range of materials, equipment, and processes.<<ETX>>"
            },
            "slug": "Precise-robotic-paste-dot-dispensing-Hamburgen",
            "title": {
                "fragments": [],
                "text": "Precise robotic paste dot dispensing"
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings., 39th Electronic Components Conference"
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "98073502"
                        ],
                        "name": "Bill Hamburgen",
                        "slug": "Bill-Hamburgen",
                        "structuredName": {
                            "firstName": "Bill",
                            "lastName": "Hamburgen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bill Hamburgen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2238476"
                        ],
                        "name": "J. Mogul",
                        "slug": "J.-Mogul",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Mogul",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mogul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2064151974"
                        ],
                        "name": "B. Reid",
                        "slug": "B.-Reid",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Reid",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Reid"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3008774"
                        ],
                        "name": "A. Eustace",
                        "slug": "A.-Eustace",
                        "structuredName": {
                            "firstName": "Alan",
                            "lastName": "Eustace",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Eustace"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2067775194"
                        ],
                        "name": "R. Swan",
                        "slug": "R.-Swan",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Swan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Swan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "21552650"
                        ],
                        "name": "M. Doherty",
                        "slug": "M.-Doherty",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Doherty",
                            "middleNames": [
                                "Jo"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Doherty"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "102406066"
                        ],
                        "name": "J. Bartlett",
                        "slug": "J.-Bartlett",
                        "structuredName": {
                            "firstName": "Joel",
                            "lastName": "Bartlett",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Bartlett"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 127613698,
            "fieldsOfStudy": [
                "Engineering"
            ],
            "id": "7d1e898582bd08bfa83caa52e6bdeed2c4ee9017",
            "isKey": false,
            "numCitedBy": 16,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "Recent anecdotal reports of novel principles of illumination have stressed qualitative aspects. This note presents a quantitative study of an organic illumintation system, characterizing the temperature and current-flow properties of the system as functions of time and device parameters. Theoretical and practical implications of these measurements are discussed."
            },
            "slug": "Characterization-of-Organic-Illumination-Systems-Hamburgen-Mogul",
            "title": {
                "fragments": [],
                "text": "Characterization of Organic Illumination Systems"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143792301"
                        ],
                        "name": "W. Yamamoto",
                        "slug": "W.-Yamamoto",
                        "structuredName": {
                            "firstName": "Wayne",
                            "lastName": "Yamamoto",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Yamamoto"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143939198"
                        ],
                        "name": "M. Nemirovsky",
                        "slug": "M.-Nemirovsky",
                        "structuredName": {
                            "firstName": "Mario",
                            "lastName": "Nemirovsky",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Nemirovsky"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 29,
                                "start": 25
                            }
                        ],
                        "text": "Y amamoto and Nemirovsky [14] evaluated an SMT architecture with separate instruction queues for up to 4 threads."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 26428673,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7427b2d16ae1c0eedd5387e2dc80c880c0ee2aee",
            "isKey": false,
            "numCitedBy": 110,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Increasing-superscalar-performance-through-Yamamoto-Nemirovsky",
            "title": {
                "fragments": [],
                "text": "Increasing superscalar performance through multistreaming"
            },
            "venue": {
                "fragments": [],
                "text": "PACT"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698456"
                        ],
                        "name": "B. Calder",
                        "slug": "B.-Calder",
                        "structuredName": {
                            "firstName": "Brad",
                            "lastName": "Calder",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Calder"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145647573"
                        ],
                        "name": "D. Grunwald",
                        "slug": "D.-Grunwald",
                        "structuredName": {
                            "firstName": "Dirk",
                            "lastName": "Grunwald",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Grunwald"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1410813914"
                        ],
                        "name": "Amitabh Srivastava",
                        "slug": "Amitabh-Srivastava",
                        "structuredName": {
                            "firstName": "Amitabh",
                            "lastName": "Srivastava",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amitabh Srivastava"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7845724,
            "fieldsOfStudy": [
                "Business"
            ],
            "id": "04d4ea1badeb008d213312ba3631ada174908a95",
            "isKey": false,
            "numCitedBy": 30,
            "numCiting": 150,
            "paperAbstract": {
                "fragments": [],
                "text": "Accurate static branch prediction is the key to many techniques for exposing, enhancing, and exploiting Instruction Level Parallelism (ILP). The initial work on static correlated branch prediction (SCBP) demonstrated improvements in branch prediction accuracy, but did not address overall performance. In particular SCBP expands the size of executable programs, which negatively affects the performance of the instruction memory hierarchy. Using the profile information available under SCBP we can minimize these negative performance effects through the application of code layout and branch alignment techniques. We evaluate the performance effect of SCBP and these profile-driven optimizations on instruction cache misses, branch mispredictions, and branch misfetches for a number of recent processor implementations. We find that SCBP improves performance over (traditional) per-branch static profile prediction. We also find that SCBP improves the performance benefits gained from branch alignment. As expected, SCBP gives larger benefits on machine organizations with high mispredict/misfetch penalties and low cache miss penalties. Finally, we find that the application of profile-driven code layout and branch alignment techniques (without SCBP) can improve the performance of the dynamic correlated branch prediction techniques."
            },
            "slug": "The-predictability-of-branches-in-libraries-Calder-Grunwald",
            "title": {
                "fragments": [],
                "text": "The predictability of branches in libraries"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "This work finds that the application of profile-driven code layout and branch alignment techniques (without SCBP) can improve the performance of the dynamic correlated branch prediction techniques."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 28th Annual International Symposium on Microarchitecture"
            },
            "year": 1995
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Server Architecture and Im''Boiling Binary Mixtures at Subatmospheric Presplementation"
            },
            "venue": {
                "fragments": [],
                "text": "Server Architecture and Im''Boiling Binary Mixtures at Subatmospheric Presplementation"
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A One-Dimensional Thermal Model for the VAX ''Experience with a Software-defined Machine Ar- 9000 Multi Chip Units"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Research Report Report"
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 121,
                                "start": 118
                            }
                        ],
                        "text": "The multiprogramming workload was compiled with cc; the parallel benchmarks were compiled with the Multiflow compiler [5], which has been modified to produce Alpha executables."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Multiflow  trace  15  scheduling compiler"
            },
            "venue": {
                "fragments": [],
                "text": "InJournal of Supercomputing"
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Breach , and T . Vijaykumar , \u201c Multiscalar Processors"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1992
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "How Useful Are Non-blocking Loads, Stream Buf''Limits of Instruction-Level Parallelism.'' David fers, and Speculative Execution in Multiple Issue W"
            },
            "venue": {
                "fragments": [],
                "text": "November Processors?.'' Keith I. Farkas, Norman 1993. P. Jouppi, and Paul Chow. WRL Research Report 94"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Integration and Packaging Plateaus of Processor ''Pool Boiling Enhancement Techniques for Water at Performance"
            },
            "venue": {
                "fragments": [],
                "text": "John Research Report"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "November ''Cache Write Policies and Performance"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "November ''Cache Write Policies and Performance"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Predictability of Libraries WRL Technical Note TN-50"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Reports and Technical Notes are available on the World Wide Web"
            },
            "year": 1995
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 141,
                                "start": 138
                            }
                        ],
                        "text": "After instruction decoding, the register-renaming logic maps the architectural registers to the hardware renaming registers to remove false dependencies."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "UltraSPARC 1), October 3, 1994 (HP PA-8000)"
            },
            "venue": {
                "fragments": [],
                "text": "Microprocessor ReportIntel Pentium Pro)"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading References"
            },
            "venue": {
                "fragments": [],
                "text": "Exploiting Choice: Instruction Fetch and Issue on an Implementable Simultaneous Multithreading References"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Precise Robotic Paste Dot DispensingRegister Windows vs. Register Allocation"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report WRL Research Report"
            },
            "year": 1987
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Efficient Generation of Test Patterns Using ''Pool Boiling on Small Heat Dissipating Elements in Boolean Satisfiablilty.'' Tracy Larrabee. WRL Water at Subatmospheric Pressure"
            },
            "venue": {
                "fragments": [],
                "text": "Efficient Generation of Test Patterns Using ''Pool Boiling on Small Heat Dissipating Elements in Boolean Satisfiablilty.'' Tracy Larrabee. WRL Water at Subatmospheric Pressure"
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "WRL Research Report Research Report"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report Research Report"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Why Aren't Operating Systems Getting Faster As Fast As Hardware?.'' John Ousterhout. WRL ''TurboChannel Versatec Adapter"
            },
            "venue": {
                "fragments": [],
                "text": "Why Aren't Operating Systems Getting Faster As Fast As Hardware?.'' John Ousterhout. WRL ''TurboChannel Versatec Adapter"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Long Address Traces from RISC Machines: ''Analysis of Power Supply Networks in VLSI Cir- Generation and Analysis"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Systems for Late Code ModificationLink-Time Optimization of Address Calculation on W May a 64-bit Architecture"
            },
            "venue": {
                "fragments": [],
                "text": "Wall. WRL Research Report Wall. WRL Research Report"
            },
            "year": 1992
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Distribution of Instruction-Level and Machine ''A Simulation Based Study of TLB Performance.'' Parallelism and Its Effect on Performance"
            },
            "venue": {
                "fragments": [],
                "text": "Norman Norman P. Jouppi. WRL Research Report P. Jouppi. WRL Research Report"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Software-Only Approach for Supporting Fine-Grain Shared MemoryCache Replacement with Dynamic Exclusion"
            },
            "venue": {
                "fragments": [],
                "text": "Tech- Scott McFarling. WRL Technical Note TN-22, nical Note TN-4"
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Stupid Memory: A Fast X Server for a Dumb Color Frame BufferA Comparison of Acoustic and Infrared Inspection WRL Technical Note TN-9"
            },
            "venue": {
                "fragments": [],
                "text": "Techniques for Die Attach.'' John S. Fitch. WRL Technical Note TN-24"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Link-Time Code ModificationProcedure Merging with Instruction Caches"
            },
            "venue": {
                "fragments": [],
                "text": "Research Report"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Architectural and Organizational Tradeoffs in the ''1990 DECWRL/Livermore Magic Release Design of the MultiTitan CPU"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Increasing superscalar performance through multistreaming WRL Research Reports ''Titan System Manual"
            },
            "venue": {
                "fragments": [],
                "text": "IFIP WG10.3 Working Conference on Parallel Architectures and Compilation Techniques (PACT 95)"
            },
            "year": 1986
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 121,
                                "start": 118
                            }
                        ],
                        "text": "The multiprogramming workload was compiled with cc; the parallel benchmarks were compiled with the Multiflow compiler [5], which has been modified to produce Alpha executables."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Ruttenber  g. The Multiflow trace  15  scheduling compiler"
            },
            "venue": {
                "fragments": [],
                "text": "Journal of Super  computing,"
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "SCHEME->C A Portable Scheme-to-C CompilerFragmentation Considered Harmful"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report WRL Research Report"
            },
            "year": 1987
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Performance Implications of Multiple Pointer ''An Enhanced Access and Cycle Time Model for Sizes On-Chip Caches"
            },
            "venue": {
                "fragments": [],
                "text": "man P. Jouppi. WRL Research Report WRL Research Report"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Schematic Drawing InterpreterEfficient Procedure Mapping using Cache Line W. Haddad. WRL Research Report 95/1, March Coloring"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1995
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Proc. Int'l Symp. Computer Architecture"
            },
            "venue": {
                "fragments": [],
                "text": "Proc. Int'l Symp. Computer Architecture"
            },
            "year": 1996
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Mostly-Copying Garbage Collection Picks Up ''A Recovery Protocol For Spritely NFS.'' Jeffrey Generations and C++"
            },
            "venue": {
                "fragments": [],
                "text": "Mostly-Copying Garbage Collection Picks Up ''A Recovery Protocol For Spritely NFS.'' Jeffrey Generations and C++"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Noise Issues in the ECL Circuit Family"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Optimization in Permutation Spaces.'' Silvio Turrini"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1996
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "venue": {
                "fragments": [],
                "text": "WRL Research Report"
            },
            "year": 1995
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 3,
            "methodology": 12
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 96,
        "totalPages": 10
    },
    "page_url": "https://www.semanticscholar.org/paper/Simultaneous-multithreading:-a-platform-for-Eggers-Emer/c9d6abd295a9428f249d33901275b7a67d0869cb?sort=total-citations"
}