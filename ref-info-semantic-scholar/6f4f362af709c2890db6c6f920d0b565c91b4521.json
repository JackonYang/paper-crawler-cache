{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39916351"
                        ],
                        "name": "R. Duffin",
                        "slug": "R.-Duffin",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Duffin",
                            "middleNames": [
                                "James"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Duffin"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 117933990,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "40b41ea7039443528c88145bb20cdd8a3bf81f01",
            "isKey": false,
            "numCitedBy": 116,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": "Fourier treated a system of linear inequalities by a method of elimination of variables. This method can be used to derive the duality theory of linear programming. Perhaps this furnishes the quickest proof both for finite and infinite linear programs. For numerical evaluation of a linear program, Fourier\u2019s procedure is very cumbersome because a variable is eliminated by adding each pair of inequalities having coefficients of opposite sign. This introduces many redundant inequalities. However, modifications are possible which reduce the number of redundant inequalities generated. With these modifications the method of Fourier becomes a practical computational algorithm for a class of parametric linear programs."
            },
            "slug": "On-fourier\u2019s-analysis-of-linear-inequality-systems-Duffin",
            "title": {
                "fragments": [],
                "text": "On fourier\u2019s analysis of linear inequality systems"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1974
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50073003"
                        ],
                        "name": "M. Wolfe",
                        "slug": "M.-Wolfe",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolfe",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wolfe"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 8906913,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "831cc6d9b7a333b38d34d923b52aed438e90ee1e",
            "isKey": false,
            "numCitedBy": 455,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "Subdividing the iteration space of a loop into blocks or tiles with a fixed maximum size has several advantages. Tiles become a natural candidate as the unit of work for parallel task scheduling. Synchronization between processors can be done between tiles, reducing synchronization frequency (at some loss of potential parallelism). The shape and size of a tile can be optimized to take advantage of memory locality for memory hierarchy utilization. Vectorization and register locality naturally fits into the optimization within a tile, while parallelization and cache locality fits into optimization between tiles."
            },
            "slug": "More-iteration-space-tiling-Wolfe",
            "title": {
                "fragments": [],
                "text": "More iteration space tiling"
            },
            "tldr": {
                "abstractSimilarityScore": 98,
                "text": "Subdividing the iteration space of a loop into blocks or tiles with a fixed maximum size has several advantages, and tiles become a natural candidate as the unit of work for parallel task scheduling."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 1989 ACM/IEEE Conference on Supercomputing (Supercomputing '89)"
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144005858"
                        ],
                        "name": "W. Shang",
                        "slug": "W.-Shang",
                        "structuredName": {
                            "firstName": "Weijia",
                            "lastName": "Shang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Shang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144371682"
                        ],
                        "name": "J. Fortes",
                        "slug": "J.-Fortes",
                        "structuredName": {
                            "firstName": "Jos\u00e9",
                            "lastName": "Fortes",
                            "middleNames": [
                                "A.",
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Fortes"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 30565554,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "32f1e2b9839eed251cad230a046281a2236b2540",
            "isKey": false,
            "numCitedBy": 70,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "Uniform dependence algorithms with arbitrary index sets are considered, and two computationally inexpensive methods to find their independent partitions are proposed. Each method has advantages over the other one for certain kinds of applications, and they both outperform previously proposed approaches in terms of computational complexity and/or optimality. Also, lower and upper bounds are given for the cardinality of maximal independent partitions. In multiple instruction multiple data (MIMD) systems, if different blocks of an independent partition are assigned to different processors, communications between processors will be minimized to zero. This is significant because the communications usually dominate the overhead in MIMD machines. >"
            },
            "slug": "Independent-Partitioning-of-Algorithms-with-Uniform-Shang-Fortes",
            "title": {
                "fragments": [],
                "text": "Independent Partitioning of Algorithms with Uniform Dependencies"
            },
            "tldr": {
                "abstractSimilarityScore": 79,
                "text": "Uniform dependence algorithms with arbitrary index sets are considered, and two computationally inexpensive methods to find their independent partitions are proposed, and lower and upper bounds are given for the cardinality of maximal independent partitions."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Computers"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48201534"
                        ],
                        "name": "M. C. Cheng",
                        "slug": "M.-C.-Cheng",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Cheng",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. C. Cheng"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 123081879,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "345f8f2734f937516f157f2e3fb3377281f342a2",
            "isKey": false,
            "numCitedBy": 40,
            "numCiting": 6,
            "paperAbstract": {
                "fragments": [],
                "text": "A system of linear inequalities subject to nonnegativity restrictions is considered. General criteria which are necessary and sufficient for a linear inequality to be redundant are derived. This general characterization provides a basis for unifying some of the existing techniques. After taking into consideration the existence of redundant linear inequalities, general necessary and sufficient criteria for a linear inequality to be nonredundant are also obtained. An example is given to illustrate the application of these new criteria."
            },
            "slug": "General-criteria-for-redundant-and-nonredundant-Cheng",
            "title": {
                "fragments": [],
                "text": "General criteria for redundant and nonredundant linear inequalities"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912411"
                        ],
                        "name": "F. Irigoin",
                        "slug": "F.-Irigoin",
                        "structuredName": {
                            "firstName": "Fran\u00e7ois",
                            "lastName": "Irigoin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Irigoin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3317184"
                        ],
                        "name": "R. Triolet",
                        "slug": "R.-Triolet",
                        "structuredName": {
                            "firstName": "R\u00e9mi",
                            "lastName": "Triolet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Triolet"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2980454,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "38747b103e631e1a3800a0f4aed496d1bf8fb82f",
            "isKey": false,
            "numCitedBy": 584,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Supercompilers must reschedule computations defined by nested DO-loops in order to make an efficient use of supercomputer features (vector units, multiple elementary processors, cache memory, etc\u2026). Many rescheduling techniques like loop interchange, loop strip-mining or rectangular partitioning have been described to speedup program execution. We present here a class of partitionings that encompasses previous techniques and provides enough flexibility to adapt code to multiprocessors with two levels of parallelism and two levels of memory."
            },
            "slug": "Supernode-partitioning-Irigoin-Triolet",
            "title": {
                "fragments": [],
                "text": "Supernode partitioning"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A class of partitionings is presented that encompasses previous techniques and provides enough flexibility to adapt code to multiprocessors with two levels of parallelism and two level of memory."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '88"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1759383"
                        ],
                        "name": "J. Peir",
                        "slug": "J.-Peir",
                        "structuredName": {
                            "firstName": "Jih-Kwon",
                            "lastName": "Peir",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Peir"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 62702812,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e7d0ac9f69563e870461be11b826ff0e815b4924",
            "isKey": false,
            "numCitedBy": 29,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Since the mid 1970's, vector machines have dominated the supercomputer market. Because of technological limitations, faster circuits and more levels of pipelining of vector processors can no longer satisfy the increasing demand for high-speed computation. Multiprocessing problems in parallel is a natural trend. Five essential issues are identified in solving problems on multiprocessor systems: control structure, program partitioning, scheduling, synchronization, and memory access. The solutions of these problems determine the performance and efficiency of future multiprocessor machines. \nThis thesis introduces new solutions for the synchronization and partitioning problems. The bit-map method synchronizes concurrent executing processes at the data level. Each synchronized data element has an attached sync field, and each synchronization memory operation contains a mask value. The data can be accessed only when the mask matches the sync. A proper referencing order for the data can be maintained. Two factors are considered when partitioning a program into processes executing in parallel: amount of parallelism and memory access and synchronization overhead. This thesis introduces a minimum distance method which partitions a recurrence loop into independent execution sets. This method uses the minimum dependence distance of each dimension of all dependence cycles to divide the index set of the loop into independent partitions. When a loop does not have a sufficient number of independent sets, the block and the interleaved methods partition the loop using a proper synchronization mechanism. A programmer assistance tool helps programmers in using these partitioning and synchronization methods. A simulator in the tool compares different partitioning strategies. This programmer assistance methodology allows users to explore several algorithms and select one which fits the appropriate multiprocessor architecture."
            },
            "slug": "Program-partitioning-and-synchronization-on-systems-Peir",
            "title": {
                "fragments": [],
                "text": "Program partitioning and synchronization on multiprocessor systems"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "A minimum distance method which partitions a recurrence loop into independent execution sets and uses the minimum dependence distance of each dimension of all dependence cycles to divide the index set of the loop intoindependent partitions is introduced."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144616193"
                        ],
                        "name": "R. Allen",
                        "slug": "R.-Allen",
                        "structuredName": {
                            "firstName": "Randy",
                            "lastName": "Allen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "153281265"
                        ],
                        "name": "D. Callahan",
                        "slug": "D.-Callahan",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Callahan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Callahan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14906277,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c2f152df1665a13d3230473dd216aee922c53712",
            "isKey": false,
            "numCitedBy": 177,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": "An algorithm for transforming sequential programs into equivalent parallel programs is presented. The method concentrates on finding loops whose separate iterations can be run in parallel without synchronization. Although a simple version of the method can be shown to be optimal, the problem of generating optimal code when loop interchange is employed is shown to be intractable. These methods are implemented in an experimental translation system developed at Rice University."
            },
            "slug": "Automatic-decomposition-of-scientific-programs-for-Allen-Callahan",
            "title": {
                "fragments": [],
                "text": "Automatic decomposition of scientific programs for parallel execution"
            },
            "tldr": {
                "abstractSimilarityScore": 71,
                "text": "An algorithm for transforming sequential programs into equivalent parallel programs is presented and the problem of generating optimal code when loop interchange is employed is shown to be intractable."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '87"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145516797"
                        ],
                        "name": "Allan Porterfield",
                        "slug": "Allan-Porterfield",
                        "structuredName": {
                            "firstName": "Allan",
                            "lastName": "Porterfield",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Allan Porterfield"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 53901676,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ddc6200131e858f49eb14fc81fda91cefe3019e9",
            "isKey": false,
            "numCitedBy": 225,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Measurements of actual supercomputer cache performance has not been previously undertaken. PFC-Sim is a program-driven event tracing facility that can simulate data cache performance of very long programs. PFC-Sim simulates cache concurrently with program execution, allowing very long traces to be used. Programs with traces in excess of 4 billion entries have been used to measure the performance of various cache structures. \nPFC-Sim was used to measure the cache performance of array references in a benchmark set of supercomputer applications, RiCEPS. Data cache hit ratios varied on average between 70% for a 16K cache and 91% for a 256K cache. Programs with very large working sets generate poor cache performance even with large caches. The hit ratios of individual references are measured to either 0% or 100%. \nBy locating the references that miss, attempts to improve memory performance can focus on references where improvement is possible. The compiler can estimate the number of loop iterations which can execute without filling the cache, the overflow iteration. The overflow iteration combined with the dependence graph can be used to determine at each reference whether execution will result in hits or misses. \nProgram transformation can be used to improve cache performance by reordering computation to move references to the same memory location closer together, thereby eliminating cache misses. Using the overflow iteration, the compiler can often do this transformation automatically. Standard blocking transformations cannot be used on many loop nests that contain transformation preventing dependences. Wavefront blocking allows any loop nest to be blocked, when the components of dependence vectors are bounded. \nWhen the cache misses cannot be eliminated, software prefetching can overlap the miss delays with computation. Software prefetching uses a special instruction to preload values into the cache. A cache load resembles a register load in structure, but does not block computation and only moves the address into cache where a later register load will be required. The compiler can inform the cache (on average) over 100 cycles before a load is required. Cache misses can be serviced in parallel with computation."
            },
            "slug": "Software-methods-for-improvement-of-cache-on-Porterfield-Kennedy",
            "title": {
                "fragments": [],
                "text": "Software methods for improvement of cache performance on supercomputer applications"
            },
            "tldr": {
                "abstractSimilarityScore": 84,
                "text": "Measurements of actual supercomputer cache performance has not been previously undertaken, and PFC-Sim, a program-driven event tracing facility that can simulate data cache performance of very long programs, is used to measure the performance of various cache structures."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144653825"
                        ],
                        "name": "A. Aiken",
                        "slug": "A.-Aiken",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Aiken",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Aiken"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145330843"
                        ],
                        "name": "A. Nicolau",
                        "slug": "A.-Nicolau",
                        "structuredName": {
                            "firstName": "Alexandru",
                            "lastName": "Nicolau",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Nicolau"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 118836301,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1b3860375a8c53b063350eef38020807e6df70f0",
            "isKey": false,
            "numCitedBy": 36,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Loop unwinding is a well-known technique for reducing loop overhead, exposing parallelism, and increasing the efficiency of pipelining. Traditional loop unwinding is limited to the innermost loop of a set of nested loops and the amount of unwinding is either fixed or must be specified by the user. In this paper we present a general technique, loop quantization, for unwinding multiple nested loops, explain its advantages over other transformations, and illustrate its practical effectiveness. An abstraction of nested loops is presented which leads to results about the complexity of computing quantizations and an algorithm."
            },
            "slug": "Loop-Quantization:-an-Analysis-and-Algorithm-Aiken-Nicolau",
            "title": {
                "fragments": [],
                "text": "Loop Quantization: an Analysis and Algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "This paper presents a general technique, loop quantization, for unwinding multiple nested loops, explains its advantages over other transformations, and illustrates its practical effectiveness."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1679622"
                        ],
                        "name": "L. Lamport",
                        "slug": "L.-Lamport",
                        "structuredName": {
                            "firstName": "Leslie",
                            "lastName": "Lamport",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Lamport"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7407863,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f8303a66826d531ec126d69cb3e4346d7d3aba68",
            "isKey": false,
            "numCitedBy": 707,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "Methods are developed for the parallel execution of different iterations of a DO loop. Both asynchronous multiprocessor computers and array computers are considered. Practical application to the design of compilers for such computers is discussed."
            },
            "slug": "The-parallel-execution-of-DO-loops-Lamport",
            "title": {
                "fragments": [],
                "text": "The parallel execution of DO loops"
            },
            "tldr": {
                "abstractSimilarityScore": 72,
                "text": "Methods are developed for the parallel execution of different iterations of a DO loop and practical application to the design of compilers for such computers is discussed."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1974
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2616848"
                        ],
                        "name": "D. Loveman",
                        "slug": "D.-Loveman",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Loveman",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Loveman"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 2756671,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bda9524ad65e656c839570f42effd59f92f206d6",
            "isKey": false,
            "numCitedBy": 240,
            "numCiting": 101,
            "paperAbstract": {
                "fragments": [],
                "text": "The use of source-to-source program transformations has proved valuable in improving program performance. The concept of program manipulation is elucidated by describing its role in both conventional optimization and high level modification of conditional, looping, and procedure structures. An example program fragment written in an Algol-like language is greatly improved by transformations enabled by a user-provided assertion about a data array. A compilation model based on the use of source-to-source program transformations is used to provide a framework for discussing issues of code generation, compilation of high level languages such as APL, and eliminating overhead commonly associated with modular structured programming. Application of the compilation model to several different languages is discussed."
            },
            "slug": "Program-Improvement-by-Source-to-Source-Loveman",
            "title": {
                "fragments": [],
                "text": "Program Improvement by Source-to-Source Transformation"
            },
            "tldr": {
                "abstractSimilarityScore": 50,
                "text": "A compilation model based on the use of source-to-source program transformations is used to provide a framework for discussing issues of code generation, compilation of high level languages such as APL, and eliminating overhead commonly associated with modular structured programming."
            },
            "venue": {
                "fragments": [],
                "text": "J. ACM"
            },
            "year": 1977
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1686222"
                        ],
                        "name": "K. Gallivan",
                        "slug": "K.-Gallivan",
                        "structuredName": {
                            "firstName": "Kyle",
                            "lastName": "Gallivan",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Gallivan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1704285"
                        ],
                        "name": "W. Jalby",
                        "slug": "W.-Jalby",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Jalby",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Jalby"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143692736"
                        ],
                        "name": "Dennis Gannon",
                        "slug": "Dennis-Gannon",
                        "structuredName": {
                            "firstName": "Dennis",
                            "lastName": "Gannon",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dennis Gannon"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 361555,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e53e83c8ca855978cedb882c044573f1d368675e",
            "isKey": false,
            "numCitedBy": 95,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "Parallel supercomputers architectures with complex memory hierarchies or distributed memory systems have become very common. Unfortunately, the problems associated with restructuring software to take advantage of these memory systems are not easily solved. This paper presents an overview of some of the mathematical issues behind several of these problems and attempts to give a brief look at some of the potential solutions."
            },
            "slug": "On-the-problem-of-optimizing-data-transfers-for-Gallivan-Jalby",
            "title": {
                "fragments": [],
                "text": "On the problem of optimizing data transfers for complex memory systems"
            },
            "tldr": {
                "abstractSimilarityScore": 53,
                "text": "An overview of some of the mathematical issues behind several of the problems associated with restructuring software to take advantage of parallel supercomputers architectures with complex memory hierarchies or distributed memory systems is presented."
            },
            "venue": {
                "fragments": [],
                "text": "ICS '88"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47546648"
                        ],
                        "name": "R. Karp",
                        "slug": "R.-Karp",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Karp",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Karp"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1400120462"
                        ],
                        "name": "Raymond E. Miller",
                        "slug": "Raymond-E.-Miller",
                        "structuredName": {
                            "firstName": "Raymond E.",
                            "lastName": "Miller",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Raymond E. Miller"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1690630"
                        ],
                        "name": "S. Winograd",
                        "slug": "S.-Winograd",
                        "structuredName": {
                            "firstName": "Shmuel",
                            "lastName": "Winograd",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Winograd"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16568434,
            "fieldsOfStudy": [
                "Physics"
            ],
            "id": "acbd0d8557edad81f05b7098a5500937725acefb",
            "isKey": false,
            "numCitedBy": 636,
            "numCiting": 13,
            "paperAbstract": {
                "fragments": [],
                "text": "A set equations in the quantities <italic>a<subscrpt>i</subscrpt></italic>(<italic>p</italic>), where <italic>i</italic> = 1, 2, \u00b7 \u00b7 \u00b7, <italic>m</italic> and <italic>p</italic> ranges over a set <italic>R</italic> of lattice points in <italic>n</italic>-space, is called a <italic>system of uniform recurrence equations</italic> if the following property holds: If <italic>p</italic> and <italic>q</italic> are in <italic>R</italic> and <italic>w</italic> is an integer <italic>n</italic>-vector, then <italic>a<subscrpt>i</subscrpt></italic>(<italic>p</italic>) depends directly on <italic>a<subscrpt>j</subscrpt></italic>(<italic>p</italic> - <italic>w</italic>) if and only if <italic>a<subscrpt>i</subscrpt></italic>(<italic>q</italic>) depends directly on <italic>a<subscrpt>j</subscrpt></italic>(<italic>q</italic> - <italic>w</italic>). Finite-difference approximations to systems of partial differential equations typically lead to such recurrence equations. The structure of such a system is specified by a <italic>dependence graph G</italic> having <italic>m</italic> vertices, in which the directed edges are labeled with integer <italic>n</italic>-vectors. For certain choices of the set <italic>R</italic>, necessary and sufficient conditions on <italic>G</italic> are given for the existence of a schedule to compute all the quantities <italic>a<subscrpt>i</subscrpt></italic>(<italic>p</italic>) explicitly from their defining equations. Properties of such schedules, such as the degree to which computation can proceed \u201cin parallel,\u201d are characterized. These characterizations depend on a certain iterative decomposition of a dependence graph into subgraphs. Analogous results concerning implicit schedules are also given."
            },
            "slug": "The-Organization-of-Computations-for-Uniform-Karp-Miller",
            "title": {
                "fragments": [],
                "text": "The Organization of Computations for Uniform Recurrence Equations"
            },
            "venue": {
                "fragments": [],
                "text": "JACM"
            },
            "year": 1967
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1729097"
                        ],
                        "name": "D. Padua",
                        "slug": "D.-Padua",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Padua",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Padua"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50073003"
                        ],
                        "name": "M. Wolfe",
                        "slug": "M.-Wolfe",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolfe",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wolfe"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 16351316,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4a7bbb5718449555f63eb45a1ab2c71fd212a75c",
            "isKey": false,
            "numCitedBy": 769,
            "numCiting": 67,
            "paperAbstract": {
                "fragments": [],
                "text": "Compilers for vector or multiprocessor computers must have certain optimization features to successfully generate parallel code."
            },
            "slug": "Advanced-compiler-optimizations-for-supercomputers-Padua-Wolfe",
            "title": {
                "fragments": [],
                "text": "Advanced compiler optimizations for supercomputers"
            },
            "tldr": {
                "abstractSimilarityScore": 87,
                "text": "Compilers for vector or multiprocessor computers must have certain optimization features to successfully generate parallel code to be able to operate on parallel systems."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145811910"
                        ],
                        "name": "U. Banerjee",
                        "slug": "U.-Banerjee",
                        "structuredName": {
                            "firstName": "Utpal",
                            "lastName": "Banerjee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "U. Banerjee"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 60826239,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "fe31e7959a578ebe57069807d38dc5f478f0f2e1",
            "isKey": false,
            "numCitedBy": 63,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "A-theory-of-loop-permutations-Banerjee",
            "title": {
                "fragments": [],
                "text": "A theory of loop permutations"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69569592"
                        ],
                        "name": "David Alejandro Padua Haiek",
                        "slug": "David-Alejandro-Padua-Haiek",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Haiek",
                            "middleNames": [
                                "Alejandro",
                                "Padua"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David Alejandro Padua Haiek"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 59854856,
            "fieldsOfStudy": [
                "Geology"
            ],
            "id": "660ac8c91f3a436220040661d4edbd8e9e692a17",
            "isKey": false,
            "numCitedBy": 96,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Multiprocessors:-discussion-of-some-theoretical-and-Haiek",
            "title": {
                "fragments": [],
                "text": "Multiprocessors: discussion of some theoretical and practical problems"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1980
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144005858"
                        ],
                        "name": "W. Shang",
                        "slug": "W.-Shang",
                        "structuredName": {
                            "firstName": "Weijia",
                            "lastName": "Shang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Shang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144371682"
                        ],
                        "name": "J. Fortes",
                        "slug": "J.-Fortes",
                        "structuredName": {
                            "firstName": "Jos\u00e9",
                            "lastName": "Fortes",
                            "middleNames": [
                                "A.",
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Fortes"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 34675788,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f8b4decd893bd745d32a9a116c5a65855464fb79",
            "isKey": false,
            "numCitedBy": 20,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Independent-Partitioning-of-Algorithms-With-Uniform-Shang-Fortes",
            "title": {
                "fragments": [],
                "text": "Independent Partitioning of Algorithms With Uniform Data Dependencies"
            },
            "venue": {
                "fragments": [],
                "text": "ICPP"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50073003"
                        ],
                        "name": "M. Wolfe",
                        "slug": "M.-Wolfe",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolfe",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wolfe"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 26424998,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "aa10d5e48f5a835a2458699af3c6911129064fbe",
            "isKey": false,
            "numCitedBy": 239,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Iteration-Space-Tiling-for-Memory-Hierarchies-Wolfe",
            "title": {
                "fragments": [],
                "text": "Iteration Space Tiling for Memory Hierarchies"
            },
            "venue": {
                "fragments": [],
                "text": "PPSC"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144297516"
                        ],
                        "name": "John R. Allen",
                        "slug": "John-R.-Allen",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Allen",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 53236484,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f3d2ab514353cb80c2ea6504f05374d4549b26c6",
            "isKey": false,
            "numCitedBy": 130,
            "numCiting": 13,
            "paperAbstract": {
                "fragments": [],
                "text": "Parallel and vector machines are becoming increasingly important to many computation intensive applications. Effectively utilizing such architectures, particularly from sequential languages such as Fortran, has demanded increasingly sophisticated compilers. In general, a compiler needs to significantly reorder a program in order to generate code optimal for a specific architecture.Because DO loops typically control the execution of a number of statements, the order in which loops are executed can dramatically affect the performance of a machine on a particular section of code. In particular, loop interchange can often be used to enhance the performance of code on parallel or vector machines.Determining when loops may be safely and profitably interchanged requires a study of the data dependences in the program. This work discusses specific applications of that theory to loop interchange. This theory is described as it has been implemented in PFC (Parallel Fortran Converter) -- a program which attempts to uncover operations in sequential Fortran code that may be safely rewritten as vector operations."
            },
            "slug": "Automatic-loop-interchange-Allen-Kennedy",
            "title": {
                "fragments": [],
                "text": "Automatic loop interchange"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Specific applications of that theory to loop interchange are discussed as it has been implemented in PFC (Parallel Fortran Converter) -- a program which attempts to uncover operations in sequential Fortran code that may be safely rewritten as vector operations."
            },
            "venue": {
                "fragments": [],
                "text": "SIGPLAN '84"
            },
            "year": 1984
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "More Itemtion Space Tiling, Supercomputing 89"
            },
            "venue": {
                "fragments": [],
                "text": "More Itemtion Space Tiling, Supercomputing 89"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Progmm Improvement by Source-to- Source Transformations"
            },
            "venue": {
                "fragments": [],
                "text": "J. of the ACM"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Dependence Approximation and Global Pamllel Code Genemtion for Nested Loope, In- ternational Workshop on Parallel and Distributed Al- gorithms, Bonae, Ott. 3-6"
            },
            "venue": {
                "fragments": [],
                "text": "Overview of the PIPS project, International Workshop on Compilers for Parallel Computers"
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "11-iolet, Supernode Partitioning"
            },
            "venue": {
                "fragments": [],
                "text": "ACM Symposium on Principles of Prograrnmin g Languages"
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Pamllel Ezecution of DO Loops, Com- munications of the"
            },
            "venue": {
                "fragments": [],
                "text": "ACM"
            },
            "year": 1974
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Advanced Compiler Opti- mization for Supereomputers"
            },
            "venue": {
                "fragments": [],
                "text": "Commum \" cations of the ACM"
            },
            "year": 1986
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Program Partitioning and Synchronization on Multiprocessors Systems, Ph.D. Thesis, report UIUCDCS-R-86-1259, University of Illinois at Urbana- Champaign"
            },
            "venue": {
                "fragments": [],
                "text": "Software Methods for Improvement of cache Performance on Superwmputer Applications, Rice COMP TR89-93"
            },
            "year": 1986
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Optimizing Supercompilera for Supercomputers"
            },
            "venue": {
                "fragments": [],
                "text": "Optimizing Supercompilera for Supercomputers"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Optimal Tiling for Itemtive PDE Solvers, Frontiers of Massively Parallel Computation"
            },
            "venue": {
                "fragments": [],
                "text": "Optimal Tiling for Itemtive PDE Solvers, Frontiers of Massively Parallel Computation"
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Organization of Computation for Uniform Recurence Equations"
            },
            "venue": {
                "fragments": [],
                "text": "Journal of the ACM"
            },
            "year": 1967
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Loop Skewing: The Wavefront Method Revi.% ited, Int'1 Journal of Parallel Progr amming"
            },
            "venue": {
                "fragments": [],
                "text": "Loop Skewing: The Wavefront Method Revi.% ited, Int'1 Journal of Parallel Progr amming"
            },
            "year": 1986
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Itemtion Space Tiling for Memory Eierarchiea"
            },
            "venue": {
                "fragments": [],
                "text": "Pardel processing for Scientific Computing, G. Rodrigue (cd.), SIAM"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Multiproceasora: Discue8ion of Some Theoretical and Practical Problems"
            },
            "venue": {
                "fragments": [],
                "text": "Multiproceasora: Discue8ion of Some Theoretical and Practical Problems"
            },
            "year": 1979
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {},
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 32,
        "totalPages": 4
    },
    "page_url": "https://www.semanticscholar.org/paper/Scanning-polyhedra-with-DO-loops-Ancourt-Irigoin/6f4f362af709c2890db6c6f920d0b565c91b4521?sort=total-citations"
}