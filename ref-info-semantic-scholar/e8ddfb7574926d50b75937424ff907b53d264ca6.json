{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2070633788"
                        ],
                        "name": "Richard M. Russell",
                        "slug": "Richard-M.-Russell",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Russell",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Richard M. Russell"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "On the Cray-1, for example, the crossover point for choosing vector over scalar processing is between 2 and 4 elements [30]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 28752186,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f2b3410db51e7b3d36ddbf14916a674eaef2267a",
            "isKey": false,
            "numCitedBy": 685,
            "numCiting": 6,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes the CRAY-1, discusses the evolution of its architecture, and gives an account of some of the problems that were overcome during its manufacture.\nThe CRAY-1 is the only computer to have been built to date that satisfies ERDA's Class VI requirement (a computer capable of processing from 20 to 60 million floating point operations per second) [1].\nThe CRAY-1's Fortran compiler (CFT) is designed to give the scientific user immediate access to the benefits of the CRAY-1's vector processing architecture. An optimizing compiler, CFT, \u201cvectorizes\u201d innermost DO loops. Compatible with the ANSI 1966 Fortran Standard and with many commonly supported Fortran extensions, CFT does not require any source program modifications or the use of additional nonstandard Fortran statements to achieve vectorization. Thus the user's investment of hundreds of man months of effort to develop Fortran programs for other contemporary computers is protected."
            },
            "slug": "The-CRAY-1-computer-system-Russell",
            "title": {
                "fragments": [],
                "text": "The CRAY-1 computer system"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "The CRAY-1 is the only computer to have been built to date that satisfies ERDA's Class VI requirement (a computer capable of processing from 20 to 60 million floating point operations per second) and its Fortran compiler (CFT) is designed to give the scientific user immediate access to the benefits of the Cray-1's vector processing architecture."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "11150119"
                        ],
                        "name": "Dorothy Wedel",
                        "slug": "Dorothy-Wedel",
                        "structuredName": {
                            "firstName": "Dorothy",
                            "lastName": "Wedel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dorothy Wedel"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 17044873,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6dfaf3fb91e1a8745e79790428b184f789f83ee0",
            "isKey": false,
            "numCitedBy": 32,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": "The ASC Fortran compiler and the methods of optimizing the execution times of compiled programs are described. Language extensions and compiler organization are briefly outlined. Traditional scalar optimization techniques and techniques to detect and generate vector operations from ANS standard Fortran source code are discussed. Emphasis is placed on optimal generation of vector operations and parallel processing. The vector and parallel processing techniques described here are applicable to a wide variety of vector or parallel processing machines. Numerous examples are discussed to demonstrate many of the capabilities and features of the compiler."
            },
            "slug": "Fortran-for-the-Texas-Instruments-ASC-system-Wedel",
            "title": {
                "fragments": [],
                "text": "Fortran for the Texas Instruments ASC system"
            },
            "tldr": {
                "abstractSimilarityScore": 75,
                "text": "The ASC Fortran compiler and the methods of optimizing the execution times of compiled programs are described, with emphasis on optimal generation of vector operations and parallel processing."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1975
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144297516"
                        ],
                        "name": "John R. Allen",
                        "slug": "John-R.-Allen",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Allen",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John R. Allen"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "These ideas are more fully developed elsewhere [4]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Furthermore, this method can be generalized to allow successive interchanges betweeen loops, or to test for interchanges between arbitrary (not necessarily consecutive) loops [4]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 59085567,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "837593a996c0875e58e5266cf51410e5b72bab65",
            "isKey": false,
            "numCitedBy": 202,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "The order in which the statements of a program are executed can affect the execution time of the program. Optimizing compilers have made use of this fact by reordering code to improve its performance on a machine. Some statement orderings are essential to a program's results, however; these orderings form the basis of a dependence relation among the statements of a program. \nDependences can arise in two separate ways within a program: from data considerations, and from control considerations. However, since all control dependences can be converted to data dependences by guarding statements with precise conditions that control their execution, data dependence is the more general concept. \nData dependences within loops can arise from two separate effects. The position of statements within the loops may cause a dependence, or iteration of a specific loop may cause a dependence. Characterizing dependence in this manner provides the foundation of extremely effective algorithms for reordering transformations. One very important reordering transformation which is made possible by dependence is vectorization. \nVectorization of a program can often be enchanced by loop interchange. Dependence plays an important role in determining when loops should be interchanged. Interchange preventing dependences inhibit a particular interchange; interchange sensitive dependences may make an interchange less profitable in terms of increased vectorization. \nDependence for symbolic subscripts is an extremely difficult problem. Nevertheless, some cases can be handled by techniques based on standard dependence tests. \nOne last reordering transformation which is of extreme importance on vector machines is sectioning, or devectorization. Dependence not only determines when a statement can be correctly sectioned but it also can be used to improve the register performance of a sectioned statement."
            },
            "slug": "Dependence-analysis-for-subscripted-variables-and-Allen",
            "title": {
                "fragments": [],
                "text": "Dependence analysis for subscripted variables and its application to program transformations"
            },
            "tldr": {
                "abstractSimilarityScore": 89,
                "text": "The order in which the statements of a program are executed can affect the execution time of the program, and this fact has made use of this fact by reordering code to improve its performance on a machine."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1983
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144297516"
                        ],
                        "name": "John R. Allen",
                        "slug": "John-R.-Allen",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Allen",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "146417166"
                        ],
                        "name": "Carrie Porterfield",
                        "slug": "Carrie-Porterfield",
                        "structuredName": {
                            "firstName": "Carrie",
                            "lastName": "Porterfield",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Carrie Porterfield"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3036988"
                        ],
                        "name": "J. Warren",
                        "slug": "J.-Warren",
                        "structuredName": {
                            "firstName": "Joe",
                            "lastName": "Warren",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Warren"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "The process of converting control dependences into data dependences is known as IF conversion [ 3 ]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 39279813,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6c5462d31a0d0f4e6cb2ff7ae795250957d9fcab",
            "isKey": false,
            "numCitedBy": 613,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "Program analysis methods, especially those which support automatic vectorization, are based on the concept of interstatement dependence where a dependence holds between two statements when one of the statements computes values needed by the other. Powerful program transformation systems that convert sequential programs to a form more suitable for vector or parallel machines have been developed using this concept [AllK 82, KKLW 80].The dependence analysis in these systems is based on data dependence. In the presence of complex control flow, data dependence is not sufficient to transform programs because of the introduction of control dependences. A control dependence exists between two statements when the execution of one statement can prevent the execution of the other. Control dependences do not fit conveniently into dependence-based program translators.One solution is to convert all control dependences to data dependences by eliminating goto statements and introducing logical variables to control the execution of statements in the program. In this scheme, action statements are converted to IF statements. The variables in the conditional expression of an IF statement can be viewed as inputs to the statement being controlled. The result is that control dependences between statements become explicit data dependences expressed through the definitions and uses of the controlling logical variables.This paper presents a method for systematically converting control dependences to data dependences in this fashion. The algorithms presented here have been implemented in PFC, an experimental vectorizer written at Rice University."
            },
            "slug": "Conversion-of-control-dependence-to-data-dependence-Allen-Kennedy",
            "title": {
                "fragments": [],
                "text": "Conversion of control dependence to data dependence"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This paper presents a method for systematically converting control dependences to data dependences in this fashion by eliminating goto statements and introducing logical variables to control the execution of statements in the program."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '83"
            },
            "year": 1983
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1739086"
                        ],
                        "name": "D. Kuck",
                        "slug": "D.-Kuck",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Kuck",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Kuck"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 16264855,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b7851e77829b5cebd63d5c4d7e8bf7ba1349f178",
            "isKey": false,
            "numCitedBy": 217,
            "numCiting": 105,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper is a survey of parallel machine organizations and programming. Parallelism is defined in a broad sense, on the bit level, operation level, and algorithm level. A number of abstract and practical questions are discussed. First, fast techniques for evaluating arithmetic expressions and linear recurrences a r e treated. Next, whole programs are discussed, and some experimental results a r e presented. Finally, various aspects of machine organization are discussed, including processors, memories, and alignment networks."
            },
            "slug": "A-Survey-of-Parallel-Machine-Organization-and-Kuck",
            "title": {
                "fragments": [],
                "text": "A Survey of Parallel Machine Organization and Programming"
            },
            "tldr": {
                "abstractSimilarityScore": 63,
                "text": "This paper is a survey of parallel machine organizations and programming, and various aspects of machine organization are discussed, including processors, memories, and alignment networks."
            },
            "venue": {
                "fragments": [],
                "text": "CSUR"
            },
            "year": 1977
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1739086"
                        ],
                        "name": "D. Kuck",
                        "slug": "D.-Kuck",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Kuck",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Kuck"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2094177"
                        ],
                        "name": "R. Kuhn",
                        "slug": "R.-Kuhn",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Kuhn",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kuhn"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1729097"
                        ],
                        "name": "D. Padua",
                        "slug": "D.-Padua",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Padua",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Padua"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3306526"
                        ],
                        "name": "B. Leasure",
                        "slug": "B.-Leasure",
                        "structuredName": {
                            "firstName": "Bruce",
                            "lastName": "Leasure",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Leasure"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50073003"
                        ],
                        "name": "M. Wolfe",
                        "slug": "M.-Wolfe",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolfe",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wolfe"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 10114479,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6eef174cc4f7ac5e30cf478334ac6bb3db31fe48",
            "isKey": false,
            "numCitedBy": 704,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "Dependence graphs can be used as a vehicle for formulating and implementing compiler optimizations. This paper defines such graphs and discusses two kinds of transformations. The first are simple rewriting transformations that remove dependence arcs. The second are abstraction transformations that deal more globally with a dependence graph. These transformations have been implemented and applied to several different types of high-speed architectures."
            },
            "slug": "Dependence-graphs-and-compiler-optimizations-Kuck-Kuhn",
            "title": {
                "fragments": [],
                "text": "Dependence graphs and compiler optimizations"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "This paper defines such graphs and discusses two kinds of transformations, simple rewriting transformations that remove dependence arcs and abstraction transformations that deal more globally with a dependence graph."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '81"
            },
            "year": 1981
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717349"
                        ],
                        "name": "D. Knuth",
                        "slug": "D.-Knuth",
                        "structuredName": {
                            "firstName": "Donald",
                            "lastName": "Knuth",
                            "middleNames": [
                                "Ervin"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Knuth"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 65140997,
            "fieldsOfStudy": [
                "Engineering",
                "Physics"
            ],
            "id": "748f27587c37d8b0882a20692967901b81429fce",
            "isKey": false,
            "numCitedBy": 11601,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "A fuel pin hold-down and spacing apparatus for use in nuclear reactors is disclosed. Fuel pins forming a hexagonal array are spaced apart from each other and held-down at their lower end, securely attached at two places along their length to one of a plurality of vertically disposed parallel plates arranged in horizontally spaced rows. These plates are in turn spaced apart from each other and held together by a combination of spacing and fastening means. The arrangement of this invention provides a strong vibration free hold-down mechanism while avoiding a large pressure drop to the flow of coolant fluid. This apparatus is particularly useful in connection with liquid cooled reactors such as liquid metal cooled fast breeder reactors."
            },
            "slug": "The-Art-of-Computer-Programming-Knuth",
            "title": {
                "fragments": [],
                "text": "The Art of Computer Programming"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "The arrangement of this invention provides a strong vibration free hold-down mechanism while avoiding a large pressure drop to the flow of coolant fluid."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1968
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1715952"
                        ],
                        "name": "A. Aho",
                        "slug": "A.-Aho",
                        "structuredName": {
                            "firstName": "Alfred",
                            "lastName": "Aho",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Aho"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706504"
                        ],
                        "name": "J. Hopcroft",
                        "slug": "J.-Hopcroft",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Hopcroft",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Hopcroft"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1742391"
                        ],
                        "name": "J. Ullman",
                        "slug": "J.-Ullman",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Ullman",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ullman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 29599075,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "10a463bb00b44bdd3a8620f2bedb9e1564bfcf32",
            "isKey": false,
            "numCitedBy": 9260,
            "numCiting": 138,
            "paperAbstract": {
                "fragments": [],
                "text": "From the Publisher: \nWith this text, you gain an understanding of the fundamental concepts of algorithms, the very heart of computer science. It introduces the basic data structures and programming techniques often used in efficient algorithms. Covers use of lists, push-down stacks, queues, trees, and graphs. Later chapters go into sorting, searching and graphing algorithms, the string-matching algorithms, and the Schonhage-Strassen integer-multiplication algorithm. Provides numerous graded exercises at the end of each chapter. \n \n \n0201000296B04062001"
            },
            "slug": "The-Design-and-Analysis-of-Computer-Algorithms-Aho-Hopcroft",
            "title": {
                "fragments": [],
                "text": "The Design and Analysis of Computer Algorithms"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This text introduces the basic data structures and programming techniques often used in efficient algorithms, and covers use of lists, push-down stacks, queues, trees, and graphs."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1974
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1768678"
                        ],
                        "name": "E. McCluskey",
                        "slug": "E.-McCluskey",
                        "structuredName": {
                            "firstName": "Edward",
                            "lastName": "McCluskey",
                            "middleNames": [
                                "Joseph"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. McCluskey"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 109163394,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1880688f5f3b031aebe4ea5c9108aa643d2a5c70",
            "isKey": false,
            "numCitedBy": 845,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "A systematic procedure is presented for writing a Boolean function as a minimum sum of products. This procedure is a simplification and extension of the method presented by W. V. Quine. Specific attention is given to terms which can be included in the function solely for the designer's convenience."
            },
            "slug": "Minimization-of-Boolean-functions-McCluskey",
            "title": {
                "fragments": [],
                "text": "Minimization of Boolean functions"
            },
            "tldr": {
                "abstractSimilarityScore": 68,
                "text": "A systematic procedure is presented for writing a Boolean function as a minimum sum of products and specific attention is given to terms which can be included in the function solely for the designer's convenience."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1956
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1721050"
                        ],
                        "name": "R. Tarjan",
                        "slug": "R.-Tarjan",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Tarjan",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Tarjan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 208,
                                "start": 204
                            }
                        ],
                        "text": "see this, observe that the computation consists of three components: (1) identification of maximal strongly connected regions-this can be done by using Tarjan\u2019s depth-first search method in O(m f n) time [31], (2) topological sorting of the n-blocks to determine the order of code generationthis will require O(m + n) time [ 161, (3) the code generation for-loop, which takes at most O(n) time, since we are ignoring the time spent in the recursive calls to codegen."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 16467262,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "385742fffcf113656f0d3cf6c06ef95cb8439dc6",
            "isKey": false,
            "numCitedBy": 6206,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "The value of depth-first search or \u201cbacktracking\u201d as a technique for solving problems is illustrated by two examples. An improved version of an algorithm for finding the strongly connected components of a directed graph and at algorithm for finding the biconnected components of an undirect graph are presented. The space and time requirements of both algorithms are bounded by $k_1 V + k_2 E + k_3 $ for some constants $k_1 ,k_2 $, and $k_3 $, where V is the number of vertices and E is the number of edges of the graph being examined."
            },
            "slug": "Depth-First-Search-and-Linear-Graph-Algorithms-Tarjan",
            "title": {
                "fragments": [],
                "text": "Depth-First Search and Linear Graph Algorithms"
            },
            "tldr": {
                "abstractSimilarityScore": 99,
                "text": "The value of depth-first search or \u201cbacktracking\u201d as a technique for solving problems is illustrated by two examples of an improved version of an algorithm for finding the strongly connected components of a directed graph."
            },
            "venue": {
                "fragments": [],
                "text": "SIAM J. Comput."
            },
            "year": 1972
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144716964"
                        ],
                        "name": "J. Cocke",
                        "slug": "J.-Cocke",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Cocke",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Cocke"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 1092505,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "84bdb440504732f38cf08a996c808156cd504e32",
            "isKey": false,
            "numCitedBy": 104,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "A simple algorithm which uses an indexed temporary table to perform reduction of operator strength in strongly connected regions is presented. Several extensions, including linear function test replacement, are discussed. These algorithms should fit well into an integrated package of local optimization algorithms."
            },
            "slug": "An-algorithm-for-reduction-of-operator-strength-Cocke-Kennedy",
            "title": {
                "fragments": [],
                "text": "An algorithm for reduction of operator strength"
            },
            "tldr": {
                "abstractSimilarityScore": 98,
                "text": "A simple algorithm which uses an indexed temporary table to perform reduction of operator strength in strongly connected regions is presented and several extensions, including linear function test replacement, are discussed."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1977
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145260350"
                        ],
                        "name": "W. Quine",
                        "slug": "W.-Quine",
                        "structuredName": {
                            "firstName": "W.",
                            "lastName": "Quine",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Quine"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 124965557,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "9f5d77fe735b272c77c7ca53285dd9c8c526d635",
            "isKey": false,
            "numCitedBy": 863,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "(1952). The Problem of Simplifying Truth Functions. The American Mathematical Monthly: Vol. 59, No. 8, pp. 521-531."
            },
            "slug": "The-Problem-of-Simplifying-Truth-Functions-Quine",
            "title": {
                "fragments": [],
                "text": "The Problem of Simplifying Truth Functions"
            },
            "tldr": {
                "abstractSimilarityScore": 56,
                "text": "The Problem of Simplifying Truth Functions is concerned with the problem of reducing the number of operations on a graph to a simple number."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1952
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 63,
                                "start": 59
                            }
                        ],
                        "text": "This transformation, called induction uaridde substitution [36], replaces statements that increment auxiliary induction variables with statements that compute them directly using normal loop induction variables and loop constants."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 157,
                                "start": 152
                            }
                        ],
                        "text": "BRl(l:N)) A(l:N) = B(l:N) + 3\nThe process of expanding scalars into arrays for vectorization is known as scalar expansion and is described in detail by Wolfe [36]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 54
                            }
                        ],
                        "text": "The observation depicted in Figure 12 is due to Wolfe [36]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 148,
                                "start": 143
                            }
                        ],
                        "text": "Much of the early development was based upon the ideas of David Kuck and his group, illuminated in discussions with Utpal Banerjee and Michael Wolfe."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 132,
                                "start": 128
                            }
                        ],
                        "text": "The process of expanding scalars into arrays for vectorization is known as scalar expansion and is described in detail by Wolfe [36]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Techniques for improving the inherent parallelism in programs"
            },
            "venue": {
                "fragments": [],
                "text": "Techniques for improving the inherent parallelism in programs"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 28,
                                "start": 20
                            }
                        ],
                        "text": "Since this test and Banerjee\u2019s inequality are similar, testing an edge to determine whether it is interchange preventing can easily accomplished at the time of normal dependence testing."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 477,
                                "start": 469
                            }
                        ],
                        "text": "If f(xl, . . . , X,,) = & + C& &Xi and g(Xl, . . . , X4) = b0 + CZl bixi and S1 and S2 are of the form\n4: X( f (x1, . . . , x,,)) = F(. . .)\nS2: A = G(Xgh . . . , x,)))\nand are contained in n common loops, n L k, and the upper bounds of the loops surrounding Sl are Mi and the upper bounds of the loops surrounding 5\u20192 are Ni (Mi = Ni for i I n), then S1 & S2 only if\n(a) gcd test:\ngcdh - bl, a2 - b2, . . . , ah-1 - bk-1, ak, . . . , a,,, bk, . . . , b,) I bo - a0\n(b) Banerjee inequality:\n--bk - IzI (ai - bi)-(Ni - 1) - (u; + bk)+(Nk - 2)\n- ;=F+, aT(Mi - 1) - 2 bt(Ni - 1) i=k+l\nI 2 bi - z CZj i"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 25,
                                "start": 17
                            }
                        ],
                        "text": "The gcd test and Banerjee\u2019s inequality can be modified to test for loop independent dependences as follows."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 72,
                                "start": 64
                            }
                        ],
                        "text": "Alternatively, 7O,(S,, Sz) is the maximum value of Nk for which Banerjee\u2019s inequality does not hold."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 51,
                                "start": 43
                            }
                        ],
                        "text": "One obvious technique would be to evaluate Banerjee\u2019s inequality symbolically as far as possible."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 53,
                                "start": 45
                            }
                        ],
                        "text": "This theorem is an adaptation of a result by Banerjee."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 130,
                                "start": 122
                            }
                        ],
                        "text": "Much of the early development was based upon the ideas of David Kuck and his group, illuminated in discussions with Utpal Banerjee and Michael Wolfe."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 85
                            }
                        ],
                        "text": "Since loop interchange corresponds to a switch of two terms in the dependence tests, Banerjee\u2019s inequality and the gcd test can be easily modified to detect interchange sensitive edges."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 116,
                                "start": 108
                            }
                        ],
                        "text": "If they are, then compute a,,, bO, al, and bl. (2) If either (a) gcd(al, bl) does not divide b0 - a0 or (b) Banerjee\u2019s inequality does not hold, then the statement does not depend upon itself."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 429,
                                "start": 421
                            }
                        ],
                        "text": "& bixi, and S1 and Sz are of the form\nSl: X(f(xl, . . . , x,,)) = F(. . .) &: A = G(Xkh . . . , +J)\nand are contained in n common loops (assumed normalized), n r k, and the upper bounds of the loops surrounding S1 are Mi and the upper bounds of the loops surrounding Sz are Ni (M; = Ni for i 5 n), then S1 & Sz only if\n(a) gcd test:\ngcdbl - h, a2 - b2, . . . , ak-1 - bk-1, ak, . . . , a,,, bk, . . . , b,) 1 bo - a0\n(b) Banerjee inequality: k-l\n-bk - zl (ai - bi)-(Ni - 1) - (a; + bk)+(Nk - 2)\n- i$, af(M - 1) - i=!+l b:(Ni - 1)\n5 ,,zo bi - a80 ai\nb-1\nC --bk + E (ai - bi)+(Ni - 1) + (ai - bk)+(Nk - 2) - i=l\n+ is!+l at(Mi - 1) + 5 b;(Ni - 1). i=k+l\nThe long but straightforward proof is given in the Appendix."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 54,
                                "start": 46
                            }
                        ],
                        "text": "The gcd test has been slightly sharpened over Banerjee\u2019s and the test has been formulated as a test for dependence with respect to a specific carrier k.\nACM Transactions on Programming Languages end Systems, Vol. 9, No. 4, October 1987."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 550,
                                "start": 542
                            }
                        ],
                        "text": "Iff&, . . . , x,,) = h + C& aixi, g(q, . . . , LX+,) = bo + CC, bixi, and S1 and S2 are of the form\nSl: X(f(xl, . . . , x,,)) = F(. . .)\nSz: A = G(XMa, . . . , x,)))\nand are contained in n common loops (assumed normalized), and the upper bounds of the loops surrounding S1 are Mi and the upper bounds of the loops surrounding 5\u20192 are Ni (Mi = Ni for i I n), then S1 6, Sz(& has a loop independent dependence on &) only if S2 follows & and\n(a) gcd test:\ngcd(al - bl, a2 - by, . . . , a, - b,, a,+~, . . . , a,,, b,+~, . . . , b,) I bo - a0\n(b) Banerjee inequality:\n-il (ai - bi)-(Ni - 1) - 3 a;(Mi - 1) - z bT(Ni - 1) i=n+l i=n+l\n5 2 bi - 2 ai i"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 90,
                                "start": 87
                            }
                        ],
                        "text": "Such a way is provided by the following theorem, adapted from a result due to Banerjee [6]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 160,
                                "start": 152
                            }
                        ],
                        "text": "The direct threshold of this dependence, written ~z(S\u2019i, S,), is one less than the minimum value of Nk (the loop upper bound for the tzth loop) at which Banerjee\u2019s inequality still holds."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 239,
                                "start": 231
                            }
                        ],
                        "text": "=O i=l\n- bk - (a; - bk)+(Nk - 2) - 2 a;(IVi - 1) - z bt(IVi - 1). i=k+l i=k+l\nBy subtracting x& oi - Czo bi from both sides of each inequality in min h I 0 I max h, we see that there is a real solution of h = 0 in R if and only if Banerjee\u2019s inequality holds."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 131,
                                "start": 123
                            }
                        ],
                        "text": "Determining whether a threshold is a constant threshold, a crossing threshold, or neither can be easily accomplished using Banerjee\u2019s inequality."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Data dependence in ordinary programs"
            },
            "venue": {
                "fragments": [],
                "text": "Data dependence in ordinary programs"
            },
            "year": 1976
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 165,
                                "start": 158
                            }
                        ],
                        "text": "In fact, it seems clear that the next ANSI standard for FORTRAN, which we shall refer to as FORTRAN 8x, will contain explicit vector operations like those in VECTRAN [5, 261."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 26,
                                "start": 19
                            }
                        ],
                        "text": "An Introduction to VECTRAN and its use in scientific applications programming."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 15,
                                "start": 8
                            }
                        ],
                        "text": "VECTRAN [27,28] is one of the earliest and most influential of such proposals, although there have been numerous others [7, 12, 341."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 11,
                                "start": 4
                            }
                        ],
                        "text": "The VECTRAN language: An experimental language for vector/ matrix array processing."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The VECTRAN language: An experimental language for vector/ matrix array processing"
            },
            "venue": {
                "fragments": [],
                "text": "IBM Palo Alto Scientific Center Report G320-3334,"
            },
            "year": 1975
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 165,
                                "start": 158
                            }
                        ],
                        "text": "In fact, it seems clear that the next ANSI standard for FORTRAN, which we shall refer to as FORTRAN 8x, will contain explicit vector operations like those in VECTRAN [5, 261."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 26,
                                "start": 19
                            }
                        ],
                        "text": "An Introduction to VECTRAN and its use in scientific applications programming."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 15,
                                "start": 8
                            }
                        ],
                        "text": "VECTRAN [27,28] is one of the earliest and most influential of such proposals, although there have been numerous others [7, 12, 341."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 11,
                                "start": 4
                            }
                        ],
                        "text": "The VECTRAN language: An experimental language for vector/ matrix array processing."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "An Introduction to VECTRAN and its use in scientific applications programming"
            },
            "venue": {
                "fragments": [],
                "text": "In Proceedings of the LASL Workshop on Vector and Parallel Pro- cessors. (Los Alamos, N.M., Sept. 1978)"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 167,
                                "start": 161
                            }
                        ],
                        "text": "INTRODUCTION\nWith the advent of successful vector computers such as the Gay-1 [lo, 301 and the popularity of array processors such as the Floating Point Systems AP-120 [13,35], there has been increased interest in making vector operations available to the FORTRAN programmer."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 175,
                                "start": 168
                            }
                        ],
                        "text": "INTRODUCTION With the advent of successful vector computers such as the Gay-1 [lo, 301 and the popularity of array processors such as the Floating Point Systems AP-120 [13,35], there has been increased interest in making vector operations available to the FORTRAN programmer."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 35,
                                "start": 29
                            }
                        ],
                        "text": "Floating Point Systems, Inc. AP-120 Programmers Reference Manual."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Array processor provides high throughput rates"
            },
            "venue": {
                "fragments": [],
                "text": "Comput. Design (March"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 62,
                                "start": 58
                            }
                        ],
                        "text": "This procedure, also known as the \u201cnode splitting\u201d method [19], should be considered cautiously in light of the increased storage required for temporary arrays."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 41,
                                "start": 37
                            }
                        ],
                        "text": "technical grounds by array expansion [19] or by clever renaming."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[19] becomes a special case of true dependence."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Compiler transfor- mation of dependence graphs"
            },
            "venue": {
                "fragments": [],
                "text": "In Conference Record of the Eighth ACM Symposium on Principles of Programming Languages (Williamsburg,"
            },
            "year": 1981
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "32100541"
                        ],
                        "name": "R. A. Towle",
                        "slug": "R.-A.-Towle",
                        "structuredName": {
                            "firstName": "Ross",
                            "lastName": "Towle",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. A. Towle"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 118122359,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9a1fc6dee625cf629bb85169aadd9b619b80c255",
            "isKey": false,
            "numCitedBy": 83,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Control-and-data-dependence-for-program-Towle",
            "title": {
                "fragments": [],
                "text": "Control and data dependence for program transformations."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1976
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717349"
                        ],
                        "name": "D. Knuth",
                        "slug": "D.-Knuth",
                        "structuredName": {
                            "firstName": "Donald",
                            "lastName": "Knuth",
                            "middleNames": [
                                "Ervin"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Knuth"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 207926480,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2e75bbb14bd35affb79e5a6e9cc832a21d54f2e2",
            "isKey": false,
            "numCitedBy": 1657,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "The-art-of-computer-programming:-V.1.:-Fundamental-Knuth",
            "title": {
                "fragments": [],
                "text": "The art of computer programming: V.1.: Fundamental algorithms"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1726805"
                        ],
                        "name": "Y. Muraoka",
                        "slug": "Y.-Muraoka",
                        "structuredName": {
                            "firstName": "Yoichi",
                            "lastName": "Muraoka",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Muraoka"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 60809044,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0cb0bbc2b135efeac687be20fd95914e600f0da5",
            "isKey": false,
            "numCitedBy": 122,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Parallelism-exposure-and-exploitation-in-programs-Muraoka",
            "title": {
                "fragments": [],
                "text": "Parallelism exposure and exploitation in programs"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1971
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69998330"
                        ],
                        "name": "D. L. Kuck",
                        "slug": "D.-L.-Kuck",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Kuck",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. L. Kuck"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 60827809,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e06ad6164946b5593727f43456b35e343d2c694e",
            "isKey": false,
            "numCitedBy": 533,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "The-Structure-of-Computers-and-Computations-Kuck",
            "title": {
                "fragments": [],
                "text": "The Structure of Computers and Computations"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1978
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1406453411"
                        ],
                        "name": "H. Griffin",
                        "slug": "H.-Griffin",
                        "structuredName": {
                            "firstName": "Harriet",
                            "lastName": "Griffin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Griffin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "A standard result from the theory of Diophantine equations [14] tells us this has a solution if and only if"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": ", [14]) will include the following theorem on Diophantine equations."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 123620118,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "f3c01e39fb3451fcaa17a2bc55988948a25bf349",
            "isKey": false,
            "numCitedBy": 47,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Elementary-theory-of-numbers-Griffin",
            "title": {
                "fragments": [],
                "text": "Elementary theory of numbers"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1954
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Reduction of operator strength"
            },
            "venue": {
                "fragments": [],
                "text": "Program Flow Analysis: Theory and Applications"
            },
            "year": 1981
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 219,
                                "start": 173
                            }
                        ],
                        "text": "In the example above, this approach results in the elimination of K from the inequality since\nb,,-a= K-K=O.\nSymbolic evaluation was used in the vectorizing compiler for the Texas Instruments Advanced Scientific Computer [9]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 115,
                                "start": 112
                            }
                        ],
                        "text": "Symbolic evaluation was used in the vectorizing compiler for the Texas Instruments Advanced Scientific Computer [9]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 90,
                                "start": 84
                            }
                        ],
                        "text": "Other projects that have influenced our work are the Texas Instruments ASC compiler [9,33], the Cray-1 FORTRAN compiler [15], and the Massachusetts Computer Associates Vectorizer [22, 251."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Vector optimization for the ASC"
            },
            "venue": {
                "fragments": [],
                "text": "In Proceedings of the Seventh Annual Princeton Conference on Information Sciences arm\u2019 Systems (Dept. of Electrical Engineering,"
            },
            "year": 1973
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 97,
                                "start": 94
                            }
                        ],
                        "text": "The process of converting control dependences into data dependences is known as IF conversion [3]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Conversion of control depen- dence to data dependence"
            },
            "venue": {
                "fragments": [],
                "text": "In Proceedings of the Tenth Annual ACM Symposium on Principles of Programming Languages (Austin,"
            },
            "year": 1983
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Compiler transformation of dependence graphs"
            },
            "venue": {
                "fragments": [],
                "text": "Conference Record of the Eighth ACM Symposium on Principles of Programming Languages"
            },
            "year": 1981
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Implementation of FORTRAN"
            },
            "venue": {
                "fragments": [],
                "text": "Burroughs Scientific Processor Bro- chure,"
            },
            "year": 1977
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Implementation of FORTRAN. Burroughs Scientific Processor Brochure"
            },
            "venue": {
                "fragments": [],
                "text": "Implementation of FORTRAN. Burroughs Scientific Processor Brochure"
            },
            "year": 1977
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Gray-l Computer System FORTRAN (CFT) Reference Manual"
            },
            "venue": {
                "fragments": [],
                "text": "Publication 2240009,"
            },
            "year": 1980
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Design and Andy& of Computer Algorithms"
            },
            "venue": {
                "fragments": [],
                "text": "ACM Transactions on Programming Languages and Systems,"
            },
            "year": 1974
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The structure of an advanced vectorizer for pipelined processors"
            },
            "venue": {
                "fragments": [],
                "text": "In Proceedings of the IEEE Computer Society Fourth Znter- national Computer Software and Applications Conference (Chicago,"
            },
            "year": 1980
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Proposals approved for Fortran 8x. X3J3/S6.80 (preliminary document)"
            },
            "venue": {
                "fragments": [],
                "text": "Proposals approved for Fortran 8x. X3J3/S6.80 (preliminary document)"
            },
            "year": 1981
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Floating Point Systems, Inc. AP-120 Programmers Reference Manual. Publication 860-7319- 000"
            },
            "venue": {
                "fragments": [],
                "text": "Floating Point Systems, Inc. AP-120 Programmers Reference Manual. Publication 860-7319- 000"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Vectorizer System: Current and proposed capabilities. Report CA-17809- 1511 Massachusetts Computer Associates, Inc"
            },
            "venue": {
                "fragments": [],
                "text": "The Vectorizer System: Current and proposed capabilities. Report CA-17809- 1511 Massachusetts Computer Associates, Inc"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Compiling serial languages for parallel machines Application of the Vectorizer for effective use of high-speed computers"
            },
            "venue": {
                "fragments": [],
                "text": "Urbana, Ill. 23. MCCLUSKEY, E. J. Minimization of Boolean functions. Bell System Tech. J"
            },
            "year": 1956
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Cray-1 Computer System Reference Manual. Publication 2240004"
            },
            "venue": {
                "fragments": [],
                "text": "Cray Research, Inc"
            },
            "year": 1976
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Array processing for FORTRAN"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1979
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Array processor provides high throughput rates"
            },
            "venue": {
                "fragments": [],
                "text": "Comput. Design"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Application of the Vectorizer for effective use of high-speed computers"
            },
            "venue": {
                "fragments": [],
                "text": "In High Speed Computer and Algorithm Organization,"
            },
            "year": 1977
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 124,
                                "start": 120
                            }
                        ],
                        "text": "Other projects that have influenced our work are the Texas Instruments ASC compiler [9,33], the Cray-1 FORTRAN compiler [15], and the Massachusetts Computer Associates Vectorizer [22, 251."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Vectorization and conversion of FORTRAN programs for the Cray-1 CFT compiler. Publication 2240207"
            },
            "venue": {
                "fragments": [],
                "text": "Cray Research Inc., Mendota Heights,"
            },
            "year": 1979
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "An Introduction to VECTRAN and its use in scientific applications programming University of California"
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the LASL Workshop on Vector and Parallel Processors . (Los Alamos"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Array processing for FORTRAN"
            },
            "venue": {
                "fragments": [],
                "text": "Array processing for FORTRAN"
            },
            "year": 1979
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The structure of an advanced vectorizer for pipelined processors"
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the IEEE Computer Society Fourth Znternational Computer Software and Applications Conference"
            },
            "year": 1980
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "ACM Transactions on Programming Languages and Systems"
            },
            "venue": {
                "fragments": [],
                "text": "ACM Transactions on Programming Languages and Systems"
            },
            "year": 1987
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Compiling serial languages for parallel machines"
            },
            "venue": {
                "fragments": [],
                "text": "Dept. of Computer Science,"
            },
            "year": 1976
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Vectorization and conversion of FORTRAN programs for the Cray-1 CFT compiler. Publication 2240207"
            },
            "venue": {
                "fragments": [],
                "text": "Vectorization and conversion of FORTRAN programs for the Cray-1 CFT compiler. Publication 2240207"
            },
            "year": 1979
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Vector optimization for the ASC"
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the Seventh Annual Princeton Conference on Information Sciences arm' Systems (Dept. of Electrical Engineering"
            },
            "year": 1973
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Design and Andy& of Computer Algorithms"
            },
            "venue": {
                "fragments": [],
                "text": "The Design and Andy& of Computer Algorithms"
            },
            "year": 1974
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "ACM Transactions on Programming Languages and Systems"
            },
            "venue": {
                "fragments": [],
                "text": "ACM Transactions on Programming Languages and Systems"
            },
            "year": 1981
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Reduction of operator strength"
            },
            "venue": {
                "fragments": [],
                "text": "In Program Flow Analysis: Theory and Applications,"
            },
            "year": 1981
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Vectorizer System: Current and proposed capabilities"
            },
            "venue": {
                "fragments": [],
                "text": "Report CA-17809-"
            },
            "year": 1978
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The VECTRAN language: An experimental language for vector/ matrix array processing"
            },
            "venue": {
                "fragments": [],
                "text": "The VECTRAN language: An experimental language for vector/ matrix array processing"
            },
            "year": 1975
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 6,
            "methodology": 9
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 53,
        "totalPages": 6
    },
    "page_url": "https://www.semanticscholar.org/paper/Automatic-translation-of-FORTRAN-programs-to-vector-Allen-Kennedy/e8ddfb7574926d50b75937424ff907b53d264ca6?sort=total-citations"
}