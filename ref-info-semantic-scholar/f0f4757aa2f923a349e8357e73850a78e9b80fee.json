{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751936"
                        ],
                        "name": "Uday Bondhugula",
                        "slug": "Uday-Bondhugula",
                        "structuredName": {
                            "firstName": "Uday",
                            "lastName": "Bondhugula",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Uday Bondhugula"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47800062"
                        ],
                        "name": "M. Baskaran",
                        "slug": "M.-Baskaran",
                        "structuredName": {
                            "firstName": "Muthu",
                            "lastName": "Baskaran",
                            "middleNames": [
                                "Manikandan"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Baskaran"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144497869"
                        ],
                        "name": "S. Krishnamoorthy",
                        "slug": "S.-Krishnamoorthy",
                        "structuredName": {
                            "firstName": "Sriram",
                            "lastName": "Krishnamoorthy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Krishnamoorthy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145981817"
                        ],
                        "name": "J. Ramanujam",
                        "slug": "J.-Ramanujam",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Ramanujam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ramanujam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1793925"
                        ],
                        "name": "A. Rountev",
                        "slug": "A.-Rountev",
                        "structuredName": {
                            "firstName": "Atanas",
                            "lastName": "Rountev",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Rountev"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293384"
                        ],
                        "name": "P. Sadayappan",
                        "slug": "P.-Sadayappan",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Sadayappan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Sadayappan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1415216,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "37a4cbe74b52643e3d7a62b201984f5ba15adcdc",
            "isKey": false,
            "numCitedBy": 227,
            "numCiting": 39,
            "paperAbstract": {
                "fragments": [],
                "text": "The polyhedral model provides powerful abstractions to optimize loop nests with regular accesses. Affine transformations in this model capture a complex sequence of execution-reordering loop transformations that can improve performance by parallelization as well as locality enhancement. Although a significant body of research has addressed affine scheduling and partitioning, the problem of automaticallyfinding good affine transforms forcommunication-optimized coarsegrained parallelization together with locality optimization for the general case of arbitrarily-nested loop sequences remains a challenging problem. \n \nWe propose an automatic transformation framework to optimize arbitrarilynested loop sequences with affine dependences for parallelism and locality simultaneously. The approach finds good tiling hyperplanes by embedding a powerful and versatile cost function into an Integer Linear Programming formulation. These tiling hyperplanes are used for communication-minimized coarse-grained parallelization as well as for locality optimization. The approach enables the minimization of inter-tile communication volume in the processor space, and minimization of reuse distances for local execution at each node. Programs requiring one-dimensional versusmulti-dimensional time schedules (with scheduling-based approaches) are all handled with the same algorithm. Synchronization-free parallelism, permutable loops or pipelined parallelismat various levels can be detected. Preliminary studies of the framework show promising results."
            },
            "slug": "Automatic-Transformations-for-Parallelization-and-Bondhugula-Baskaran",
            "title": {
                "fragments": [],
                "text": "Automatic Transformations for Communication-Minimized Parallelization and Locality Optimization in the Polyhedral Model"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This work proposes an automatic transformation framework to optimize arbitrarily-nested loop sequences with affine dependences for parallelism and locality simultaneously and finds good tiling hyperplanes by embedding a powerful and versatile cost function into an Integer Linear Programming formulation."
            },
            "venue": {
                "fragments": [],
                "text": "CC"
            },
            "year": 2008
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751936"
                        ],
                        "name": "Uday Bondhugula",
                        "slug": "Uday-Bondhugula",
                        "structuredName": {
                            "firstName": "Uday",
                            "lastName": "Bondhugula",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Uday Bondhugula"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47800062"
                        ],
                        "name": "M. Baskaran",
                        "slug": "M.-Baskaran",
                        "structuredName": {
                            "firstName": "Muthu",
                            "lastName": "Baskaran",
                            "middleNames": [
                                "Manikandan"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Baskaran"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144497869"
                        ],
                        "name": "S. Krishnamoorthy",
                        "slug": "S.-Krishnamoorthy",
                        "structuredName": {
                            "firstName": "Sriram",
                            "lastName": "Krishnamoorthy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Krishnamoorthy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145981817"
                        ],
                        "name": "J. Ramanujam",
                        "slug": "J.-Ramanujam",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Ramanujam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ramanujam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1793925"
                        ],
                        "name": "A. Rountev",
                        "slug": "A.-Rountev",
                        "structuredName": {
                            "firstName": "Atanas",
                            "lastName": "Rountev",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Rountev"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293384"
                        ],
                        "name": "P. Sadayappan",
                        "slug": "P.-Sadayappan",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Sadayappan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Sadayappan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 14385375,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "19f2b254ad2ab035540d394b25cf18c1c1ecd152",
            "isKey": false,
            "numCitedBy": 20,
            "numCiting": 58,
            "paperAbstract": {
                "fragments": [],
                "text": "A long running program often spends most of its time in nested loops. The polyhedral model provides powerful abstractions to optimize loop nests with regular accesses for parallel execution. Affine transformations in this model capture a complex sequence of execution-reordering loop transformations that improve performance by parallelization as well as better locality. Although a significant amount of research has addressed affine scheduling and partitioning, the problem of automatically finding good affine transforms for communication-optimized coarse-grained parallelization along with locality optimization for the general case of arbitrarily-nested loop sequences remains a challenging problem most frameworks do not treat parallelization and locality optimization in an integrated manner, and/or do not optimize across a sequence of producer-consumer loops. In this paper, we develop an approach to communication minimization and locality optimization in tiling of arbitrarily nested loop sequences with affine dependences. We address the minimization of inter-tile communication volume in the processor space, and minimization of reuse distances for local execution at each node. The approach can also fuse across a long sequence of loop nests that have a producer/consumer relationship. Programs requiring one-dimensional versus multi-dimensional time schedules are all handled with the same algorithm. Synchronization-free parallelism, permutable loops or pipelined parallelism, and inner parallel loops can be detected. Examples are provided that demonstrate the power of the framework. The algorithm has been incorporated into a tool chain to generate transformations from C/Fortran code in a fully automatic fashion."
            },
            "slug": "Affine-Transformations-for-Communication-Minimal-of-Bondhugula-Baskaran",
            "title": {
                "fragments": [],
                "text": "Affine Transformations for Communication Minimal Parallelization and Locality Optimization of Arbitrarily Nested Loop Sequences"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "An approach to communication minimization and locality optimization in tiling of arbitrarily nested loop sequences with affine dependences is developed and incorporated into a tool chain to generate transformations from C/Fortran code in a fully automatic fashion."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2007
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2506136"
                        ],
                        "name": "Sylvain Girbal",
                        "slug": "Sylvain-Girbal",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Girbal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Girbal"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1702824"
                        ],
                        "name": "David Parello",
                        "slug": "David-Parello",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Parello",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David Parello"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "18182536"
                        ],
                        "name": "Marc Sigler",
                        "slug": "Marc-Sigler",
                        "structuredName": {
                            "firstName": "Marc",
                            "lastName": "Sigler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Marc Sigler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1731764"
                        ],
                        "name": "O. Temam",
                        "slug": "O.-Temam",
                        "structuredName": {
                            "firstName": "Olivier",
                            "lastName": "Temam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Temam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 8182159,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cc1c1b1eb6e9672d1b2813ad763f701494d8fcee",
            "isKey": false,
            "numCitedBy": 240,
            "numCiting": 123,
            "paperAbstract": {
                "fragments": [],
                "text": "Modern compilers are responsible for translating the idealistic operational semantics of the source program into a form that makes efficient use of a highly complex heterogeneous machine. Since optimization problems are associated with huge and unstructured search spaces, this combinational task is poorly achieved in general, resulting in weak scalability and disappointing sustained performance. We address this challenge by working on the program representation itself, using a semi-automatic optimization approach to demonstrate that current compilers offen suffer from unnecessary constraints and intricacies that can be avoided in a semantically richer transformation framework. Technically, the purpose of this paper is threefold: (1) to show that syntactic code representations close to the operational semantics lead to rigid phase ordering and cumbersome expression of architecture-aware loop transformations, (2) to illustrate how complex transformation sequences may be needed to achieve significant performance benefits, (3) to facilitate the automatic search for program transformation sequences, improving on classical polyhedral representations to better support operation research strategies in a simpler, structured search space. The proposed framework relies on a unified polyhedral representation of loops and statements, using normalization rules to allow flexible and expressive transformation sequencing. Thisrepresentation allows to extend the scalability of polyhedral dependence analysis, and to delay the (automatic) legality checks until the end of a transformation sequence. Our work leverages on algorithmic advances in polyhedral code generation and has been implemented in a modern research compiler."
            },
            "slug": "Semi-Automatic-Composition-of-Loop-Transformations-Girbal-Vasilache",
            "title": {
                "fragments": [],
                "text": "Semi-Automatic Composition of Loop Transformations for Deep Parallelism and Memory Hierarchies"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This work leverages on algorithmic advances in polyhedral code generation and has been implemented in a modern research compiler, using a semi-automatic optimization approach to demonstrate that current compilers suffer from unnecessary constraints and intricacies that can be avoided in a semantically richer transformation framework."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 38,
                                "start": 34
                            }
                        ],
                        "text": "This is particularly common in sci\u00adenti.c and engineering applications."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 9474356,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e8a732e85540102732a0e729a26009891a7548b6",
            "isKey": false,
            "numCitedBy": 86,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "The polyhedral model is known to be a powerful framework to reason about high level loop transformations. Recent developments in optimizing compilers broke some generally accepted ideas about the limitations of this model. First, thanks to advances in dependence analysis for irregular access patterns, its applicability which was supposed to be limited to very simple loop nests has been extended to wide code regions. Then, new algorithms made it possible to compute the target code for hundreds of statements while this code generation step was expected not to be scalable. Such theoretical advances and new software tools allowed actors from both academia and industry to study more complex and realistic cases. Unfortunately, despite strong optimization potential of a given transformation for e.g., parallelism or data locality, code generation may still be challenging or result in high control overhead. This paper presents scalable code generation methods that make possible the application of increasingly complex program transformations. By studying the transformations themselves, we show how it is possible to benefit from their properties to dramatically improve both code generation quality and space/time complexity, with respect to the best state-of-the-art code generation tool. In addition, we build on these improvements to present a new algorithm improving generated code performance for strided domains and reindexed schedules."
            },
            "slug": "Polyhedral-Code-Generation-in-the-Real-World-Vasilache-Bastoul",
            "title": {
                "fragments": [],
                "text": "Polyhedral Code Generation in the Real World"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "By studying the transformations themselves, it is shown how it is possible to benefit from their properties to dramatically improve both code generation quality and space/time complexity, with respect to the best state-of-the-art code generation tool."
            },
            "venue": {
                "fragments": [],
                "text": "CC"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 28,
                                "start": 25
                            }
                        ],
                        "text": "This is particularly common in sci\u00adenti.c and engineering applications."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7971227,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d2f48fb9fd31390c56609f00510accf5c56f9f9b",
            "isKey": false,
            "numCitedBy": 518,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "Many advances in automatic parallelization and optimization have been achieved through the polyhedral model. It has been extensively shown that this computational model provides convenient abstractions to reason about and apply program transformations. Nevertheless, the complexity of code generation has long been a deterrent for using polyhedral representation in optimizing compilers. First, code generators have a hard time coping with generated code size and control overhead that may spoil theoretical benefits achieved by the transformations. Second, this step is usually time consuming, hampering the integration of the polyhedral framework in production compilers or feedback-directed, iterative optimization schemes. Moreover, current code generation algorithms only cover a restrictive set of possible transformation functions. This paper discusses a general transformation framework able to deal with nonunimodular, noninvertible, nonintegral or even nonuniform functions. It presents several improvements to a state-of-the-art code generation algorithm. Two directions are explored: generated code size and code generator efficiency. Experimental evidence proves the ability of the improved method to handle real-life problems."
            },
            "slug": "Code-generation-in-the-polyhedral-model-is-easier-Bastoul",
            "title": {
                "fragments": [],
                "text": "Code generation in the polyhedral model is easier than you think"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "A general transformation framework able to deal with nonunimodular, noninvertible, nonintegral or even nonuniform functions is discussed and several improvements to a state-of-the-art code generation algorithm are presented."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. 13th International Conference on Parallel Architecture and Compilation Techniques, 2004. PACT 2004."
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1793611"
                        ],
                        "name": "L. Pouchet",
                        "slug": "L.-Pouchet",
                        "structuredName": {
                            "firstName": "Louis-No\u00ebl",
                            "lastName": "Pouchet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Pouchet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6405506,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7a28813b890cf0e3064958fbbd82bba7414264ae",
            "isKey": false,
            "numCitedBy": 130,
            "numCiting": 66,
            "paperAbstract": {
                "fragments": [],
                "text": "Emerging microprocessors offer unprecedented parallel computing capabilities and deeper memory hierarchies, increasing the importance of loop transformations in optimizing compilers. Because compiler heuristics rely on simplistic performance models, and because they are bound to a limited set of transformations sequences, they only uncover a fraction of the peak performance on typical benchmarks. Iterative optimization is a maturing framework to address these limitations, but so far, it was not successfully applied complex loop transformation sequences because of the combinatorics of the optimization search space. We focus on the class of loop transformation which can be expressed as one-dimensional affine schedules. We define a systematic exploration method to enumerate the space of all legal, distinct transformations in this class. This method is based on an upstream characterization, as opposed to state-of-the-art downstream filtering approaches. Our results demonstrate orders of magnitude improvements in the size of the search space and in the convergence speed of a dedicated iterative optimization heuristic"
            },
            "slug": "Iterative-Optimization-in-the-Polyhedral-Model:-I,-Pouchet-Bastoul",
            "title": {
                "fragments": [],
                "text": "Iterative Optimization in the Polyhedral Model: Part I, One-Dimensional Time"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "This work defines a systematic exploration method to enumerate the space of all legal, distinct transformations in the class of loop transformation which can be expressed as one-dimensional affine schedules and demonstrates orders of magnitude improvements in the size of the search space and in the convergence speed of a dedicated iterative optimization heuristic."
            },
            "venue": {
                "fragments": [],
                "text": "International Symposium on Code Generation and Optimization (CGO'07)"
            },
            "year": 2007
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714483"
                        ],
                        "name": "C. Lengauer",
                        "slug": "C.-Lengauer",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Lengauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Lengauer"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6569614,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "60c854d27c9cf71a88a733acf190b9ff0fcb2872",
            "isKey": false,
            "numCitedBy": 264,
            "numCiting": 73,
            "paperAbstract": {
                "fragments": [],
                "text": "During the course of the last decade, a mathematical model for the parallelization of FOR-loops has become increasingly popular. In this model, a (perfect) nest of r FOR-loops is represented by a convex polytope in \u2124r. The boundaries of each loop specify the extent of the polytope in a distinct dimension. Various ways of slicing and segmenting the polytope yield a multitude of guaranteed correct mappings of the loops' operations in space-time. These transformations have a very intuitive interpretation and can be easily quantified and automated due to their mathematical foundation in linear programming and linear algebra. With the recent availability of massively parallel computers, the idea of loop parallelization is gaining significance, since it promises execution speed-ups of orders of magnitude. The polytope model for loop parallelization has its origin in systolic design, but it applies in more general settings and methods based on it will become a part of future parallelizing compilers. This paper provides an overview and future perspective of the polytope model and methods based on it."
            },
            "slug": "Loop-Parallelization-in-the-Polytope-Model-Lengauer",
            "title": {
                "fragments": [],
                "text": "Loop Parallelization in the Polytope Model"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The polytope model for loop parallelization has its origin in systolic design, but it applies in more general settings and methods based on it will become a part of future parallelizing compilers."
            },
            "venue": {
                "fragments": [],
                "text": "CONCUR"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1793611"
                        ],
                        "name": "L. Pouchet",
                        "slug": "L.-Pouchet",
                        "structuredName": {
                            "firstName": "Louis-No\u00ebl",
                            "lastName": "Pouchet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Pouchet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1874233"
                        ],
                        "name": "J. Cavazos",
                        "slug": "J.-Cavazos",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Cavazos",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Cavazos"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 42
                            }
                        ],
                        "text": "Several works are based on such schedules [7, 24, 14, 45, 44]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 79,
                                "start": 71
                            }
                        ],
                        "text": "A limitation of the recent iterative polyhedral compilation approaches [45, 44] is that the constructed search space does not include tiling and its integration poses a nontrivial challenge."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 152,
                                "start": 132
                            }
                        ],
                        "text": "In addition to model-based approaches, semi-automatic and search-based transformation frameworks in the polyhedral model also exist [30, 14, 22, 45, 44]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1296146,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "518d38f7ae0e734d0674a61427ccfb5bcbbc88b7",
            "isKey": false,
            "numCitedBy": 185,
            "numCiting": 59,
            "paperAbstract": {
                "fragments": [],
                "text": "High-level loop optimizations are necessary to achieve good performance over a wide variety of processors. Their performance impact can be significant because they involve in-depth program transformations that aim to sustain a balanced workload over the computational, storage, and communication resources of the target architecture. Therefore, it is mandatory that the compiler accurately models the target architecture as well as the effects of complex code restructuring.\n However, because optimizing compilers (1) use simplistic performance models that abstract away many of the complexities of modern architectures, (2) rely on inaccurate dependence analysis, and (3) lack frameworks to express complex interactions of transformation sequences, they typically uncover only a fraction of the peak performance available on many applications. We propose a complete iterative framework to address these issues. We rely on the polyhedral model to construct and traverse a large and expressive search space. This space encompasses only legal, distinct versions resulting from the restructuring of any static control loop nest. We first propose a feedback-driven iterative heuristic tailored to the search space properties of the polyhedral model. Though, it quickly converges to good solutions for small kernels, larger benchmarks containing higher dimensional spaces are more challenging and our heuristic misses opportunities for significant performance improvement. Thus, we introduce the use of a genetic algorithm with specialized operators that leverage the polyhedral representation of program dependences. We provide experimental evidence that the genetic algorithm effectively traverses huge optimization spaces, achieving good performance improvements on large loop nests."
            },
            "slug": "Iterative-optimization-in-the-polyhedral-model:-ii,-Pouchet-Bastoul",
            "title": {
                "fragments": [],
                "text": "Iterative optimization in the polyhedral model: part ii, multidimensional time"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A genetic algorithm with specialized operators that leverage the polyhedral representation of program dependences is introduced, providing experimental evidence that the genetic algorithm effectively traverses huge optimization spaces, achieving good performance improvements on large loop nests."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '08"
            },
            "year": 2008
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1704888"
                        ],
                        "name": "M. Griebl",
                        "slug": "M.-Griebl",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Griebl",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Griebl"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6053227,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "91e413ece54c911087295f1d9c06397e961e361f",
            "isKey": false,
            "numCitedBy": 138,
            "numCiting": 164,
            "paperAbstract": {
                "fragments": [],
                "text": "Parallel computers, especially in the form of clusters of standard PCs, have become reasonably cheap within the last few years. It is an obvious desire to use the increased computation power of such parallel hardware in order to speed up any given application. However, for that purpose, these application programs must be transformed such that they take benefit of the parallel hardware. One solution to generate the necessary parallel software is to use automatic parallelization, i.e., a parallelizing compiler. Such a tool takes a program in which nothing is specified about parallelism, and automatically transforms it to a parallel program. This idea allows to introduce parallelism easily, i.e., without much effort and, simultaneously, with guaranteed correctness with respect to the input program. This thesis presents a way to build up such a parallelizing compiler. In order to be efficient, we restrict ourselves to arbitrarily nested loops as the only control structure causing repeated computations. We apply a mathematical model, the polyhedron model, that gives a unified framework for the various parallelization tasks, and that allows a directed search for optimal solutions. We touch nearly every parallelization task and demonstrate the interactions between them. One of the main topics of this thesis is how to extract parallelism of the right granularity: too coarse-grained parallelism might not exploit the parallelism available from the hardware, and too fine-grained parallelism leads to increased overhead, especially to communication overhead. We shall derive a method that allows to precisely adapt the granularity to the given parallel architecture."
            },
            "slug": "Automatic-Parallelization-of-Loop-Programs-for-Griebl",
            "title": {
                "fragments": [],
                "text": "Automatic Parallelization of Loop Programs for Distributed Memory Architectures"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A mathematical model, the polyhedron model, is applied that gives a unified framework for the various parallelization tasks, and that allows a directed search for optimal solutions, to derive a method that allows to precisely adapt the granularity to the given parallel architecture."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2825685"
                        ],
                        "name": "G. Goumas",
                        "slug": "G.-Goumas",
                        "structuredName": {
                            "firstName": "Georgios",
                            "lastName": "Goumas",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Goumas"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2101333"
                        ],
                        "name": "Maria Athanasaki",
                        "slug": "Maria-Athanasaki",
                        "structuredName": {
                            "firstName": "Maria",
                            "lastName": "Athanasaki",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Maria Athanasaki"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1774783"
                        ],
                        "name": "N. Koziris",
                        "slug": "N.-Koziris",
                        "structuredName": {
                            "firstName": "Nectarios",
                            "lastName": "Koziris",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Koziris"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[23] reported an alternate tiled code generation scheme to Ancourt and Irigoin\u2019s [4]) to address the inefficiency involved in using Fourier-Motzkin elimination \u2013 however, this is no longer an issue as the state-of-the-art uses efficient algorithms [47, 6] based on PolyLib [57, 42] and its implementation of the Chernikova algorithm [33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 9708076,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c3173d58f65e99843077fbbc937b25745e12a91c",
            "isKey": false,
            "numCitedBy": 6,
            "numCiting": 27,
            "paperAbstract": {
                "fragments": [],
                "text": "Tiling or supernode transformation has been widely used to improve locality in multi-level memory hierarchies, as well as to efficiently execute loops onto parallel architectures. However, automatic code generation for tiled loops can be a very complex compiler work due to non-rectangular tile shapes and arbitrary iteration space bounds. In this paper, we first survey code generation methods for nested loops which are transformed using non-unimodular transformations. All methods are based on Fourier-Motzkin (FM) elimination. Next, we consider and enhance previous work on rewriting tiled loops by considering parallelepiped tiles and arbitrary iteration space shapes. In order to generate tiled code, all methods first enumerate the tiles containing points within the iteration space, and second, sweep the points within each tile. For the first, we extend previous work in order to access all tile origins correctly, while for the latter, we propose the transformation of the initial parallelepiped tile iteration space into a rectangular one, so as to generate code efficiently with the aid of a non-unimodular transformation matrix and its Hermite Normal Form (HNF). The resulting systems of inequalities are much simpler than those appeared in bibliography; thus their solutions are more efficiently determined using the FM elimination. Experimental results which compare all presented approaches, show that the proposed method for generating tiled code is significantly accelerated, thus rewriting any -D tiled loop in a much more efficient and direct way."
            },
            "slug": "Code-Generation-Methods-for-Tiling-Transformations-Goumas-Athanasaki",
            "title": {
                "fragments": [],
                "text": "Code Generation Methods for Tiling Transformations"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "Experimental results which compare all presented approaches, show that the proposed method for generating tiled code is significantly accelerated, thus rewriting any -D tiled loop in a much more efficient and direct way."
            },
            "venue": {
                "fragments": [],
                "text": "J. Inf. Sci. Eng."
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2115414533"
                        ],
                        "name": "Yonghong Song",
                        "slug": "Yonghong-Song",
                        "structuredName": {
                            "firstName": "Yonghong",
                            "lastName": "Song",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yonghong Song"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109822007"
                        ],
                        "name": "Zhiyuan Li",
                        "slug": "Zhiyuan-Li",
                        "structuredName": {
                            "firstName": "Zhiyuan",
                            "lastName": "Li",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Zhiyuan Li"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 31,
                                "start": 23
                            }
                        ],
                        "text": "Some specialized works [52, 62] also exist on tiling a restricted class of imperfectly nested loops for locality."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 15170626,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b2d8cf8baa5c78ab352dd78a9dd2fdaae621ef34",
            "isKey": false,
            "numCitedBy": 220,
            "numCiting": 33,
            "paperAbstract": {
                "fragments": [],
                "text": "Tiling is a well-known loop transformation to improve temporal locality of nested loops. Current compiler algorithms for tiling are limited to loops which are perfectly nested or can be transformed, in trivial ways, into a perfect nest. This paper presents a number of program transformations to enable tiling for a class of nontrivial imperfectly-nested loops such that cache locality is improved. We define a program model for such loops and develop compiler algorithms for their tiling. We propose to adopt odd-even variable duplication to break anti- and output dependences without unduly increasing the working-set size, and to adopt speculative execution to enable tiling of loops which may terminate prematurely due to, e.g. convergence tests in iterative algorithms. We have implemented these techniques in a research compiler, Panorama. Initial experiments with several benchmark programs are performed on SGI workstations based on MIPS R5K and R10K processors. Overall, the transformed programs run faster by 9% to 164%."
            },
            "slug": "New-tiling-techniques-to-improve-cache-temporal-Song-Li",
            "title": {
                "fragments": [],
                "text": "New tiling techniques to improve cache temporal locality"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "A number of program transformations to enable tiling for a class of nontrivial imperfectly-nested loops such that cache locality is improved and odd-even variable duplication to break anti- and output dependences without unduly increasing the working-set size are presented."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '99"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1687296"
                        ],
                        "name": "Karin H\u00f6gstedt",
                        "slug": "Karin-H\u00f6gstedt",
                        "structuredName": {
                            "firstName": "Karin",
                            "lastName": "H\u00f6gstedt",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Karin H\u00f6gstedt"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144852271"
                        ],
                        "name": "L. Carter",
                        "slug": "L.-Carter",
                        "structuredName": {
                            "firstName": "Larry",
                            "lastName": "Carter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Carter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144704592"
                        ],
                        "name": "J. Ferrante",
                        "slug": "J.-Ferrante",
                        "structuredName": {
                            "firstName": "Jeanne",
                            "lastName": "Ferrante",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ferrante"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 141
                            }
                        ],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14586943,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "23c678555bcd4780b6e83864d58d0216345e8c97",
            "isKey": false,
            "numCitedBy": 59,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "Many computationally-intensive programs, such as those for differential equations, spatial interpolation, and dynamic programming, spend a large portion of their execution time in multiply-nested loops which have a regular stencil of data dependences. Tiling is a well-known optimization that improves performance on such loops, particularly for computers with a multi-levelled hierarchy of parallelism and memory. Most previous work on tiling restricts the tile shape to be rectangular. Our previous work and its extension by Desprez, Dongarra, Rastello and Robert Showed that for doubly nested loops, using parallelograms can improve parallel execution time by decreasing the idle time, the time that a processor spends waiting for data or synchronization. In this technical report, we extend that work to more deeply nested loops, as well as to more complex loop bounds. We introduce a model which allows us to demonstrate the equivalence in complexity of linear programming and determining the execution time of a tiling in the model. We then identify a sub-class of these loops that constitute rectilinear iteration spaces for which we derive a closed form formula for their execution time. This formula can be used by a compiler to predict the execution tome of a loop nest. We then derive the tile shape that minimizes this formula. Using the duality property of linear programming, we also study how the longest path of dependent tiles within a rectilinear iteration space depends on the slope of only four of the facets defining the iteration space, independent of its dimensionality."
            },
            "slug": "Selecting-tile-shape-for-minimal-execution-time-H\u00f6gstedt-Carter",
            "title": {
                "fragments": [],
                "text": "Selecting tile shape for minimal execution time"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "A model which allows the equivalence in complexity of linear programming and determining the execution time of a tiling in the model is introduced, and how the longest path of dependent tiles within a rectilinear iteration space depends on the slope of only four of the facets defining the iteration space, independent of its dimensionality is studied."
            },
            "venue": {
                "fragments": [],
                "text": "SPAA '99"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "18182536"
                        ],
                        "name": "Marc Sigler",
                        "slug": "Marc-Sigler",
                        "structuredName": {
                            "firstName": "Marc",
                            "lastName": "Sigler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Marc Sigler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2506136"
                        ],
                        "name": "Sylvain Girbal",
                        "slug": "Sylvain-Girbal",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Girbal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Girbal"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1731764"
                        ],
                        "name": "O. Temam",
                        "slug": "O.-Temam",
                        "structuredName": {
                            "firstName": "Olivier",
                            "lastName": "Temam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Temam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1702824"
                        ],
                        "name": "David Parello",
                        "slug": "David-Parello",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Parello",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David Parello"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16965438,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "081fdf4787a2ec2cae16fa76a59c1747f4467e94",
            "isKey": false,
            "numCitedBy": 111,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": "Static compiler optimizations can hardly cope with the complex run-time behavior and hardware components interplay of modern processor architectures. Multiple architectural phenomena occur and interact simultaneously, which requires the optimizer to combine multiple program transformations. Whether these transformations are selected through static analysis and models, runtime feedback, or both, the underlying infrastructure must have the ability to perform long and complex compositions of program transformations in a flexible manner. Existing compilers are ill-equipped to perform that task because of rigid phase ordering, fragile selection rules using pattern matching, and cumbersome expression of loop transformations on syntax trees. Moreover, iterative optimization emerges as a pragmatic and general means to select an optimization strategy via machine learning and operations research. Searching for the composition of dozens of complex, dependent, parameterized transformations is a challenge for iterative approaches.The purpose of this article is threefold: (1) to facilitate the automatic search for compositions of program transformations, introducing a richer framework which improves on classical polyhedral representations, suitable for iterative optimization on a simpler, structured search space, (2) to illustrate, using several examples, that syntactic code representations close to the operational semantics hamper the composition of transformations, and (3) that complex compositions of transformations can be necessary to achieve significant performance benefits. The proposed framework relies on a unified polyhedral representation of loops and statements. The key is to clearly separate four types of actions associated with program transformations: iteration domain, schedule, data layout and memory access functions modifications. The framework is implemented within the Open64/ORC compiler, aiming for native IA64, AMD64 and IA32 code generation, along with source-to-source optimization of Fortran90, C and C++."
            },
            "slug": "Facilitating-the-search-for-compositions-of-program-Cohen-Sigler",
            "title": {
                "fragments": [],
                "text": "Facilitating the search for compositions of program transformations"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The purpose of this article is to facilitate the automatic search for compositions of program transformations, introducing a richer framework which improves on classical polyhedral representations, suitable for iterative optimization on a simpler, structured search space, and to illustrate that complex compositions of transformations can be necessary to achieve significant performance benefits."
            },
            "venue": {
                "fragments": [],
                "text": "ICS '05"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1704888"
                        ],
                        "name": "M. Griebl",
                        "slug": "M.-Griebl",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Griebl",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Griebl"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714483"
                        ],
                        "name": "C. Lengauer",
                        "slug": "C.-Lengauer",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Lengauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Lengauer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2168556886"
                        ],
                        "name": "Sabine Wetzel",
                        "slug": "Sabine-Wetzel",
                        "structuredName": {
                            "firstName": "Sabine",
                            "lastName": "Wetzel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sabine Wetzel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 143,
                                "start": 139
                            }
                        ],
                        "text": "Copyright c &#38;#169; 2008ACM \n978-1-59593-860-2/08/06... $5.00 J. Ramanujam2 P. Sadayappan1 2Dept.of Electrical&#38;Computer Engineering&#38;CCT \nLouisiana State University jxr@ece.lsu.edu Manycompute-intensive applications often spend most of their \nexecution time in nested loops."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6488833,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ff6dd16afedc0ac47f278b7b176aa013e1272613",
            "isKey": true,
            "numCitedBy": 71,
            "numCiting": 27,
            "paperAbstract": {
                "fragments": [],
                "text": "Automatic parallelization of nested loops, based on a mathematical model, the polytope model, has been improved significantly over the last decade: state-of-the-art methods allow flexible distributions of computations in space and time, which lead to high-quality parallelism. However, these methods have not found their way into practical parallelizing compilers due to the lack of code generation schemes which are able to deal with the new-found flexibility. To close this gap is the purpose of this paper."
            },
            "slug": "Code-generation-in-the-polytope-model-Griebl-Lengauer",
            "title": {
                "fragments": [],
                "text": "Code generation in the polytope model"
            },
            "tldr": {
                "abstractSimilarityScore": 48,
                "text": "This paper aims to close the gap between automatic parallelization of nested loops and practical parallelizing compilers due to the lack of code generation schemes which are able to deal with the new-found flexibility of the polytope model."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. 1998 International Conference on Parallel Architectures and Compilation Techniques (Cat. No.98EX192)"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49030677"
                        ],
                        "name": "Qing Yi",
                        "slug": "Qing-Yi",
                        "structuredName": {
                            "firstName": "Qing",
                            "lastName": "Yi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Qing Yi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 31,
                                "start": 23
                            }
                        ],
                        "text": "Some specialized works [52, 62] also exist on tiling a restricted class of imperfectly nested loops for locality."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 11817465,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4f07a44ddea3cea20a5ce1d4df90a58f8949d477",
            "isKey": false,
            "numCitedBy": 34,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": "Over the past 20 years, increases in processor speed have dramatically outstripped performance increases for standard memory chips. To bridge this gap, compilers must optimize applications so that data fetched into caches are reused before being displaced. Existing compiler techniques can efficiently optimize simple loop structures such as sequences of perfectly nested loops. However, on more complicated structures, existing techniques are either ineffective or require too much computation time to be practical for a commercial compiler. To optimize complex loop structures both effectively and inexpensively, we present a novel loop transformation, dependence hoisting, for optimizing arbitrarily nested loops, and an efficient framework that applies the new technique to aggressively optimize benchmarks for better locality. Our technique is as inexpensive as the traditional unimodular loop transformation techniques and thus can be incorporated into commercial compilers. In addition, it is highly effective and is able to block several linear algebra kernels containing highly challenging loop structures, in particular, Cholesky, QR, LU factorization without pivoting, and LU with partial pivoting. The automatic blocking of QR and pivoting LU is a notable achievement\u2014to our knowledge, few previous compiler techniques, including theoretically more general loop transformation frameworks [1, 21, 23, 27, 31], were able to completely automate the blocking of these kernels, and none has produced the same blocking as produced by our technique. These results indicate that with low compilation cost, our technique can in practice match the effectiveness of much more expensive frameworks that are theoretically more powerful."
            },
            "slug": "Transforming-Complex-Loop-Nests-for-Locality-Yi-Kennedy",
            "title": {
                "fragments": [],
                "text": "Transforming Complex Loop Nests for Locality"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This work presents a novel loop transformation, dependence hoisting, for optimizing arbitrarily nested loops, and an efficient framework that applies the new technique to aggressively optimize benchmarks for better locality."
            },
            "venue": {
                "fragments": [],
                "text": "The Journal of Supercomputing"
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2209910"
                        ],
                        "name": "DaeGon Kim",
                        "slug": "DaeGon-Kim",
                        "structuredName": {
                            "firstName": "DaeGon",
                            "lastName": "Kim",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "DaeGon Kim"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2341687"
                        ],
                        "name": "Lakshminarayanan Renganarayanan",
                        "slug": "Lakshminarayanan-Renganarayanan",
                        "structuredName": {
                            "firstName": "Lakshminarayanan",
                            "lastName": "Renganarayanan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lakshminarayanan Renganarayanan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48806702"
                        ],
                        "name": "D. Rostron",
                        "slug": "D.-Rostron",
                        "structuredName": {
                            "firstName": "D",
                            "lastName": "Rostron",
                            "middleNames": [
                                "W"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Rostron"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747659"
                        ],
                        "name": "S. Rajopadhye",
                        "slug": "S.-Rajopadhye",
                        "structuredName": {
                            "firstName": "Sanjay",
                            "lastName": "Rajopadhye",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Rajopadhye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709408"
                        ],
                        "name": "M. Strout",
                        "slug": "M.-Strout",
                        "structuredName": {
                            "firstName": "Michelle",
                            "lastName": "Strout",
                            "middleNames": [
                                "Mills"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Strout"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Techniques for parametric tiled code generation [49,  32 ] were recently proposed for single statement domains for which rectangular tiling is valid."
                    },
                    "intents": []
                }
            ],
            "corpusId": 17216889,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2f48eff3c71f9cb0d6992b0d0547372d446e639f",
            "isKey": false,
            "numCitedBy": 79,
            "numCiting": 38,
            "paperAbstract": {
                "fragments": [],
                "text": "Tiling is a widely used loop transformation for exposing/exploiting parallelism and data locality. High-performance implementations use multiple levels of tiling to exploit the hierarchy of parallelism and cache/register locality. Efficient generation of multi-level tiled code is essential for effective use of multi-level tiling. Parameterized tiled code, where tile sizes are not fixed but left as symbolic parameters can enable several dynamic and run-time optimizations. Previous solutions to multi-level tiled loop generation are limited to the case where tile sizes are fixed at compile time. We present an algorithm that can generate multi-level parameterized tiled loops at the same cost as generating single-level tiled loops. The efficiency of our method is demonstrated on several benchmarks. We also present a method-useful in register tiling-for separating partial and full tiles at any arbitrary level of tiling. The code generator we have implemented is available as an open source tool."
            },
            "slug": "Multi-level-tiling:-M-for-the-price-of-one-Kim-Renganarayanan",
            "title": {
                "fragments": [],
                "text": "Multi-level tiling: M for the price of one"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This work presents an algorithm that can generate multi-level parameterized tiled loops at the same cost as generating single-level tiling loops and presents a method-useful in register tiling-for separating partial and full tiles at any arbitrary level of tiling."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 2007 ACM/IEEE Conference on Supercomputing (SC '07)"
            },
            "year": 2007
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2506136"
                        ],
                        "name": "Sylvain Girbal",
                        "slug": "Sylvain-Girbal",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Girbal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Girbal"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 33,
                                "start": 29
                            }
                        ],
                        "text": "This is particularly common in sci\u00adenti.c and engineering applications."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14048366,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b8462344da2c018d385845d837d01035b05fae1e",
            "isKey": false,
            "numCitedBy": 44,
            "numCiting": 46,
            "paperAbstract": {
                "fragments": [],
                "text": "The polyhedral model is a powerful framework to reason about high level loop transformations. Yet the lack of scalable algorithms and tools has deterred actors from both academia and industry to put this model to practical use. Indeed, for fundamental complexity reasons, its applicability has long been limited to simple kernels. Recent developments broke some generally accepted ideas about these limitations. In particular, new algorithms made it possible to compute the target code for full SPEC benchmarks while this code generation step was expected not to be scalable.Instancewise array dependence analysis computes a finite, intensional representation of the (statically unbounded) set of all dynamic dependences. This problem has always been considered non-scalable and/or an overkill with respect to less expressive and faster dependence tests. On the contrary, this article presents experimental evidence of its applicability to full SPEC CPU2000 benchmarks. To make this possible, we revisit the characterization of data dependences, considering relations between time dimensions of the transformed space. Beyond algorithmic benefits, this naturally leads to a novel way of reasoning about violated dependences across arbitrary transformation sequences. Reasoning about violated dependences relieves the compiler designer from the cumbersome task of implementing specific legality checks for each single transformation. It also allows, in the case of invalid transformations, to precisely determine the violated dependences that need to be corrected. Identifying these violations can in turn enable automatic correction schemes to fix an illegal transformation sequence with minimal changes."
            },
            "slug": "Violated-dependence-analysis-Vasilache-Bastoul",
            "title": {
                "fragments": [],
                "text": "Violated dependence analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Experimental evidence of the applicability of the polyhedral model to full SPEC CPU2000 benchmarks is presented, and the characterization of data dependences is revisited, considering relations between time dimensions of the transformed space."
            },
            "venue": {
                "fragments": [],
                "text": "ICS '06"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2341687"
                        ],
                        "name": "Lakshminarayanan Renganarayanan",
                        "slug": "Lakshminarayanan-Renganarayanan",
                        "structuredName": {
                            "firstName": "Lakshminarayanan",
                            "lastName": "Renganarayanan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lakshminarayanan Renganarayanan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2209910"
                        ],
                        "name": "DaeGon Kim",
                        "slug": "DaeGon-Kim",
                        "structuredName": {
                            "firstName": "DaeGon",
                            "lastName": "Kim",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "DaeGon Kim"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747659"
                        ],
                        "name": "S. Rajopadhye",
                        "slug": "S.-Rajopadhye",
                        "structuredName": {
                            "firstName": "Sanjay",
                            "lastName": "Rajopadhye",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Rajopadhye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709408"
                        ],
                        "name": "M. Strout",
                        "slug": "M.-Strout",
                        "structuredName": {
                            "firstName": "Michelle",
                            "lastName": "Strout",
                            "middleNames": [
                                "Mills"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Strout"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Techniques for parametric tiled code generation [49, 32] were recently proposed for single statement domains for which rectangular tiling is valid."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 513727,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e52672b9c05cd7870fef0a87512b7c388ebe40c5",
            "isKey": false,
            "numCitedBy": 96,
            "numCiting": 50,
            "paperAbstract": {
                "fragments": [],
                "text": "Parameterized tiled loops-where the tile sizes are not fixed at compile time, but remain symbolic parameters until later--are quite useful for iterative compilers and \"auto-tuners\" that produce highly optimized libraries and codes. Tile size parameterization could also enable optimizations such as register tiling to become dynamic optimizations. Although it is easy to generate such loops for (hyper) rectangular iteration spaces tiled with (hyper) rectangular tiles, many important computations do not fall into this restricted domain. Parameterized tile code generation for the general case of convex iteration spaces being tiled by (hyper) rectangular tiles has in the past been solved with bounding box approaches or symbolic Fourier Motzkin approaches. However, both approaches have less than ideal code generation efficiency and resulting code quality. We present the theoretical foundations, implementation, and experimental validation of a simple, unified technique for generating parameterized tiled code. Our code generation efficiency is comparable to all existing code generation techniques including those for fixed tile sizes, and the resulting code is as efficient as, if not more than, all previous techniques. Thus the technique provides parameterized tiled loops for free! Our \"one-size-fits-all\" solution, which is available as open source software can be adapted for use in production compilers."
            },
            "slug": "Parameterized-tiled-loops-for-free-Renganarayanan-Kim",
            "title": {
                "fragments": [],
                "text": "Parameterized tiled loops for free"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The theoretical foundations, implementation, and experimental validation of a simple, unified technique for generating parameterized tiled code that is comparable to all existing code generation techniques including those for fixed tile sizes are presented and the resulting code is as efficient as, if not more than, all previous techniques."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '07"
            },
            "year": 2007
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2020735"
                        ],
                        "name": "Fabien Quiller\u00e9",
                        "slug": "Fabien-Quiller\u00e9",
                        "structuredName": {
                            "firstName": "Fabien",
                            "lastName": "Quiller\u00e9",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Fabien Quiller\u00e9"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747659"
                        ],
                        "name": "S. Rajopadhye",
                        "slug": "S.-Rajopadhye",
                        "structuredName": {
                            "firstName": "Sanjay",
                            "lastName": "Rajopadhye",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Rajopadhye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143860773"
                        ],
                        "name": "D. Wilde",
                        "slug": "D.-Wilde",
                        "structuredName": {
                            "firstName": "Doran",
                            "lastName": "Wilde",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Wilde"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 24,
                                "start": 20
                            }
                        ],
                        "text": "This is particularly common in sci\u00adenti.c and engineering applications."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14709233,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d56126a645271da916ad339df27a2bac1b75d320",
            "isKey": false,
            "numCitedBy": 206,
            "numCiting": 75,
            "paperAbstract": {
                "fragments": [],
                "text": "Automatic parallelization in the polyhedral model is based on affine transformations from an original computation domain (iteration space) to a target space-time domain, often with a different transformation for each variable. Code generation is an often ignored step in this process that has a significant impact on the quality of the final code. It involves making a trade-off between code size and control code simplification/optimization. Previous methods of doing code generation are based on loop splitting, however they have nonoptimal behavior when working on parameterized programs. We present a general parameterized method for code generation based on dual representation of polyhedra. Our algorithm uses a simple recursion on the dimensions of the domains, and enables fine control over the tradeoff between code size and control overhead."
            },
            "slug": "Generation-of-Efficient-Nested-Loops-from-Polyhedra-Quiller\u00e9-Rajopadhye",
            "title": {
                "fragments": [],
                "text": "Generation of Efficient Nested Loops from Polyhedra"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This work presents a general parameterized method for code generation based on dual representation of polyhedra that uses a simple recursion on the dimensions of the domains, and enables fine control over the tradeoff between code size and control overhead."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1987955"
                        ],
                        "name": "Nawaaz Ahmed",
                        "slug": "Nawaaz-Ahmed",
                        "structuredName": {
                            "firstName": "Nawaaz",
                            "lastName": "Ahmed",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nawaaz Ahmed"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144827979"
                        ],
                        "name": "N. Mateev",
                        "slug": "N.-Mateev",
                        "structuredName": {
                            "firstName": "Nikolay",
                            "lastName": "Mateev",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Mateev"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1776186"
                        ],
                        "name": "K. Pingali",
                        "slug": "K.-Pingali",
                        "structuredName": {
                            "firstName": "Keshav",
                            "lastName": "Pingali",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Pingali"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2845533,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "db5911eecf93c3be2f3554b7bdc240c2220c54aa",
            "isKey": false,
            "numCitedBy": 77,
            "numCiting": 113,
            "paperAbstract": {
                "fragments": [],
                "text": "Linear loop transformations and tiling are known to be very effective for enhancing locality of reference in perfectly-nested loops. However, they cannot be applied directly to imperfectly-nested loops. Some compilers attempt to convert imperfectly-nested loops into perfectly-nested loops by using statement sinking, loop fusion, etc., and then apply locality enhancing transformations to the resulting perfectly-nested loops, but the approaches used are fairly ad hoc and may fail even for simple programs. In this paper, we present a systematic approach for synthesizing transformations to enhance locality in imperfectly-nested loops. The key idea is to embed the iteration space of each statement into a special iteration space called the product space. The product space can be viewed as a perfectly-nested loop nest, so embedding generalizes techniques like statement sinking and loop fusion which are used in ad hoc ways in current compilers to produce perfectly-nested loops from imperfectly-nested ones. In contrast to these ad hoc techniques however, our embeddings are chosen carefully to enhance locality. The product space can itself be transformed to increase locality further, after which fully permutable loops can be tiled. The final code generation step may produce imperfectly-nested loops as output if that is desirable. We present experimental evidence for the effectiveness of this approach, using dense numerical linear algebra benchmarks, relaxation codes, and the tomcatv code from the SPEC benchmarks."
            },
            "slug": "Synthesizing-Transformations-for-Locality-of-Loop-Ahmed-Mateev",
            "title": {
                "fragments": [],
                "text": "Synthesizing Transformations for Locality Enhancement of Imperfectly-Nested Loop Nests"
            },
            "tldr": {
                "abstractSimilarityScore": 51,
                "text": "This paper presents a systematic approach for synthesizing transformations to enhance locality in imperfectly-nested loops by embedding the iteration space of each statement into a special iteration space called the product space, which generalizes techniques like statement sinking and loop fusion used in ad hoc ways in current compilers."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "10214063"
                        ],
                        "name": "M. E. Wolf",
                        "slug": "M.-E.-Wolf",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolf",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. E. Wolf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 39618367,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5d80427dd880159b32cb3a84942ed132debd1df3",
            "isKey": false,
            "numCitedBy": 749,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "An approach to transformations for general loops in which dependence vectors represent precedence constraints on the iterations of a loop is presented. Therefore, dependences extracted from a loop nest must be lexicographically positive. This leads to a simple test for legality of compound transformations: any code transformation that leaves the dependences lexicographically positive is legal. The loop transformation theory is applied to the problem of maximizing the degree of coarse- or fine-grain parallelism in a loop nest. It is shown that the maximum degree of parallelism can be achieved by transforming the loops into a nest of coarsest fully permutable loop nests and wavefronting the fully permutable nests. The canonical form of coarsest fully permutable nests can be transformed mechanically to yield maximum degrees of coarse- and/or fine-grain parallelism. The efficient heuristics can find the maximum degrees of parallelism for loops whose nesting level is less than five. >"
            },
            "slug": "A-Loop-Transformation-Theory-and-an-Algorithm-to-Wolf-Lam",
            "title": {
                "fragments": [],
                "text": "A Loop Transformation Theory and an Algorithm to Maximize Parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The loop transformation theory is applied to the problem of maximizing the degree of coarse- or fine-grain parallelism in a loop nest and it is shown that the maximum degree of parallelism can be achieved by transforming the loops into a nest of coarsest fullypermutable loop nests and wavefronting the fully permutable nests."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Parallel Distributed Syst."
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "10214063"
                        ],
                        "name": "M. E. Wolf",
                        "slug": "M.-E.-Wolf",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolf",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. E. Wolf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Tiling [28, 58, 61] is a key transformation in optimizing for parallelism and data locality."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Iteration space tiling [28, 58, 48, 61] is a standard approach for aggregating a set of loop iterations into tiles, with each tile being executed atomically."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 52798160,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f4dff66ba8f2338d118f379f2eff1410feb57ce6",
            "isKey": false,
            "numCitedBy": 1199,
            "numCiting": 40,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper proposes an algorithm that improves the locality of a loop nest by transforming the code via interchange, reversal, skewing and tiling. The loop transformation algorithm is based on two concepts: a mathematical formulation of reuse and locality, and a loop transformation theory that unifies the various transforms as unimodular matrix transformations.The algorithm has been implemented in the SUIF (Stanford University Intermediate Format) compiler, and is successful in optimizing codes such as matrix multiplication, successive over-relaxation (SOR), LU decomposition without pivoting, and Givens QR factorization. Performance evaluation indicates that locality optimization is especially crucial for scaling up the performance of parallel code."
            },
            "slug": "A-data-locality-optimizing-algorithm-Wolf-Lam",
            "title": {
                "fragments": [],
                "text": "A data locality optimizing algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 63,
                "text": "An algorithm that improves the locality of a loop nest by transforming the code via interchange, reversal, skewing and tiling is proposed, and is successful in optimizing codes such as matrix multiplication, successive over-relaxation, LU decomposition without pivoting, and Givens QR factorization."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '91"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144198209"
                        ],
                        "name": "Jingling Xue",
                        "slug": "Jingling-Xue",
                        "structuredName": {
                            "firstName": "Jingling",
                            "lastName": "Xue",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jingling Xue"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 141
                            }
                        ],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7339836,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0256e1248efb7297b6ee3503941f3803082e2ed6",
            "isKey": false,
            "numCitedBy": 41,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": "Tiling is a loop transformation that the compiler uses to create automatically blocked algorithms in order to improve the benefits of the memory hierarchy and reduce the communication overhead between processors. Motivated by existing results, this paper presents a conceptually simple approach to finding tilings with a minimal amount of communication between tiles. The development of all results is based primarily on the inequality of arithmetic and geometric means, except for Lemma 8 whose proof relies on the concept of extremal rays of convex cones. The key insight is mat a tiling that is communication-minimal must induce the same amount of communication through all faces of a tile, which restricts the search space for optimal tilings to those tiling matrices whose rows are all extremal rays in a cone. For nested loops with several special forms of dependences, closed-form optimal tilings are derived. In the general case, a procedure is given that always returns optimal tilings. A detailed comparison of this work with some existing results is provided."
            },
            "slug": "Communication-Minimal-Tiling-of-Uniform-Dependence-Xue",
            "title": {
                "fragments": [],
                "text": "Communication-Minimal Tiling of Uniform Dependence Loops"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "A conceptually simple approach to finding tilings with a minimal amount of communication between tiles by restricting the search space for optimal tilings to those tiling matrices whose rows are all extremal rays in a cone."
            },
            "venue": {
                "fragments": [],
                "text": "LCPC"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "28513548"
                        ],
                        "name": "Amy W. Lim",
                        "slug": "Amy-W.-Lim",
                        "structuredName": {
                            "firstName": "Amy",
                            "lastName": "Lim",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amy W. Lim"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40063567"
                        ],
                        "name": "Shih-Wei Liao",
                        "slug": "Shih-Wei-Liao",
                        "structuredName": {
                            "firstName": "Shih-Wei",
                            "lastName": "Liao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Shih-Wei Liao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2860549,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "598863f81fc8fae6647a65cade0a323f79efe197",
            "isKey": false,
            "numCitedBy": 150,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Applicable to arbitrary sequences and nests of loops, affine partitioning is a program transformation framework that unifies many previously proposed loop transformations, including unimodular transforms, fusion, fission, reindexing, scaling and statement reordering. Algorithms based on affine partitioning have been shown to be effective for parallelization and communication minimization. This paper presents algorithms that improve data locality using affine partitioning.\nBlocking and array contraction are two important optimizations that have been shown to be useful for data locality. Blocking creates a set of inner loops so that data brought into the faster levels of the memory hierarchy can be reused. Array contraction reduces an array to a scalar variable and thereby reduces the number of memory operations executed and the memory footprint. Loop transforms are often necessary to make blocking and array contraction possible.\n By bringing the full generality of affine partitioning to bear on the problem, our locality algorithm can find more contractable arrays than previously possible. This paper also generalizes the concept of blocking and shows that affine partitioning allows the benefits of blocking be realized in arbitrarily nested loops. Experimental results on a number of benchmarks and a complete multigrid application in aeronautics indicates that affine partitioning is effective in practice."
            },
            "slug": "Blocking-and-array-contraction-across-arbitrarily-Lim-Liao",
            "title": {
                "fragments": [],
                "text": "Blocking and array contraction across arbitrarily nested loops using affine partitioning"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "This paper generalizes the concept of blocking and shows that affine partitioning allows the benefits of blocking be realized in arbitrarily nested loops, and can find more contractable arrays than previously possible."
            },
            "venue": {
                "fragments": [],
                "text": "PPoPP '01"
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "28513548"
                        ],
                        "name": "Amy W. Lim",
                        "slug": "Amy-W.-Lim",
                        "structuredName": {
                            "firstName": "Amy",
                            "lastName": "Lim",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amy W. Lim"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2261825"
                        ],
                        "name": "Gerald I. Cheong",
                        "slug": "Gerald-I.-Cheong",
                        "structuredName": {
                            "firstName": "Gerald",
                            "lastName": "Cheong",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Gerald I. Cheong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 10945781,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9382ea659ccde9e28047834d19ed9de8fa8d1760",
            "isKey": false,
            "numCitedBy": 189,
            "numCiting": 32,
            "paperAbstract": {
                "fragments": [],
                "text": "An affine partitioning Framework unifies many useful program transforms such as unimodular transformations (interchange, reversal, skewing), loop fusion, fission, scaling, reindexing, and statement reordering. This paper presents an algorithm, based on this unified framework, that maximizes parallelism while minimizing communication in programs with arbitrary loop nestings and affine data accesses. Our algorithm can find the optimal affine partition that maximizes the degree of parallelism with the minimum degree of synchronizations. In addition, it uses a greedy algorithm to minimize communication between loops heuristically by aligning the computation partitions for different loops, trading off excess degrees of parallelism, and choosing pipelined parallelism over doall paralleIism if it can significantly reduce the communication. The algorithm is optimal in maximizing the degrees of parallelism that require (1) no communication, (2) near-neighbor communication and a constant number of synchronizations, and (3) near-neighbor communication and O(n) synchronizations where n is the number of iterations in a loop."
            },
            "slug": "An-affine-partitioning-algorithm-to-maximize-and-Lim-Cheong",
            "title": {
                "fragments": [],
                "text": "An affine partitioning algorithm to maximize parallelism and minimize communication"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "An algorithm is presented that maximizes parallelism while minimizing communication in programs with arbitrary loop nestings and affine data accesses and can find the optimal affine partition that maximized the degree of parallelism with the minimum degree of synchronizations."
            },
            "venue": {
                "fragments": [],
                "text": "ICS '99"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1910572"
                        ],
                        "name": "E. Hodzic",
                        "slug": "E.-Hodzic",
                        "structuredName": {
                            "firstName": "Edin",
                            "lastName": "Hodzic",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Hodzic"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144005858"
                        ],
                        "name": "W. Shang",
                        "slug": "W.-Shang",
                        "structuredName": {
                            "firstName": "Weijia",
                            "lastName": "Shang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Shang"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 141
                            }
                        ],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 10700631,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "eef46c46bbc8511318ddcaf8bc5f7c14997a1055",
            "isKey": false,
            "numCitedBy": 37,
            "numCiting": 45,
            "paperAbstract": {
                "fragments": [],
                "text": "With the objective of minimizing the total execution time of a parallel program on a distributed memory parallel computer, this paper discusses the selection of an optimal supernode shape of a supernode transformation (also known as tiling). We identify three parameters of a supernode transformation: supernode size, relative side lengths, and cutting hyperplane directions. For supernode transformations on algorithms with perfectly nested loops and uniform dependencies, we prove the optimality of a constant linear schedule vector and give a necessary and sufficient condition for optimal relative side lengths. We also prove that the total running time is minimized by a cutting hyperplane direction matrix from a particular subset of all valid directions and we discuss the cases where this subset is unique. The results are derived in continuous space and should be considered approximate. Our model does not include cache effects and assumes an unbounded number of available processors, the communication cost approximated by a constant, uniform dependences, and loop bounds known at compile time. A comprehensive example is discussed with an application of the results to the Jacobi algorithm."
            },
            "slug": "On-Time-Optimal-Supernode-Shape-Hodzic-Shang",
            "title": {
                "fragments": [],
                "text": "On Time Optimal Supernode Shape"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "It is proved that the optimality of a constant linear schedule vector is a necessary and sufficient condition for optimal relative side lengths and the total running time is minimized by a cutting hyperplane direction matrix from a particular subset of all valid directions."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Parallel Distributed Syst."
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2192711"
                        ],
                        "name": "Georges-Andr\u00e9 Silber",
                        "slug": "Georges-Andr\u00e9-Silber",
                        "structuredName": {
                            "firstName": "Georges-Andr\u00e9",
                            "lastName": "Silber",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Georges-Andr\u00e9 Silber"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "41070781"
                        ],
                        "name": "F. Vivien",
                        "slug": "F.-Vivien",
                        "structuredName": {
                            "firstName": "Fr\u00e9d\u00e9ric",
                            "lastName": "Vivien",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Vivien"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6184063,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e28cdf77aa7ea99cb4c4ed92a60c1638863ecab7",
            "isKey": false,
            "numCitedBy": 72,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "Tiling is a technique used for exploiting medium-grain parallelism in nested loops. It relies on a first step that detects sets of permutable nested loops. All algorithms developed so far consider the statements of the loop body as a single block, in other words, they are not able to take advantage of the structure of dependences between different statements. In this paper, we overcame this limitation by showing how the structure of the reduced dependence graph can be taken into account for detecting more permutable loops. Our method combines graph retiming techniques and graph scheduling techniques. It can be viewed as an extension of Wolf and Lam's algorithm to the case of loops with multiple statements. Loan independent dependences play a particular role in our study, and we show how the way we handle them can be useful for fine-grain loop parallelization as well."
            },
            "slug": "Combining-Retiming-and-Scheduling-Techniques-for-Darte-Silber",
            "title": {
                "fragments": [],
                "text": "Combining Retiming and Scheduling Techniques for Loop Parallelization and Loop Tiling"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This paper demonstrates how the structure of the reduced dependence graph can be taken into account for detecting more permutable loops and shows how the way it is handled can be useful for fine-grain loop parallelization as well."
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Process. Lett."
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2070331"
                        ],
                        "name": "K. Yotov",
                        "slug": "K.-Yotov",
                        "structuredName": {
                            "firstName": "Kamen",
                            "lastName": "Yotov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Yotov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2116431932"
                        ],
                        "name": "Xiaoming Li",
                        "slug": "Xiaoming-Li",
                        "structuredName": {
                            "firstName": "Xiaoming",
                            "lastName": "Li",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Xiaoming Li"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2055939116"
                        ],
                        "name": "Gang Ren",
                        "slug": "Gang-Ren",
                        "structuredName": {
                            "firstName": "Gang",
                            "lastName": "Ren",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Gang Ren"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2300469"
                        ],
                        "name": "Mike Cibulskis",
                        "slug": "Mike-Cibulskis",
                        "structuredName": {
                            "firstName": "Mike",
                            "lastName": "Cibulskis",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mike Cibulskis"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1802807"
                        ],
                        "name": "G. DeJong",
                        "slug": "G.-DeJong",
                        "structuredName": {
                            "firstName": "Gerald",
                            "lastName": "DeJong",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. DeJong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3106639"
                        ],
                        "name": "M. Garzar\u00e1n",
                        "slug": "M.-Garzar\u00e1n",
                        "structuredName": {
                            "firstName": "Mar\u00eda",
                            "lastName": "Garzar\u00e1n",
                            "middleNames": [
                                "Jes\u00fas"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Garzar\u00e1n"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1729097"
                        ],
                        "name": "D. Padua",
                        "slug": "D.-Padua",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Padua",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Padua"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1776186"
                        ],
                        "name": "K. Pingali",
                        "slug": "K.-Pingali",
                        "structuredName": {
                            "firstName": "Keshav",
                            "lastName": "Pingali",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Pingali"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3223763"
                        ],
                        "name": "P. Stodghill",
                        "slug": "P.-Stodghill",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Stodghill",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Stodghill"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143856977"
                        ],
                        "name": "Peng Wu",
                        "slug": "Peng-Wu",
                        "structuredName": {
                            "firstName": "Peng",
                            "lastName": "Wu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Peng Wu"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7093054,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cbda9d69bfa9d2e33e73f0c77ac205f376a9c133",
            "isKey": false,
            "numCitedBy": 196,
            "numCiting": 48,
            "paperAbstract": {
                "fragments": [],
                "text": "Empirical program optimizers estimate the values of key optimization parameters by generating different program versions and running them on the actual hardware to determine which values give the best performance. In contrast, conventional compilers use models of programs and machines to choose these parameters. It is widely believed that model-driven optimization does not compete with empirical optimization, but few quantitative comparisons have been done to date. To make such a comparison, we replaced the empirical optimization engine in ATLAS (a system for generating a dense numerical linear algebra library called the BLAS) with a model-driven optimization engine that used detailed models to estimate values for optimization parameters, and then measured the relative performance of the two systems on three different hardware platforms. Our experiments show that model-driven optimization can be surprisingly effective, and can generate code whose performance is comparable to that of code generated by empirical optimizers for the BLAS."
            },
            "slug": "A-comparison-of-empirical-and-model-driven-Yotov-Li",
            "title": {
                "fragments": [],
                "text": "A comparison of empirical and model-driven optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The experiments show that model-driven optimization can be surprisingly effective, and can generate code whose performance is comparable to that of code generated by empirical optimizers for the BLAS."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '03"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145597416"
                        ],
                        "name": "W. Kelly",
                        "slug": "W.-Kelly",
                        "structuredName": {
                            "firstName": "Wayne",
                            "lastName": "Kelly",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Kelly"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144022269"
                        ],
                        "name": "W. Pugh",
                        "slug": "W.-Pugh",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Pugh",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Pugh"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50593802"
                        ],
                        "name": "E. Rosser",
                        "slug": "E.-Rosser",
                        "structuredName": {
                            "firstName": "Evan",
                            "lastName": "Rosser",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Rosser"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 138,
                                "start": 134
                            }
                        ],
                        "text": "Copyright c &#38;#169; 2008ACM \n978-1-59593-860-2/08/06... $5.00 J. Ramanujam2 P. Sadayappan1 2Dept.of Electrical&#38;Computer Engineering&#38;CCT \nLouisiana State University jxr@ece.lsu.edu Manycompute-intensive applications often spend most of their \nexecution time in nested loops."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 60915757,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "39a0018bf60ae72b34e61d83129c2808525718a7",
            "isKey": true,
            "numCitedBy": 138,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "There has been a great amount of recent work toward unifying iteration reordering transformations. Many of these approaches represent transformations as affine mappings from the original iteration space to a new iteration space. These approaches show a great deal of promise, but they all rely on the ability to generate code that iterates over the points in these new iteration spaces in the appropriate order. This problem has been fairly well-studied in the case where all statements use the same mapping. We have developed an algorithm for the less well-studied case where each statement uses a potentially different mapping. Unlike many other approaches, our algorithm can also generate code from mappings corresponding to loop blocking. We address the important trade-off between reducing control overhead and duplicating code.<<ETX>>"
            },
            "slug": "Code-generation-for-multiple-mappings-Kelly-Pugh",
            "title": {
                "fragments": [],
                "text": "Code generation for multiple mappings"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This work has developed an algorithm that addresses the important trade-off between reducing control overhead and duplicating code and can also generate code from mappings corresponding to loop blocking."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings Frontiers '95. The Fifth Symposium on the Frontiers of Massively Parallel Computation"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144022269"
                        ],
                        "name": "W. Pugh",
                        "slug": "W.-Pugh",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Pugh",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Pugh"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6756477,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5097a13ef3ce1cbbf4947df044ed76635f8d0420",
            "isKey": false,
            "numCitedBy": 597,
            "numCiting": 27,
            "paperAbstract": {
                "fragments": [],
                "text": "ndamental analis step in an ad',nced optimizing compiler (as well as many other software tools) is data dependence analysis f o r arrays. This means deciding i f two references to an array can refer to the same e lement and i f so, under what conditions. This information is used to determine allowable program transformations and optimizations. For example, we can determine that in the fo l lowing code fragment , no location o f the array is both read and written. Once we also verify that no location is writ ten more than once, we know that the writes can be done in any order. for i = 1 to 100 do f o r j -i to 100 do A[i, j + 11 = A[100,j]"
            },
            "slug": "A-practical-algorithm-for-exact-array-dependence-Pugh",
            "title": {
                "fragments": [],
                "text": "A practical algorithm for exact array dependence analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 91,
                "text": "A fundamental analis step in an ad',nced optimizing compiler (as well as many other software tools) is data dependence analysis f o r arrays, which determines whether two references to an array can refer to the same e lement and under what conditions."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145683292"
                        ],
                        "name": "S. Kamil",
                        "slug": "S.-Kamil",
                        "structuredName": {
                            "firstName": "Shoaib",
                            "lastName": "Kamil",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Kamil"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49589461"
                        ],
                        "name": "K. Datta",
                        "slug": "K.-Datta",
                        "structuredName": {
                            "firstName": "Kaushik",
                            "lastName": "Datta",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Datta"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145117071"
                        ],
                        "name": "Samuel Williams",
                        "slug": "Samuel-Williams",
                        "structuredName": {
                            "firstName": "Samuel",
                            "lastName": "Williams",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Samuel Williams"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1757847"
                        ],
                        "name": "L. Oliker",
                        "slug": "L.-Oliker",
                        "structuredName": {
                            "firstName": "Leonid",
                            "lastName": "Oliker",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Oliker"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746446"
                        ],
                        "name": "J. Shalf",
                        "slug": "J.-Shalf",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Shalf",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Shalf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1731111"
                        ],
                        "name": "K. Yelick",
                        "slug": "K.-Yelick",
                        "structuredName": {
                            "firstName": "Katherine",
                            "lastName": "Yelick",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Yelick"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7034373,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "bdf9e863482f0b74e5aef6a2a6924f4e90a2625b",
            "isKey": false,
            "numCitedBy": 147,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "Stencil-based kernels constitute the core of many scientific applications on block-structured grids. Unfortunately, these codes achieve a low fraction of peak performance, due primarily to the disparity between processor and main memory speeds. We examine several optimizations on both the conventional cache-based memory systems of the Itanium 2, Opteron, and Power5, as well as the heterogeneous multicore design of the Cell processor. The optimizations target cache reuse across stencil sweeps, including both an implicit cache oblivious approach and a cache-aware algorithm blocked to match the cache structure. Finally, we consider stencil computations on a machine with an explicitly-managed memory hierarchy, the Cell processor. Overall, results show that a cache-aware approach is significantly faster than a cache oblivious approach and that the explicitly managed memory on Cell is more efficient: Relative to the Power5, it has almost 2x more memory bandwidth and is 3.7x faster."
            },
            "slug": "Implicit-and-explicit-optimizations-for-stencil-Kamil-Datta",
            "title": {
                "fragments": [],
                "text": "Implicit and explicit optimizations for stencil computations"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "Several optimizations on both the conventional cache-based memory systems of the Itanium 2, Opteron, and Power5, as well as the heterogeneous multicore design of the Cell processor are examined, including both an implicit cache oblivious approach and a cache-aware algorithm blocked to match the cache structure."
            },
            "venue": {
                "fragments": [],
                "text": "MSPC '06"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1708869"
                        ],
                        "name": "J. Dongarra",
                        "slug": "J.-Dongarra",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Dongarra",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Dongarra"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143986781"
                        ],
                        "name": "R. Schreiber",
                        "slug": "R.-Schreiber",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Schreiber",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Schreiber"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14477597,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e89225f891a98820121832a155c2a275d563b0b1",
            "isKey": false,
            "numCitedBy": 186,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Blocked algorithms have much better properties of data locality and therefore can be much more efficient than ordinary algorithms when a memory hierarchy is involved. On the other hand, they are very difficult to write and to tune for particular machines. The reorganization is considered of nested loops through the use of known program transformations in order to create blocked algorithms automatically. The program transformations used are strip mining, loop interchange, and a variant of loop skewing in which invertible linear transformations (with integer coordinates) of the loop indices are allowed. Some problems are solved concerning the optimal application of these transformations. It is shown, in a very general setting, how to choose a nearly optimal set of transformed indices. It is then shown, in one particular but rather frequently occurring situation, how to choose an optimal set of block sizes."
            },
            "slug": "Automatic-Blocking-of-Nested-Loops-Dongarra-Schreiber",
            "title": {
                "fragments": [],
                "text": "Automatic Blocking of Nested Loops"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "It is shown, in a very general setting, how to choose a nearly optimal set of transformed indices and, in one particular but rather frequently occurring situation,How to choose an optimalSet of block sizes."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 42
                            }
                        ],
                        "text": "Several works are based on such schedules [7, 24, 14, 45, 44]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6676338,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9ffb522ce93e16718083d11d03a6af5587681018",
            "isKey": false,
            "numCitedBy": 50,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "Cache memories were invented to decouple fast processors from slow memories. However, this decoupling is only partial, and many researchers have attempted to improve cache use by program optimization. Potential benefits are significant since both energy dissipation and performance highly depend on the traffic between memory levels. But modeling the traffic is difficult; this observation has led to the use of heuristic methods for steering program transformations. In this paper, we propose another approach: we simplify the cache model and we organize the target program in such a way that an asymptotic evaluation of the memory traffic is possible. This information is used by our optimization algorithm in order to find the best reordering of the program operations, at least in an asymptotic sense. Our method optimizes both temporal and spatial locality. It can be applied to any static control program with arbitrary dependences. The optimizer has been partially implemented and applied to non-trivial programs. We present experimental evidence that the amount of cache misses is drastically reduced with corresponding performance improvements."
            },
            "slug": "Improving-Data-Locality-by-Chunking-Bastoul-Feautrier",
            "title": {
                "fragments": [],
                "text": "Improving Data Locality by Chunking"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This paper simplifies the cache model and organizes the target program in such a way that an asymptotic evaluation of the memory traffic is possible, and presents experimental evidence that the amount of cache misses is drastically reduced with corresponding performance improvements."
            },
            "venue": {
                "fragments": [],
                "text": "CC"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1744256"
                        ],
                        "name": "Pierre Boulet",
                        "slug": "Pierre-Boulet",
                        "structuredName": {
                            "firstName": "Pierre",
                            "lastName": "Boulet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Pierre Boulet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2192711"
                        ],
                        "name": "Georges-Andr\u00e9 Silber",
                        "slug": "Georges-Andr\u00e9-Silber",
                        "structuredName": {
                            "firstName": "Georges-Andr\u00e9",
                            "lastName": "Silber",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Georges-Andr\u00e9 Silber"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "41070781"
                        ],
                        "name": "F. Vivien",
                        "slug": "F.-Vivien",
                        "structuredName": {
                            "firstName": "Fr\u00e9d\u00e9ric",
                            "lastName": "Vivien",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Vivien"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[12] for a detailed summary of earlier parallelization algorithms \u2013 these restricted the input loop forms and/or were based on weaker dependence abstractions than exact polyhedral dependences [3, 17, 16, 59]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7804781,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f1206999e216f9622dcc42ab548434361c3cef73",
            "isKey": false,
            "numCitedBy": 97,
            "numCiting": 60,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Loop-Parallelization-Algorithms:-From-Parallelism-Boulet-Darte",
            "title": {
                "fragments": [],
                "text": "Loop Parallelization Algorithms: From Parallelism Extraction to Code Generation"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Comput."
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144022269"
                        ],
                        "name": "W. Pugh",
                        "slug": "W.-Pugh",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Pugh",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Pugh"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 113,
                                "start": 109
                            }
                        ],
                        "text": "Copyright c &#38;#169; 2008ACM \n978-1-59593-860-2/08/06... $5.00 J. Ramanujam2 P. Sadayappan1 2Dept.of Electrical&#38;Computer Engineering&#38;CCT \nLouisiana State University jxr@ece.lsu.edu Manycompute-intensive applications often spend most of their \nexecution time in nested loops."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 3174094,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "285024b15197b5face8bdef1d03f36949b8339c4",
            "isKey": true,
            "numCitedBy": 949,
            "numCiting": 37,
            "paperAbstract": {
                "fragments": [],
                "text": "The Omega test is an integer programming algorithm that can determine whether a dependence exists between two array references, and if so, under what conditions. Conventional wisdom holds that integer programming techniques are far too expensive to be used for dependence analysis, except as a method of last resort for situations that cannot be decided by simpler methods. We present evidence that suggests this wisdom is wrong, and that the Omega test is competitive with approximate algorithms used in practice and suitable for use in production compilers. The Omega test is based on an extension of FourierMotzkin variable elimination to integer programming, and has worst-case exponential time complexity. However, we show that for many situations in which other (polynomial) methods are accurate, the Omega test has low order polynomial time complexity. The Omega test can be used to simplify integer programming problems, rather than just deciding them. This has many applications, including accurately and efficiently computing dependence direction and distance vectors."
            },
            "slug": "The-Omega-test:-A-fast-and-practical-integer-for-Pugh",
            "title": {
                "fragments": [],
                "text": "The Omega test: A fast and practical integer programming algorithm for dependence analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Evidence is presented that suggests conventional wisdom is wrong, and that the Omega test is competitive with approximate algorithms used in practice and suitable for use in production compilers, and has low order polynomial time complexity."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 1991 ACM/IEEE Conference on Supercomputing (Supercomputing '91)"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 8
                            }
                        ],
                        "text": "[20] P. Feautrier."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 8
                            }
                        ],
                        "text": "[18] P. Feautrier."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 100,
                                "start": 80
                            }
                        ],
                        "text": "Our approach is thus a departure from scheduling-based approaches in this field [20, 21, 17, 24, 15] as well as partitioning-based approaches [37, 36, 35] (due to incorporation of more concrete optimization criteria), however, is built on the same mathematical foundations and machinery."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 9,
                                "start": 0
                            }
                        ],
                        "text": "Feautrier."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 52
                            }
                        ],
                        "text": "E (4) Suchabounding function approachwas .rst usedbyFeautrier [20], but for a \ndifferent purpose to .nd minimum latency schedules."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 119,
                                "start": 110
                            }
                        ],
                        "text": "We \nthus provide comparison for some num\u00adber of cases with the state of the art (1) Griebl s approach that \nuses Feautrier s schedules along with Forward-Communication-Only allocations to enable time tiling [24] \nthat will be referred to as Scheduling-based (time tiling) and (2) Lim/Lam s af.ne parti\u00adtioning [37, \n36, 35] referred to as Af.ne partitioning (max degree parallelism, no cost function) in the graphs."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 8
                            }
                        ],
                        "text": "[21] P. Feautrier."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 8
                            }
                        ],
                        "text": "[19] P. Feautrier."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 31,
                                "start": 23
                            }
                        ],
                        "text": "The works of Feautrier [20, 21], Darte and Vivien [17] and Griebl [24] (to some extent) fall into the former class, while Lim/Lam\u2019s approach [37, 36, 35] falls into the second class."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 22,
                                "start": 13
                            }
                        ],
                        "text": "The works \nof Feautrier [20, 21], Darte and Vivien [17] and Griebl [24] (to someextent)fall into the former class, \nwhileLim/Lam s approach[37,36,35]fallsintothe second class."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 143,
                                "start": 134
                            }
                        ],
                        "text": "As for scheduling-based approaches, \nthe LooPo system[38] includes implementationsofvarious polyhe\u00addral scheduling techniques including Feautrier \ns multi-dimensional time scheduler which can be coupled with Griebl s space and FCO time tiling techniques."
                    },
                    "intents": []
                }
            ],
            "corpusId": 23417662,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "486986fb365f072146cb9648ab408b0c567ae019",
            "isKey": true,
            "numCitedBy": 384,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper extends the algorithms which were developed in Part I to cases in which there is no affine schedule, i.e. to problems whose parallel complexity is polynomial but not linear. The natural generalization is to multidimensional schedules with lexicographic ordering as temporal succession. Multidimensional affine schedules, are, in a sense, equivalent to polynomial schedules, and are much easier to handle automatically. Furthermore, there is a strong connection between multidimensional schedules and loop nests, which allows one to prove that a static control program always has a multidimensional schedule. Roughly, a larger dimension indicates less parallelism. In the algorithm which is presented here, this dimension is computed dynamically, and is just sufficient for scheduling the source program. The algorithm lends itself to a \u201cdivide and conquer\u201d strategy. The paper gives some experimental evidence for the applicability, performances and limitations of the algorithm."
            },
            "slug": "Some-efficient-solutions-to-the-affine-scheduling-Feautrier",
            "title": {
                "fragments": [],
                "text": "Some efficient solutions to the affine scheduling problem. Part II. Multidimensional time"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "This paper extends the algorithms which were developed in Part I to cases in which there is no affine schedule, i.e. to problems whose parallel complexity is polynomial but not linear, and gives some experimental evidence for the applicability, performances and limitations of the algorithm."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2709194"
                        ],
                        "name": "R. Andonov",
                        "slug": "R.-Andonov",
                        "structuredName": {
                            "firstName": "Rumen",
                            "lastName": "Andonov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Andonov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50009319"
                        ],
                        "name": "S. Balev",
                        "slug": "S.-Balev",
                        "structuredName": {
                            "firstName": "Stephan",
                            "lastName": "Balev",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Balev"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747659"
                        ],
                        "name": "S. Rajopadhye",
                        "slug": "S.-Rajopadhye",
                        "structuredName": {
                            "firstName": "Sanjay",
                            "lastName": "Rajopadhye",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Rajopadhye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2405305"
                        ],
                        "name": "N. Yanev",
                        "slug": "N.-Yanev",
                        "structuredName": {
                            "firstName": "Nicola",
                            "lastName": "Yanev",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Yanev"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 2078046,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1faa6e41f6fd2a3ecba7b5f773097b7fc2614796",
            "isKey": false,
            "numCitedBy": 27,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "For 2-D iteration space tiling, we address the problem of determining the tile parameters that minimize the total execution time under the BSP model. We consider uniform dependency computations, tiled so that (at least) one of the tile boundaries is parallel to the domain boundary. We determine the optimal tile size as a closed form solution. In addition, we determine the optimal number of processors and also the optimal slope of the oblique tile boundary.\nOur predictions are validated, among other examples, on a sequence alignment problem specialized to similar sequences using Ficket's \u201ck-band\u201d algorithm, for which, our optimal semi-oblique tiling yields an improvement over orthogonal tiling by a factor of 2.5. Our optimal solution requires a block-cyclic distribution of tiles to processors. The best one can obtain with only block distribution (as many authors require) is 3 times slower."
            },
            "slug": "Optimal-semi-oblique-tiling-Andonov-Balev",
            "title": {
                "fragments": [],
                "text": "Optimal Semi-Oblique Tiling"
            },
            "tldr": {
                "abstractSimilarityScore": 69,
                "text": "This work addresses the problem of determining the tile parameters that minimize the total execution time under the BSP model, and determines the optimal tile size as a closed form solution and the optimal number of processors."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Parallel Distributed Syst."
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144616193"
                        ],
                        "name": "R. Allen",
                        "slug": "R.-Allen",
                        "structuredName": {
                            "firstName": "Randy",
                            "lastName": "Allen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 207,
                                "start": 192
                            }
                        ],
                        "text": "[12] for a detailed summary of earlier parallelization algorithms \u2013 these restricted the input loop forms and/or were based on weaker dependence abstractions than exact polyhedral dependences [3, 17, 16, 59]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 13978052,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e8ddfb7574926d50b75937424ff907b53d264ca6",
            "isKey": false,
            "numCitedBy": 824,
            "numCiting": 53,
            "paperAbstract": {
                "fragments": [],
                "text": "The recent success of vector computers such as the Cray-1 and array processors such as those manufactured by Floating Point Systems has increased interest in making vector operations available to the FORTRAN programmer. The FORTRAN standards committee is currently considering a successor to FORTRAN 77, usually called FORTRAN 8x, that will permit the programmer to explicitly specify vector and array operations.\nAlthough FORTRAN 8x will make it convenient to specify explicit vector operations in new programs, it does little for existing code. In order to benefit from the power of vector hardware, existing programs will need to be rewritten in some language (presumably FORTRAN 8x) that permits the explicit specification of vector operations. One way to avoid a massive manual recoding effort is to provide a translator that discovers the parallelism implicit in a FORTRAN program and automatically rewrites that program in FORTRAN 8x.\nSuch a translation from FORTRAN to FORTRAN 8x is not straightforward because FORTRAN DO loops are not always semantically equivalent to the corresponding FORTRAN 8x parallel operation. The semantic difference between these two constructs is precisely captured by the concept of dependence. A translation from FORTRAN to FORTRAN 8x preserves the semantics of the original program if it preserves the dependences in that program.\nThe theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form. Dependence is defined and characterized in terms of the conditions that give rise to it; accurate tests to determine dependence are presented; and transformations that use dependence to uncover additional parallelism are discussed."
            },
            "slug": "Automatic-translation-of-FORTRAN-programs-to-vector-Allen-Kennedy",
            "title": {
                "fragments": [],
                "text": "Automatic translation of FORTRAN programs to vector form"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "The theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form and transformations that use dependence to uncover additional parallelism are discussed."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 12851421,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "16de6f9e2bf6ee1068dbca8c9e5446295c904315",
            "isKey": false,
            "numCitedBy": 459,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": "Programs and systems of recurrence equations may be represented as sets of actions which are to be executed subject to precedence constraints. In may cases, actions may be labelled by integral vectors in some iterations domains, and precedence constraints may be described by affine relations. A schedule for such a program is a function which assigns an execution data to each action. Knowledge of such a schedule allows one to estimate the intrinsic degree of parallelism of the program and to compile a parallel version for multiprocessor architectures or systolic arrays. This paper deals with the problem of finding closed form schedules as affine or piecewise affine functions of the iteration vector. An algorithm is presented which reduces the scheduling problem to a parametric linear program of small size, which can be readily solved by an efficient algorithm."
            },
            "slug": "Some-efficient-solutions-to-the-affine-scheduling-Feautrier",
            "title": {
                "fragments": [],
                "text": "Some efficient solutions to the affine scheduling problem. I. One-dimensional time"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This paper deals with the problem of finding closed form schedules as affine or piecewise affine functions of the iteration vector and presents an algorithm which reduces the scheduling problem to a parametric linear program of small size, which can be readily solved by an efficient algorithm."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144301481"
                        ],
                        "name": "R. C. Whaley",
                        "slug": "R.-C.-Whaley",
                        "structuredName": {
                            "firstName": "R.",
                            "lastName": "Whaley",
                            "middleNames": [
                                "Clinton"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. C. Whaley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1719457"
                        ],
                        "name": "A. Petitet",
                        "slug": "A.-Petitet",
                        "structuredName": {
                            "firstName": "Antoine",
                            "lastName": "Petitet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Petitet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1708869"
                        ],
                        "name": "J. Dongarra",
                        "slug": "J.-Dongarra",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Dongarra",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Dongarra"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 159954,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c649fed768cf39c83531eb4f17082a51bfedb70f",
            "isKey": false,
            "numCitedBy": 1158,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Automated-empirical-optimizations-of-software-and-Whaley-Petitet",
            "title": {
                "fragments": [],
                "text": "Automated empirical optimizations of software and the ATLAS project"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Comput."
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "41070781"
                        ],
                        "name": "F. Vivien",
                        "slug": "F.-Vivien",
                        "structuredName": {
                            "firstName": "Fr\u00e9d\u00e9ric",
                            "lastName": "Vivien",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Vivien"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 6,
                                "start": 0
                            }
                        ],
                        "text": "Vivien."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 100,
                                "start": 80
                            }
                        ],
                        "text": "Our approach is thus a departure from scheduling-based approaches in this field [20, 21, 17, 24, 15] as well as partitioning-based approaches [37, 36, 35] (due to incorporation of more concrete optimization criteria), however, is built on the same mathematical foundations and machinery."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 207,
                                "start": 192
                            }
                        ],
                        "text": "[12] for a detailed summary of earlier parallelization algorithms \u2013 these restricted the input loop forms and/or were based on weaker dependence abstractions than exact polyhedral dependences [3, 17, 16, 59]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 42,
                                "start": 36
                            }
                        ],
                        "text": "[16] A. Darte, G.-A. Silber, and F. Vivien."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 54,
                                "start": 50
                            }
                        ],
                        "text": "The works of Feautrier [20, 21], Darte and Vivien [17] and Griebl [24] (to some extent) fall into the former class, while Lim/Lam\u2019s approach [37, 36, 35] falls into the second class."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 39,
                                "start": 33
                            }
                        ],
                        "text": "[15] A. Darte, Y. Robert, and F. Vivien."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 49,
                                "start": 33
                            }
                        ],
                        "text": "The works \nof Feautrier [20, 21], Darte and Vivien [17] and Griebl [24] (to someextent)fall into the former class, \nwhileLim/Lam s approach[37,36,35]fallsintothe second class."
                    },
                    "intents": []
                }
            ],
            "corpusId": 9495601,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "13a21479048ac71ac583d880aea2695eb4ef3262",
            "isKey": true,
            "numCitedBy": 43,
            "numCiting": 80,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents an optimal algorithm for detecting line or medium grain parallelism in nested loops whose dependences are described by an approximation of distance vectors by polyhedra. In particular, this algorithm is optimal for the classical approximation by direction sectors. This result generalizes, to the case of several statements. Wolf and Lam's algorithm which is optimal for a single statement. Our algorithm relies on a dependence uniformization process and on parallelization techniques related to system of uniform recurrence equations. It can also be viewed as a combination of both Allen and Kennedy's algorithm and Wolf and Lam's algorithm."
            },
            "slug": "Optimal-Fine-and-Medium-Grain-Parallelism-Detection-Darte-Vivien",
            "title": {
                "fragments": [],
                "text": "Optimal Fine and Medium Grain Parallelism Detection in Polyhedral Reduced Dependence Graphs"
            },
            "tldr": {
                "abstractSimilarityScore": 90,
                "text": "This paper presents an optimal algorithm for detecting line or medium grain parallelism in nested loops whose dependences are described by an approximation of distance vectors by polyhedra that is optimal for the classical approximation by direction sectors."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 1996 Conference on Parallel Architectures and Compilation Technique"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "28513548"
                        ],
                        "name": "Amy W. Lim",
                        "slug": "Amy-W.-Lim",
                        "structuredName": {
                            "firstName": "Amy",
                            "lastName": "Lim",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amy W. Lim"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 28055317,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "36bc9c1c9da784ff78bb955bf6fc247961e0ac31",
            "isKey": false,
            "numCitedBy": 147,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Maximizing-Parallelism-and-Minimizing-with-Affine-Lim-Lam",
            "title": {
                "fragments": [],
                "text": "Maximizing Parallelism and Minimizing Synchronization with Affine Partitions"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Comput."
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1744256"
                        ],
                        "name": "Pierre Boulet",
                        "slug": "Pierre-Boulet",
                        "structuredName": {
                            "firstName": "Pierre",
                            "lastName": "Boulet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Pierre Boulet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144708005"
                        ],
                        "name": "T. Risset",
                        "slug": "T.-Risset",
                        "structuredName": {
                            "firstName": "Tanguy",
                            "lastName": "Risset",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Risset"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145552986"
                        ],
                        "name": "Y. Robert",
                        "slug": "Y.-Robert",
                        "structuredName": {
                            "firstName": "Yves",
                            "lastName": "Robert",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Robert"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5,  11 , 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 15580573,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "29d26d4ff8a79b90affcdf21414f1d9f700b04e6",
            "isKey": false,
            "numCitedBy": 147,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "(Pen)-ultimate-tiling-Boulet-Darte",
            "title": {
                "fragments": [],
                "text": "(Pen)-ultimate tiling?"
            },
            "venue": {
                "fragments": [],
                "text": "Integr."
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145597416"
                        ],
                        "name": "W. Kelly",
                        "slug": "W.-Kelly",
                        "structuredName": {
                            "firstName": "Wayne",
                            "lastName": "Kelly",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Kelly"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144022269"
                        ],
                        "name": "W. Pugh",
                        "slug": "W.-Pugh",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Pugh",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Pugh"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 152,
                                "start": 132
                            }
                        ],
                        "text": "In addition to model-based approaches, semi-automatic and search-based transformation frameworks in the polyhedral model also exist [30, 14, 22, 45, 44]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 61938591,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "57d1a9fdc692d6b32f29b0d3a43b05c9ef92a250",
            "isKey": false,
            "numCitedBy": 60,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a framework for unifying iteration reordering transformations such as loop interchange, loop distribution, skewing, tiling, index set splitting and statement reordering. The framework is based on the idea that a transformation can be represented as a mapping from the original iteration space to a new iteration space. The framework is designed to provide a uniform way to represent and reason about transformations. We also provide algorithms to test the legality of mappings, and to generate optimized code for mappings.<<ETX>>"
            },
            "slug": "A-unifying-framework-for-iteration-reordering-Kelly-Pugh",
            "title": {
                "fragments": [],
                "text": "A unifying framework for iteration reordering transformations"
            },
            "tldr": {
                "abstractSimilarityScore": 82,
                "text": "This work presents a framework for unifying iteration reordering transformations such as loop interchange, loop distribution, skewing, tiling, index set splitting and statement reordering, designed to provide a uniform way to represent and reason about transformations."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings 1st International Conference on Algorithms and Architectures for Parallel Processing"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 5738544,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7cd685371e267a499ded869a934a4cffed591aec",
            "isKey": false,
            "numCitedBy": 454,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "Given a program written in a simple imperative language (assignment statements,for loops, affine indices and loop limits), this paper presents an algorithm for analyzing the patterns along which values flow as the execution proceeds. For each array or scalar reference, the result is the name and iteration vector of the source statement as a function of the iteration vector of the referencing statement. The paper discusses several applications of the method: conversion of a program to a set of recurrence equations, array and scalar expansion, program verification and parallel program construction."
            },
            "slug": "Dataflow-analysis-of-array-and-scalar-references-Feautrier",
            "title": {
                "fragments": [],
                "text": "Dataflow analysis of array and scalar references"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "This paper presents an algorithm for analyzing the patterns along which values flow as the execution proceeds, and discusses several applications of the method: conversion of a program to a set of recurrence equations, array and scalar expansion, program verification and parallel program construction."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2050725"
                        ],
                        "name": "O. Yasar",
                        "slug": "O.-Yasar",
                        "structuredName": {
                            "firstName": "Osman",
                            "lastName": "Yasar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Yasar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "87558455"
                        ],
                        "name": "Y. Deng",
                        "slug": "Y.-Deng",
                        "structuredName": {
                            "firstName": "Y.",
                            "lastName": "Deng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Deng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2914613"
                        ],
                        "name": "R. E. Tuzun",
                        "slug": "R.-E.-Tuzun",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Tuzun",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. E. Tuzun"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "102971399"
                        ],
                        "name": "D. Saltz",
                        "slug": "D.-Saltz",
                        "structuredName": {
                            "firstName": "D.",
                            "lastName": "Saltz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Saltz"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Model-driven empirical optimization and automatic tuning approaches (e.g., ATLAS) have been shown to be very effective in optimizing single-processor execution for some regular kernels like matrix-matrix multiplication [ 56 , 63]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 195721081,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6f5cc984ba23ea682036cd3abf8f26a7553f4cd3",
            "isKey": false,
            "numCitedBy": 1135,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "New-trends-in-high-performance-computing-Yasar-Deng",
            "title": {
                "fragments": [],
                "text": "New trends in high performance computing"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2157338354"
                        ],
                        "name": "Wei Li",
                        "slug": "Wei-Li",
                        "structuredName": {
                            "firstName": "Wei",
                            "lastName": "Li",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Wei Li"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1776186"
                        ],
                        "name": "K. Pingali",
                        "slug": "K.-Pingali",
                        "structuredName": {
                            "firstName": "Keshav",
                            "lastName": "Pingali",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Pingali"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 5688067,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "a98fdf0ce1928599235175fcbafdf376c7f2d117",
            "isKey": false,
            "numCitedBy": 74,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "In this paper, we discuss a loop transformation framework that is based on integer non-singular matrices. The transformations included in this framework are called \u039b-transformations and include permutation, skewing and reversal, as well as a transformation calledloop scaling. This framework is more general than existing ones; however, it is also more difficult to generate code in our framework. This paper shows how integer lattice theory can be used to generate efficient code. An added advantage of our framework over existing ones is that there is a simple completion algorithm which, given a partial transformation matrix, produces a full transformation matrix that satisfies all dependences. This completion procedure has applications in parallelization and in the generation of code for NUMA machines."
            },
            "slug": "A-singular-loop-transformation-framework-based-on-Li-Pingali",
            "title": {
                "fragments": [],
                "text": "A singular loop transformation framework based on non-singular matrices"
            },
            "tldr": {
                "abstractSimilarityScore": 57,
                "text": "It is shown how integer lattice theory can be used to generate efficient code in a loop transformation framework based on integer non-singular matrices."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2007
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912411"
                        ],
                        "name": "F. Irigoin",
                        "slug": "F.-Irigoin",
                        "structuredName": {
                            "firstName": "Fran\u00e7ois",
                            "lastName": "Irigoin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Irigoin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3317184"
                        ],
                        "name": "R. Triolet",
                        "slug": "R.-Triolet",
                        "structuredName": {
                            "firstName": "R\u00e9mi",
                            "lastName": "Triolet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Triolet"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2980454,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "38747b103e631e1a3800a0f4aed496d1bf8fb82f",
            "isKey": false,
            "numCitedBy": 584,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Supercompilers must reschedule computations defined by nested DO-loops in order to make an efficient use of supercomputer features (vector units, multiple elementary processors, cache memory, etc\u2026). Many rescheduling techniques like loop interchange, loop strip-mining or rectangular partitioning have been described to speedup program execution. We present here a class of partitionings that encompasses previous techniques and provides enough flexibility to adapt code to multiprocessors with two levels of parallelism and two levels of memory."
            },
            "slug": "Supernode-partitioning-Irigoin-Triolet",
            "title": {
                "fragments": [],
                "text": "Supernode partitioning"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A class of partitionings is presented that encompasses previous techniques and provides enough flexibility to adapt code to multiprocessors with two levels of parallelism and two level of memory."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '88"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143860773"
                        ],
                        "name": "D. Wilde",
                        "slug": "D.-Wilde",
                        "structuredName": {
                            "firstName": "Doran",
                            "lastName": "Wilde",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Wilde"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 249,
                                "start": 242
                            }
                        ],
                        "text": "Goumas et al. [23] reported an alternate tiled code generation scheme \n(to [4]) to address the inef.ciency in\u00advolved in using Fourier-Motzkin however, this is no longer an \nissue as the state-of-the-art uses ef.cient algorithms [47, 6] based on PolyLib [57, 42] and its implementation \nof the Chernikovaalgo\u00adrithm[33]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 12,
                                "start": 5
                            }
                        ],
                        "text": "[42] PolyLib -Alibraryof polyhedral \nfunctions. http://icps.u-strasbg.fr/polylib/."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 27,
                                "start": 19
                            }
                        ],
                        "text": "CLooG uses PolyLib [57, 42] (which in turn uses the Chernikova algorithm [33]) for its core operations, and the code generated is far more efficient than that by older code generators based on FourierMotzkin variable elimination like Omega Codegen [46] or LooPo\u2019s internal code generator [25, 24])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 281,
                                "start": 273
                            }
                        ],
                        "text": "[23] reported an alternate tiled code generation scheme to Ancourt and Irigoin\u2019s [4]) to address the inefficiency involved in using Fourier-Motzkin elimination \u2013 however, this is no longer an issue as the state-of-the-art uses efficient algorithms [47, 6] based on PolyLib [57, 42] and its implementation of the Chernikova algorithm [33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 18,
                                "start": 11
                            }
                        ],
                        "text": "CLooG uses PolyLib [57, 42] (which in turn uses the Chernikova algorithm[33])forits \ncore operations,andthecode generatedisfar moreef.cient than thatby older code generators based onFourier-Motzkinvariable \nelimination like Omega Codegen [46] or LooPo s internal code generator [25, 24])."
                    },
                    "intents": []
                }
            ],
            "corpusId": 122619002,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "b912cf5f477a6e81c623097906645882fddc0fb1",
            "isKey": true,
            "numCitedBy": 236,
            "numCiting": 31,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract The design and implementation of a library of C-code procedures to perform operations on rational polyhedra is described. The library supports intersection, union, difference, simplification in context, convex hull, affine image, affine preimage, and computation of dual forms. Since not all of these functions are closed over polyhedra, the library is extended to operate on finite unions of polyhedra. The major design decisions made during the implementation of the library are discussed. The data structure used for representing finite unions of polyhedra is developed and validity rules for the representation of polyhedra are derived. And finally, the algorithms used to implement the various functions in the library are presented."
            },
            "slug": "A-LIBRARY-FOR-DOING-POLYHEDRAL-OPERATIONS-Wilde",
            "title": {
                "fragments": [],
                "text": "A LIBRARY FOR DOING POLYHEDRAL OPERATIONS"
            },
            "tldr": {
                "abstractSimilarityScore": 87,
                "text": "The design and implementation of a library of C-code procedures to perform operations on rational polyhedra to support intersection, union, difference, simplification in context, convex hull, affine image, affines preimage, and computation of dual forms is described."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144198209"
                        ],
                        "name": "Jingling Xue",
                        "slug": "Jingling-Xue",
                        "structuredName": {
                            "firstName": "Jingling",
                            "lastName": "Xue",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jingling Xue"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 132,
                                "start": 128
                            }
                        ],
                        "text": "The transformations .nally re.ect in the generated code as reordered execution with improved \ncache locality and/or loops that havebeen parallelized."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 26924725,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9711f277bc6159c963dbeb24c0ed447df85d88d5",
            "isKey": false,
            "numCitedBy": 230,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "List of Figures. List of Tables. Preface. Acknowledgments. Part I: Mathematic Background and Loop Transformation. 1. Mathematical Background. 2. Nonsingular Transformations and Permutability. Part II: Tiling as a Loop Transformation. 3. Rectangular Tiling. 4. Parallelepiped Tiling. Part III: Tiling for Distributed-Memory Machines. 5. SPMD Code Generation. 6. Communication-Minimal Tiling. 7. Time-Minimal Tiling. Bibliography. Index."
            },
            "slug": "Loop-Tiling-for-Parallelism-Xue",
            "title": {
                "fragments": [],
                "text": "Loop Tiling for Parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "This chapter discusses tiling for Distributed-Memory Machines, which has applications in SPMD Code Generation and Nonsingular Transformations and Permutability, and tiling as a Loop Transformation."
            },
            "venue": {
                "fragments": [],
                "text": "Kluwer International Series in Engineering and Computer Science"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1689196"
                        ],
                        "name": "A. Schrijver",
                        "slug": "A.-Schrijver",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Schrijver",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Schrijver"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 29180149,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "3ce2d233cee585ecff73729836918ba87195c18f",
            "isKey": false,
            "numCitedBy": 4874,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Introduction and Preliminaries. Problems, Algorithms, and Complexity. LINEAR ALGEBRA. Linear Algebra and Complexity. LATTICES AND LINEAR DIOPHANTINE EQUATIONS. Theory of Lattices and Linear Diophantine Equations. Algorithms for Linear Diophantine Equations. Diophantine Approximation and Basis Reduction. POLYHEDRA, LINEAR INEQUALITIES, AND LINEAR PROGRAMMING. Fundamental Concepts and Results on Polyhedra, Linear Inequalities, and Linear Programming. The Structure of Polyhedra. Polarity, and Blocking and Anti--Blocking Polyhedra. Sizes and the Theoretical Complexity of Linear Inequalities and Linear Programming. The Simplex Method. Primal--Dual, Elimination, and Relaxation Methods. Khachiyana s Method for Linear Programming. The Ellipsoid Method for Polyhedra More Generally. Further Polynomiality Results in Linear Programming. INTEGER LINEAR PROGRAMMING. Introduction to Integer Linear Programming. Estimates in Integer Linear Programming. The Complexity of Integer Linear Programming. Totally Unimodular Matrices: Fundamental Properties and Examples. Recognizing Total Unimodularity. Further Theory Related to Total Unimodularity. Integral Polyhedra and Total Dual Integrality. Cutting Planes. Further Methods in Integer Linear Programming. References. Indexes."
            },
            "slug": "Theory-of-linear-and-integer-programming-Schrijver",
            "title": {
                "fragments": [],
                "text": "Theory of linear and integer programming"
            },
            "venue": {
                "fragments": [],
                "text": "Wiley-Interscience series in discrete mathematics and optimization"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145552986"
                        ],
                        "name": "Y. Robert",
                        "slug": "Y.-Robert",
                        "structuredName": {
                            "firstName": "Yves",
                            "lastName": "Robert",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Robert"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "41070781"
                        ],
                        "name": "F. Vivien",
                        "slug": "F.-Vivien",
                        "structuredName": {
                            "firstName": "Fr\u00e9d\u00e9ric",
                            "lastName": "Vivien",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Vivien"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 100,
                                "start": 80
                            }
                        ],
                        "text": "Our approach is thus a departure from scheduling-based approaches in this field [20, 21, 17, 24, 15] as well as partitioning-based approaches [37, 36, 35] (due to incorporation of more concrete optimization criteria), however, is built on the same mathematical foundations and machinery."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 5208148,
            "fieldsOfStudy": [
                "Business"
            ],
            "id": "a3af5a000bdb8a0c6b59597e6367e8613812dce5",
            "isKey": false,
            "numCitedBy": 190,
            "numCiting": 92,
            "paperAbstract": {
                "fragments": [],
                "text": "I Unidimensional Problems.- 1 Scheduling DAGs without Communications.- 2 Scheduling DAGs with Communications.- 3 Cyclic Scheduling.- II Multidimensional Problems.- 4 Systems of Uniform Recurrence Equations.- 5 Parallelism Detection in Nested Loops."
            },
            "slug": "Scheduling-and-Automatic-Parallelization-Darte-Robert",
            "title": {
                "fragments": [],
                "text": "Scheduling and Automatic Parallelization"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "Scheduling DAGs without Communications, Parallelism Detection in Nested Loops, and Systems of Uniform Recurrence Equations."
            },
            "venue": {
                "fragments": [],
                "text": "Birkh\u00e4user Boston"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3050922"
                        ],
                        "name": "Corinne Ancourt",
                        "slug": "Corinne-Ancourt",
                        "structuredName": {
                            "firstName": "Corinne",
                            "lastName": "Ancourt",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Corinne Ancourt"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912411"
                        ],
                        "name": "F. Irigoin",
                        "slug": "F.-Irigoin",
                        "structuredName": {
                            "firstName": "Fran\u00e7ois",
                            "lastName": "Irigoin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Irigoin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 56,
                                "start": 49
                            }
                        ],
                        "text": "Our tiled code gen\u00aderation scheme uses Ancourt andIrigoin s [4] \nclassic approach to specify domains with .xed tile sizes and shape information, but combines it with \nCloog s support for scattering functions to al\u00adlow generation of tiled code for multiple domains under \nthe com\u00adputed transformations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 150,
                                "start": 147
                            }
                        ],
                        "text": "The domain supplied to the code generator is a higher dimensional domain with the tile shape constraints like that proposed by Ancourt and Irigoin [4]; but the scatterings are duplicated for the tile space too."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 63,
                                "start": 60
                            }
                        ],
                        "text": "Our tiled code generation scheme uses Ancourt and Irigoin\u2019s [4] classic approach to specify domains with fixed tile sizes and shape information, but combines it with CLooG\u2019s support for scattering functions to allow generation of tiled code for multiple domains under the computed transformations."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 7,
                                "start": 0
                            }
                        ],
                        "text": "Irigoin."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 81,
                                "start": 74
                            }
                        ],
                        "text": "Pe (2) The above is a generalization of the classic condition proposed by Irigoin \nand Triolet [28] (as hT ."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 84,
                                "start": 81
                            }
                        ],
                        "text": "[23] reported an alternate tiled code generation scheme to Ancourt and Irigoin\u2019s [4]) to address the inefficiency involved in using Fourier-Motzkin elimination \u2013 however, this is no longer an issue as the state-of-the-art uses efficient algorithms [47, 6] based on PolyLib [57, 42] and its implementation of the Chernikova algorithm [33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 146,
                                "start": 127
                            }
                        ],
                        "text": "The domain \nsupplied to the code generator is a higher dimensional domain with the tile shape constraints like that \nproposed by Ancourt and Irigoin [4]; but the scatterings are duplicated for the tile space too."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 14,
                                "start": 7
                            }
                        ],
                        "text": "[28]F. IrigoinandR."
                    },
                    "intents": []
                }
            ],
            "corpusId": 1469859,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6f4f362af709c2890db6c6f920d0b565c91b4521",
            "isKey": true,
            "numCitedBy": 376,
            "numCiting": 32,
            "paperAbstract": {
                "fragments": [],
                "text": "HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L\u2019archive ouverte pluridisciplinaire HAL, est destin\u00e9e au d\u00e9p\u00f4t et \u00e0 la diffusion de documents scientifiques de niveau recherche, publi\u00e9s ou non, \u00e9manant des \u00e9tablissements d\u2019enseignement et de recherche fran\u00e7ais ou \u00e9trangers, des laboratoires publics ou priv\u00e9s. Scanning polyhedra with DO loops Corinne Ancourt, Fran\u00e7ois Irigoin"
            },
            "slug": "Scanning-polyhedra-with-DO-loops-Ancourt-Irigoin",
            "title": {
                "fragments": [],
                "text": "Scanning polyhedra with DO loops"
            },
            "tldr": {
                "abstractSimilarityScore": 90,
                "text": "HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not, for teaching and research institutions in France or abroad, or from public or private research centers."
            },
            "venue": {
                "fragments": [],
                "text": "PPOPP '91"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "150124301"
                        ],
                        "name": "H. Le Verge",
                        "slug": "H.-Le-Verge",
                        "structuredName": {
                            "firstName": "H.",
                            "lastName": "Le Verge",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Le Verge"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 77,
                                "start": 73
                            }
                        ],
                        "text": "CLooG uses PolyLib [57, 42] (which in turn uses the Chernikova algorithm [33]) for its core operations, and the code generated is far more efficient than that by older code generators based on FourierMotzkin variable elimination like Omega Codegen [46] or LooPo\u2019s internal code generator [25, 24])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 337,
                                "start": 333
                            }
                        ],
                        "text": "[23] reported an alternate tiled code generation scheme to Ancourt and Irigoin\u2019s [4]) to address the inefficiency involved in using Fourier-Motzkin elimination \u2013 however, this is no longer an issue as the state-of-the-art uses efficient algorithms [47, 6] based on PolyLib [57, 42] and its implementation of the Chernikova algorithm [33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 14014078,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "9c8f9215de4cb4592dffb4fdaa18538905270325",
            "isKey": false,
            "numCitedBy": 108,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes an implementation of Chernikova's algorithm for nding an irredundant set of vertices for a given polyhedron de-ned by a set of linear inequalities and equations. This algorithm can also be used for the dual problem: given a set of extremal rays and vertices, nd the associated irredundant set of facet supporting hyper-planes. The method is an extension of initial Chernikova's algorithm (nonnegative domain), and is mainly based on the polyhedral cone duality principle. A new enhancement for extremal ray detection is presented together with its eeects on a class of polyedra."
            },
            "slug": "A-Note-on-Chernikova's-Algorithm-Verge",
            "title": {
                "fragments": [],
                "text": "A Note on Chernikova's Algorithm"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2776445"
                        ],
                        "name": "H. L. Verge",
                        "slug": "H.-L.-Verge",
                        "structuredName": {
                            "firstName": "Herv\u00e9",
                            "lastName": "Verge",
                            "middleNames": [
                                "Le"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. L. Verge"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 123651003,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "a75801c45a43e4db7bd3dfb804a89649807dced6",
            "isKey": false,
            "numCitedBy": 88,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes an implementation of Chernikova's algorithm for finding an irredundant set of vertices for a given polyhedron defined by a set of linear inequalities and equations. This algorithm can also be used for the dual problem : given a set of extremal rays and vertices, find the associated irredundant set of facet supporting hyperplanes. The method is an extension of initial Chernikova's algorithm (non negative domain) and is mainly based on the polyhedral cone duality principle. A new en hancement for extremal ray detection is presented together with its effects on a class of polyedra."
            },
            "slug": "A-Note-on-Chernikova's-algorithm-Verge",
            "title": {
                "fragments": [],
                "text": "A Note on Chernikova's algorithm"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 58913364,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "d6613b9ca5b21506b56b004be7593d9d40fb84da",
            "isKey": false,
            "numCitedBy": 472,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "L'analyse semantique des programmes informatiques conduit a la resolution de problemes de programmation parametrique entiere. L'article s'est ainsi consacre a la construction d'un algorithme de ce type"
            },
            "slug": "Parametric-integer-programming-Feautrier",
            "title": {
                "fragments": [],
                "text": "Parametric integer programming"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 91,
                                "start": 87
                            }
                        ],
                        "text": "The above is a generalization of the classic condition proposed by Irigoin and Triolet [28] (as h ."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 39,
                                "start": 23
                            }
                        ],
                        "text": "Iteration space tiling [28, 58, 48, 61] is a standard approach for aggregating a set of loop iterations into tiles, with each tile being executed atomically."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 74
                            }
                        ],
                        "text": "Pe (2) The above is a generalization of the classic condition proposed by Irigoin \nand Triolet [28] (as hT ."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 7,
                                "start": 0
                            }
                        ],
                        "text": "Triolet."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 19,
                                "start": 7
                            }
                        ],
                        "text": "Tiling [28, 58, 61] is a key transformation in optimizing for parallelism and data locality."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Triolet. Supernode partitioning"
            },
            "venue": {
                "fragments": [],
                "text": "In ACM SIGPLAN PoPL, pages 319\u2013329,"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1977944"
                        ],
                        "name": "Sebastian Pop",
                        "slug": "Sebastian-Pop",
                        "structuredName": {
                            "firstName": "Sebastian",
                            "lastName": "Pop",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sebastian Pop"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2506136"
                        ],
                        "name": "Sylvain Girbal",
                        "slug": "Sylvain-Girbal",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Girbal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Girbal"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "100846812"
                        ],
                        "name": "G. Silber",
                        "slug": "G.-Silber",
                        "structuredName": {
                            "firstName": "G.",
                            "lastName": "Silber",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Silber"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 237,
                                "start": 233
                            }
                        ],
                        "text": "The polyhedral model pro\u00advides a powerful abstraction to reason about transformations on such loop nests \nby viewing a dynamic instance (iteration) of each statement as an integer point in a well-de.ned space \ncalled the statement s polyhedron."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 114678484,
            "fieldsOfStudy": [
                "Materials Science"
            ],
            "id": "b78e3bd52a3b9f208702faac88e0e74ed03b6257",
            "isKey": false,
            "numCitedBy": 49,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "GRAPHITE:-Loop-Optimizations-Based-on-the-Model-for-Pop-Cohen",
            "title": {
                "fragments": [],
                "text": "GRAPHITE: Loop Optimizations Based on the Polyhedral Model for GCC"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "10214063"
                        ],
                        "name": "M. E. Wolf",
                        "slug": "M.-E.-Wolf",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolf",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. E. Wolf"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 127,
                                "start": 123
                            }
                        ],
                        "text": "The transformations .nally re.ect in the generated code as reordered execution with improved \ncache locality and/or loops that havebeen parallelized."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 12283423,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c1e3938cc4110cd6cedf33452b925ba79e85573e",
            "isKey": false,
            "numCitedBy": 491,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper proposes an algorithm that improves the locality of a loop nest by transforming the code via interchange, reversal, skewing and tiling. The loop transformation algorithm is based on two concepts: a mathematical formulation of reuse and locality, and a loop transformation theory that unifies the various transforms as unimodular matrix transformations.The algorithm has been implemented in the SUIF (Stanford University Intermediate Format) compiler, and is successful in optimizing codes such as matrix multiplication, successive over-relaxation (SOR), LU decomposition without pivoting, and Givens QR factorization. Performance evaluation indicates that locality optimization is especially crucial for scaling up the performance of parallel code."
            },
            "slug": "A-data-locality-optimizing-algorithm-Lam-Wolf",
            "title": {
                "fragments": [],
                "text": "A data locality optimizing algorithm"
            },
            "tldr": {
                "abstractSimilarityScore": 63,
                "text": "An algorithm that improves the locality of a loop nest by transforming the code via interchange, reversal, skewing and tiling is proposed, and is successful in optimizing codes such as matrix multiplication, successive over-relaxation, LU decomposition without pivoting, and Givens QR factorization."
            },
            "venue": {
                "fragments": [],
                "text": "SIGP"
            },
            "year": 2004
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 141
                            }
                        ],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 39,
                                "start": 23
                            }
                        ],
                        "text": "Iteration space tiling [28, 58, 48, 61] is a standard approach for aggregating a set of loop iterations into tiles, with each tile being executed atomically."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Tiling multidimensional iteration spaces for multicomputers"
            },
            "venue": {
                "fragments": [],
                "text": "JPDC"
            },
            "year": 1992
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "PolyLib -A library of polyhedral functions. http://icps.u-strasbg.fr/polylib"
            },
            "venue": {
                "fragments": [],
                "text": "PolyLib -A library of polyhedral functions. http://icps.u-strasbg.fr/polylib"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 141
                            }
                        ],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Optimal semioblique tiling"
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Par. & Dist. Sys"
            },
            "year": 2003
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 131,
                                "start": 127
                            }
                        ],
                        "text": "Additional experimental results and comments about the optimized codes and transformations are available in an extended report [10]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 89
                            }
                        ],
                        "text": "Analysis of cache misses with each of the schemes is presented in a more detailed report [10]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Pluto: A practical and fully automatic polyhedral parallelizer and locality optimizer"
            },
            "venue": {
                "fragments": [],
                "text": "Pluto: A practical and fully automatic polyhedral parallelizer and locality optimizer"
            },
            "year": 2007
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[39] to perform syntactic transformations on the code generated from Cloog as a post-processing; these include register tiling followed by unrolling or unroll/jamming."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Annotations for performance and productivity"
            },
            "venue": {
                "fragments": [],
                "text": "Annotations for performance and productivity"
            },
            "year": 2007
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Dataflow analysis of scalar and array references"
            },
            "venue": {
                "fragments": [],
                "text": "Intl. J. of Parallel Programming"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "CLooG: The Chunky Loop Generator"
            },
            "venue": {
                "fragments": [],
                "text": "CLooG: The Chunky Loop Generator"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 131,
                                "start": 127
                            }
                        ],
                        "text": "The performance of the optimized stencil codes through our system is already comparable to hand optimized versions reported in [29]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Implicit and explicit optimization for stencil computations"
            },
            "venue": {
                "fragments": [],
                "text": "ACM SIGPLAN workshop on Memory Systems Perofmance and Correctness"
            },
            "year": 2006
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 130,
                                "start": 126
                            }
                        ],
                        "text": "Based on the description of the heuristic approach to minimizing reuse distances [2], it would appear that it is not scalable [53]."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Scalable Program Optimization Techniques in the Polyhedral Model"
            },
            "venue": {
                "fragments": [],
                "text": "Scalable Program Optimization Techniques in the Polyhedral Model"
            },
            "year": 2007
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "PLuTo: A polyhedral automatic parallelizer and locality optimizer for multicores"
            },
            "venue": {
                "fragments": [],
                "text": "PLuTo: A polyhedral automatic parallelizer and locality optimizer for multicores"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 141
                            }
                        ],
                        "text": "Researchers have considered the problem of selecting tile shape and size to minimize communication, improve locality or minimize finish time [5, 11, 26, 27, 48, 50, 60]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Pen)-ultimate tiling? Integration, the VLSI Journal"
            },
            "venue": {
                "fragments": [],
                "text": "Pen)-ultimate tiling? Integration, the VLSI Journal"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "PIP: The Parametric Integer Programming Library"
            },
            "venue": {
                "fragments": [],
                "text": "PIP: The Parametric Integer Programming Library"
            }
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 30,
            "methodology": 13
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 71,
        "totalPages": 8
    },
    "page_url": "https://www.semanticscholar.org/paper/A-practical-automatic-polyhedral-parallelizer-and-Bondhugula-Hartono/f0f4757aa2f923a349e8357e73850a78e9b80fee?sort=total-citations"
}