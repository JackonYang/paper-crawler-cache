{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144005858"
                        ],
                        "name": "W. Shang",
                        "slug": "W.-Shang",
                        "structuredName": {
                            "firstName": "Weijia",
                            "lastName": "Shang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Shang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144371682"
                        ],
                        "name": "J. Fortes",
                        "slug": "J.-Fortes",
                        "structuredName": {
                            "firstName": "Jos\u00e9",
                            "lastName": "Fortes",
                            "middleNames": [
                                "A.",
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Fortes"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 49,
                                "start": 45
                            }
                        ],
                        "text": "As an example, consider the following problem(31): find a causal schedule for"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 39051311,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "26fc23f372f1a52b69c4cfae8d110996f47b3bdb",
            "isKey": false,
            "numCitedBy": 166,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "The problem of identifying the time-optimal linear schedules for uniform dependence algorithms with any convex-polyhedron index set is addressed. Optimization procedures are proposed, and the class of algorithms is identified for which the total execution times by the optimal linear schedule and the free schedule that schedules the computation to execute as soon as its operands are available are equal. This method is useful in mapping algorithms onto systolic/MIMD (multiple-instruction, multiple-instruction stream) systems.<<ETX>>"
            },
            "slug": "Time-optimal-linear-schedules-for-algorithms-with-Shang-Fortes",
            "title": {
                "fragments": [],
                "text": "Time optimal linear schedules for algorithms with uniform dependencies"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "Optimal linear schedules for uniform dependence algorithms with any convex-polyhedron index set are addressed and a class of algorithms is identified for which the total execution times by the optimal linear schedule and the free schedule that schedules the computation to execute as soon as its operands are available are equal."
            },
            "venue": {
                "fragments": [],
                "text": "[1988] Proceedings. International Conference on Systolic Arrays"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145205522"
                        ],
                        "name": "C. Mauras",
                        "slug": "C.-Mauras",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Mauras",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Mauras"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144803177"
                        ],
                        "name": "P. Quinton",
                        "slug": "P.-Quinton",
                        "structuredName": {
                            "firstName": "Patrice",
                            "lastName": "Quinton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Quinton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747659"
                        ],
                        "name": "S. Rajopadhye",
                        "slug": "S.-Rajopadhye",
                        "structuredName": {
                            "firstName": "Sanjay",
                            "lastName": "Rajopadhye",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Rajopadhye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2907155"
                        ],
                        "name": "Y. Saouter",
                        "slug": "Y.-Saouter",
                        "structuredName": {
                            "firstName": "Yannick",
                            "lastName": "Saouter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Saouter"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "An example with its DFG is given in Fig. 9. The reader may care to verify, as a straightforward application of our methods, that linear program ( 30 ) for that example is unfeasible."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 122553522,
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "id": "a4aad18dcbdfcdfb7ba338b9a5451d07bb394d6e",
            "isKey": false,
            "numCitedBy": 44,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "We present new scheduling techniques for systems of affine recurrence equations. We show that it is possible to extend earlier results on affine scheduling to the case when each variable of the system is scheduled independently of the others by an affine timing-function. This new technique makes it possible to analyze systems of recurrence equations with variables in different index spaces, and multi-step systolic algorithms. We illustrate our method on dynamic programming, LU decomposition and 2D conv& lution."
            },
            "slug": "Scheduling-affine-parameterized-recurrences-by-of-Mauras-Quinton",
            "title": {
                "fragments": [],
                "text": "Scheduling affine parameterized recurrences by means of variable dependent timing functions"
            },
            "tldr": {
                "abstractSimilarityScore": 72,
                "text": "It is shown that it is possible to extend earlier results on affine scheduling to the case when each variable of the system is scheduled independently of the others by an affine timing-function, which makes it possible to analyze systems of recurrence equations with variables in different index spaces, and multi-step systolic algorithms."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144803177"
                        ],
                        "name": "P. Quinton",
                        "slug": "P.-Quinton",
                        "structuredName": {
                            "firstName": "Patrice",
                            "lastName": "Quinton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Quinton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8910550"
                        ],
                        "name": "V. V. Dongen",
                        "slug": "V.-V.-Dongen",
                        "structuredName": {
                            "firstName": "Vincent",
                            "lastName": "Dongen",
                            "middleNames": [
                                "Van"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. V. Dongen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15049061,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "4961ed921db492418491635c9127802fc3b0b44a",
            "isKey": false,
            "numCitedBy": 238,
            "numCiting": 58,
            "paperAbstract": {
                "fragments": [],
                "text": "The parallelization of many algorithms can be obtained using space-time transformations which are applied on nested do-loops or on recurrence equations. In this paper, we analyze systems of linear recurrence equations, a generalization of uniform recurrence equations. The first part of the paper describes a method for finding automatically whether such a system can be scheduled by an affine timing function, independent of the size parameter of the algorithm. In the second part, we describe a powerful method that makes it possible to transform linear recurrences into uniform recurrence equations. Both parts rely on results on integral convex polyhedra. Our results are illustrated on the Gauss elimination algorithm and on the Gauss-Jordan diagonalization algorithm."
            },
            "slug": "The-mapping-of-linear-recurrence-equations-on-Quinton-Dongen",
            "title": {
                "fragments": [],
                "text": "The mapping of linear recurrence equations on regular arrays"
            },
            "tldr": {
                "abstractSimilarityScore": 48,
                "text": "A method for finding automatically whether such a system can be scheduled by an affine timing function, independent of the size parameter of the algorithm, and a powerful method that makes it possible to transform linear recurrences into uniform recurrence equations are described."
            },
            "venue": {
                "fragments": [],
                "text": "J. VLSI Signal Process."
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33568065"
                        ],
                        "name": "D. Baxter",
                        "slug": "D.-Baxter",
                        "structuredName": {
                            "firstName": "Doug",
                            "lastName": "Baxter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Baxter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1696458"
                        ],
                        "name": "R. Mirchandaney",
                        "slug": "R.-Mirchandaney",
                        "structuredName": {
                            "firstName": "Ravi",
                            "lastName": "Mirchandaney",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Mirchandaney"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46934873"
                        ],
                        "name": "J. Saltz",
                        "slug": "J.-Saltz",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Saltz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Saltz"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Applying this method to the above example again gives the solution of Eq. ( 23 ), with a latency L = n + 1."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "One verifies that each operation which has no predecessor in the extended DFG is scheduled at time 0, and that for other operions, one of the delays at least is equal to 1. The reader may be interested in checking in this way that schedule in Eq. ( 23 ) is the free schedule of program 1, while Eq. (45) is not the free schedule of program 8."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "In the case of the example, one will directly obtain the solution of Eq. ( 23 )."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "In the case of the kernel in Fig. 1, one again obtains Eq. ( 23 )."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Application of this method to the program of Fig. 1 will again give Eq. ( 23 )."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Another use is in runtime parallelization, ( 23 ) in which a schedule is computed according to Eq. (6) by a so-called inspector loop, then exploited for the actual parallel execution of the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5342029,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6faf65acb8e0ae69e8c6c79ca36788df0a98901d",
            "isKey": true,
            "numCitedBy": 248,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract : This paper extends the class of problems that can be effectively compiled by parallelizing compilers. This is accomplished with the doconsider construct which would allow these compilers to parallelize many problems in which substantial loop-level parallelism is available but cannot be detected by standard compile-time analysis. The authors describe the experimentally analyze mechanisms used to parallelize the work required for these types of loops. In each of these methods, a new loop structure is produced by modifying the loop to be parallelized. Also presented are the rules by which these loop transformations may be automated in order that they be included in language compilers. The main application area of our research involves problems in scientific computations and engineering. The workload used in the experiments includes a mixture of real problems as well as synthetically generated inputs. From extensive tests on the Encore Multimax/320, the authors have reached the conclusion that for the types of workloads we have investigated, self-execution almost always performs better than pre-scheduling. Further, the improvement in performance that accrues as a result of global topological sorting of indices as opposed to the less expensive local sorting, is not very significant in the case of self-execution."
            },
            "slug": "Run-time-parallelization-and-scheduling-of-loops-Baxter-Mirchandaney",
            "title": {
                "fragments": [],
                "text": "Run-time parallelization and scheduling of loops"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "The authors have reached the conclusion that for the types of workloads they have investigated, self-execution almost always performs better than pre-scheduling and the improvement in performance that accrues as a result of global topological sorting of indices as opposed to the less expensive local sorting, is not very significant in the case of self-Execution."
            },
            "venue": {
                "fragments": [],
                "text": "SPAA '89"
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(1), then L0] is an integral solution to the same scheduling problem."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(1) into a set of inequalities whose size does no longer depend on the program complexity."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(1) are linear in z and e, and one has to solve a linear programming problem."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(1) must be imposed between (R, x) and (S, y ) i f f ( x , y ) ~ ."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(1) which corresponds to this hypothesis is:"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(1) by a few linear constraints with the help of a classical result of the theory of linear inequalities, the affine form of Farkas Lemma, and how to solve these constraints for an efficient schedule, efficiency being defined in several ways."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 17754865,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "94db9b5d42d8c77af57bdd44fc53d2949e90464e",
            "isKey": false,
            "numCitedBy": 11,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper gives a general method for the construction of parallel algorithms. Starting from a conventional sequential program, one rst constructs a timing function, i.e. a schedule for a paracomputer. It is shown that the ratio of the maximum value of the timing function to the total operation count is a good measure of the degree of parallelism in the original algorithm. In particular, if this ratio tends to zero when the operation count grows large, then there is an asymptotically eecient parallel version of the original algorithm. This implementation is shown to be surprisingly robust in the face of variations, random and otherwise, of the operation execution times. The technique may be used as the starting point of the construction of programs for all kinds of parallel computers: vector, synchronous, asynchronous and distributed architectures."
            },
            "slug": "Asymptotically-Efficient-Algorithms-for-Parallel-Feautrier",
            "title": {
                "fragments": [],
                "text": "Asymptotically Efficient Algorithms for Parallel Architectures"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "This paper gives a general method for the construction of parallel algorithms, starting from a conventional sequential program, and shows that the ratio of the maximum value of the timing function to the total operation count is a good measure of the degree of parallelism in the original algorithm."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144616193"
                        ],
                        "name": "R. Allen",
                        "slug": "R.-Allen",
                        "structuredName": {
                            "firstName": "Randy",
                            "lastName": "Allen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 3102993,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f3d2ab514353cb80c2ea6504f05374d4549b26c6",
            "isKey": false,
            "numCitedBy": 57,
            "numCiting": 56,
            "paperAbstract": {
                "fragments": [],
                "text": "Parallel and vector machines are becoming increasingly important to many computation intensive applications. Effectively utilizing such architectures, particularly from sequential languages such as Fortran, has demanded increasingly sophisticated compilers. In general, a compiler needs to significantly reorder a program in order to generate code optimal for a specific architecture.Because DO loops typically control the execution of a number of statements, the order in which loops are executed can dramatically affect the performance of a machine on a particular section of code. In particular, loop interchange can often be used to enhance the performance of code on parallel or vector machines.Determining when loops may be safely and profitably interchanged requires a study of the data dependences in the program. This work discusses specific applications of that theory to loop interchange. This theory is described as it has been implemented in PFC (Parallel Fortran Converter) -- a program which attempts to uncover operations in sequential Fortran code that may be safely rewritten as vector operations."
            },
            "slug": "Automatic-loop-interchange-Allen-Kennedy",
            "title": {
                "fragments": [],
                "text": "Automatic loop interchange"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Specific applications of that theory to loop interchange are discussed as it has been implemented in PFC (Parallel Fortran Converter) -- a program which attempts to uncover operations in sequential Fortran code that may be safely rewritten as vector operations."
            },
            "venue": {
                "fragments": [],
                "text": "SIGP"
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145552986"
                        ],
                        "name": "Y. Robert",
                        "slug": "Y.-Robert",
                        "structuredName": {
                            "firstName": "Yves",
                            "lastName": "Robert",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Robert"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 1428972,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e8b606391c6eaf78d1f70bb3c3961f291964002a",
            "isKey": false,
            "numCitedBy": 67,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Mapping-Uniform-Loop-Nests-Onto-Distributed-Memory-Darte-Robert",
            "title": {
                "fragments": [],
                "text": "Mapping Uniform Loop Nests Onto Distributed Memory Architectures"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Comput."
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "10214063"
                        ],
                        "name": "M. E. Wolf",
                        "slug": "M.-E.-Wolf",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Wolf",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. E. Wolf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 39618367,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5d80427dd880159b32cb3a84942ed132debd1df3",
            "isKey": false,
            "numCitedBy": 749,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "An approach to transformations for general loops in which dependence vectors represent precedence constraints on the iterations of a loop is presented. Therefore, dependences extracted from a loop nest must be lexicographically positive. This leads to a simple test for legality of compound transformations: any code transformation that leaves the dependences lexicographically positive is legal. The loop transformation theory is applied to the problem of maximizing the degree of coarse- or fine-grain parallelism in a loop nest. It is shown that the maximum degree of parallelism can be achieved by transforming the loops into a nest of coarsest fully permutable loop nests and wavefronting the fully permutable nests. The canonical form of coarsest fully permutable nests can be transformed mechanically to yield maximum degrees of coarse- and/or fine-grain parallelism. The efficient heuristics can find the maximum degrees of parallelism for loops whose nesting level is less than five. >"
            },
            "slug": "A-Loop-Transformation-Theory-and-an-Algorithm-to-Wolf-Lam",
            "title": {
                "fragments": [],
                "text": "A Loop Transformation Theory and an Algorithm to Maximize Parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The loop transformation theory is applied to the problem of maximizing the degree of coarse- or fine-grain parallelism in a loop nest and it is shown that the maximum degree of parallelism can be achieved by transforming the loops into a nest of coarsest fullypermutable loop nests and wavefronting the fully permutable nests."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Trans. Parallel Distributed Syst."
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1747659"
                        ],
                        "name": "S. Rajopadhye",
                        "slug": "S.-Rajopadhye",
                        "structuredName": {
                            "firstName": "Sanjay",
                            "lastName": "Rajopadhye",
                            "middleNames": [
                                "V."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Rajopadhye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1721009"
                        ],
                        "name": "R. Fujimoto",
                        "slug": "R.-Fujimoto",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Fujimoto",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Fujimoto"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 36659389,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ea514dec6af4b8d2ab62ad01edc56e1a19a84596",
            "isKey": false,
            "numCitedBy": 96,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Synthesizing-systolic-arrays-from-recurrence-Rajopadhye-Fujimoto",
            "title": {
                "fragments": [],
                "text": "Synthesizing systolic arrays from recurrence equations"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Comput."
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2776445"
                        ],
                        "name": "H. L. Verge",
                        "slug": "H.-L.-Verge",
                        "structuredName": {
                            "firstName": "Herv\u00e9",
                            "lastName": "Verge",
                            "middleNames": [
                                "Le"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. L. Verge"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145205522"
                        ],
                        "name": "C. Mauras",
                        "slug": "C.-Mauras",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Mauras",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Mauras"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144803177"
                        ],
                        "name": "P. Quinton",
                        "slug": "P.-Quinton",
                        "structuredName": {
                            "firstName": "Patrice",
                            "lastName": "Quinton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Quinton"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 36205240,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0cdb2a38b728659b3fb50f50f4cfe446dfccd8b7",
            "isKey": false,
            "numCitedBy": 122,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": "The ALPHA language results from research on automatic synthesis of systolic algorithms. It is based on the recurrence equation formalism introduced by Karp, Miller and Winograd in 1967. The basic objects of ALPHA are variables indexed on integral points of a convex set. It is a functional/equational language, whose definition is particularly well-suited to express regular algorithms, as well as transformations of these algorithms from their initial mathematical specification to an implementation on a synchronous parallel architecture. In particular, ALPHA makes it easy to define, prove and implement basic transformations such as Leiserson and Saxe's retiming, space-time reindexing, localization, and partitioning.We describe ALPHA, its use for expressing and deriving systolic arrays, and the design environment ALPHA DU CENTAUR for this language."
            },
            "slug": "The-ALPHA-language-and-its-use-for-the-design-of-Verge-Mauras",
            "title": {
                "fragments": [],
                "text": "The ALPHA language and its use for the design of systolic arrays"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "ALPHA is a functional/equational language, whose definition is particularly well-suited to express regular algorithms, as well as transformations of these algorithms from their initial mathematical specification to an implementation on a synchronous parallel architecture."
            },
            "venue": {
                "fragments": [],
                "text": "J. VLSI Signal Process."
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2907155"
                        ],
                        "name": "Y. Saouter",
                        "slug": "Y.-Saouter",
                        "structuredName": {
                            "firstName": "Yannick",
                            "lastName": "Saouter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Saouter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144803177"
                        ],
                        "name": "P. Quinton",
                        "slug": "P.-Quinton",
                        "structuredName": {
                            "firstName": "Patrice",
                            "lastName": "Quinton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Quinton"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(25) at all vertices, and as a consequence, everywhere in ~s."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 48,
                                "start": 44
                            }
                        ],
                        "text": "n + k such that VS, x ~ ~s: L - O(S, x)>~ 0 (25)"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(25) implies the existence of positive numbers VSk such that:"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 13575542,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "5c5894159e8c3d091957f506ed96514a1a7528f6",
            "isKey": true,
            "numCitedBy": 41,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Computability-of-recurrence-equations-Saouter-Quinton",
            "title": {
                "fragments": [],
                "text": "Computability of recurrence equations"
            },
            "venue": {
                "fragments": [],
                "text": "Theor. Comput. Sci."
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37924444"
                        ],
                        "name": "Michael L. Dowling",
                        "slug": "Michael-L.-Dowling",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Dowling",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael L. Dowling"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 44890946,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "210022c0eb2d5e1d602fd20f2f0c59a49ff88f5d",
            "isKey": false,
            "numCitedBy": 55,
            "numCiting": 5,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Optimal-code-parallelization-using-unimodular-Dowling",
            "title": {
                "fragments": [],
                "text": "Optimal code parallelization using unimodular transformations"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Comput."
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1768785"
                        ],
                        "name": "W. Wadge",
                        "slug": "W.-Wadge",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Wadge",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Wadge"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2629665"
                        ],
                        "name": "E. Ashcroft",
                        "slug": "E.-Ashcroft",
                        "structuredName": {
                            "firstName": "Edward",
                            "lastName": "Ashcroft",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Ashcroft"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 58265579,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d9f1ac9c46a94408c8ed9bee7d3ac984ac27ee8b",
            "isKey": false,
            "numCitedBy": 73,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "LUCID is a new dataflow language. It was designed to exploit the capabilities of the coming generation of supercomputers - multi-processor ''dataflow'' machines which are (potentially) hundreds or thousands of times more powerful than conventional, single-processor ''von Neumann'' machines and which need languages in which highly parallel algorithms can be easily expressed. LUCID is a functional language, but one which supports variables, i.e., values which change with time. LUCID programmers can therefore use iteration (repetition) as well as recursion. The statements of a LUCID program are equations which can be thought of as defining a network of processors and communication lines. LUCID's dataflow approach to programming has more in common with that of the UNIX (TM) shell, with its filters and pipelines, than with the imperative, one-step-at-a-time approach of a conventional language like C or PASCAL. The primary objective of this book is to prove that Dataflow is a real alternative to sequential/imperative computing, and that dataflow algorithms can be expressed naturally and concisely in LUCID."
            },
            "slug": "LUCID:-The-data-flow-programming-language-Wadge-Ashcroft",
            "title": {
                "fragments": [],
                "text": "LUCID: The data flow programming language"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "The primary objective of this book is to prove that Dataflow is a real alternative to sequential/imperative computing, and that dataflow algorithms can be expressed naturally and concisely in LUCID."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1985
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35157982"
                        ],
                        "name": "L. Lu",
                        "slug": "L.-Lu",
                        "structuredName": {
                            "firstName": "Lee-Chung",
                            "lastName": "Lu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Lu"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Hence, if an inequality ~b(x) ~> 0 is satisfied at all points of a set ~ it is also satisfied at all points of the convex hull of @. Equations ( 8 ) ~)r (9) must be verified at all integral points inside a polyhedron ~e. As a consequence, they are satisfied at all points of the convex hull of the set of integral points of ~e--the so-called ,integer hull of ~e. But the integer hull of a polyhedron is not necessarily equal to the polyhedron ..."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "\ufffd9 Write instances of Eq. ( 8 ) at all vertices of ~e. Similarly, write instances of O(S, x) >i 0 at all vertices of ~s. \ufffd9 Solve the resulting finite system of linear inequalities by any standard algorithm."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "( 8 ) or (9) everywhere in the polyhedron is a pessimistic approach, which may eliminate some valid solutions but never give false results."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "For all these reasons, I will ignore the difficulty and proceed by relaxing the integrality constraints on vectors like x and y in Eq. ( 8 )."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "( 8 ) or (9), one gets systems of linear inequalities in the unknown coefficients."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "( 8 ) or (9) at each of these points, and solve for the unknown coefficients."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7326508,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "21f2e87d1cb7a9a52d90ae7b5533d83849e36881",
            "isKey": true,
            "numCitedBy": 33,
            "numCiting": 16,
            "paperAbstract": {
                "fragments": [],
                "text": "Abstract : This paper presents a formal mathematical framework which unifies the existing loop transformations. This framework also includes more general classes of loop transformations, which can extract more parallelism from a class of programs than the existing techniques. We classify schedules into three classes: uniform, subdomain-variant, and statement-variant. Viewing from the degree of parallelism to be gained by loop transformation, the schedules can also be classified as single-sequential level, multiple-sequential level, and mixed schedules. We also illustrate the usefulness of the more general loop transformation with an example program."
            },
            "slug": "A-unified-framework-for-systematic-loop-Lu",
            "title": {
                "fragments": [],
                "text": "A unified framework for systematic loop transformations"
            },
            "tldr": {
                "abstractSimilarityScore": 89,
                "text": "This paper presents a formal mathematical framework which unifies the existing loop transformations and includes more general classes of loop transformations, which can extract more parallelism from a class of programs than the existing techniques."
            },
            "venue": {
                "fragments": [],
                "text": "PPOPP '91"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733001"
                        ],
                        "name": "A. Darte",
                        "slug": "A.-Darte",
                        "structuredName": {
                            "firstName": "Alain",
                            "lastName": "Darte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Darte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1750104"
                        ],
                        "name": "L. Khachiyan",
                        "slug": "L.-Khachiyan",
                        "structuredName": {
                            "firstName": "Leonid",
                            "lastName": "Khachiyan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Khachiyan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145552986"
                        ],
                        "name": "Y. Robert",
                        "slug": "Y.-Robert",
                        "structuredName": {
                            "firstName": "Yves",
                            "lastName": "Robert",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Y. Robert"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 14370039,
            "fieldsOfStudy": [
                "Mathematics",
                "Computer Science"
            ],
            "id": "f45efd20d1d92c86887c148d9b6b4188b8b3f53f",
            "isKey": false,
            "numCitedBy": 88,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper deals with the problem of finding optimal schedulings for uniform dependence algorithms. Given a convex domain, let Tf be the total time needed to execute all computations using the free (greedy) schedule and let Tl be the total time needed to execute all computations using the optimal linear schedule. Our main result is to bound Tl/Tf and Tl \u2212 Tf for sufficiently \"fat\" domains."
            },
            "slug": "Linear-Scheduling-Is-Nearly-Optimal-Darte-Khachiyan",
            "title": {
                "fragments": [],
                "text": "Linear Scheduling Is Nearly Optimal"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "The main result is to bound Tl/Tf and Tl \u2212 Tf for sufficiently \"fat\" domains."
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Process. Lett."
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2108828527"
                        ],
                        "name": "Marina C. Chen",
                        "slug": "Marina-C.-Chen",
                        "structuredName": {
                            "firstName": "Marina",
                            "lastName": "Chen",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Marina C. Chen"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 18700374,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "661e856a488dea0f9506aaf8368ccf1f84dd801d",
            "isKey": false,
            "numCitedBy": 63,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": "A language <b>Crystal</b> and its compiler for parallel programming is presented. The goal of <b>Crystal</b> is to help programmers in seeking efficient parallel implementations of an algorithm, and managing the complexity that might arise in dealing with hundreds of thousands of autonomous parallel processes. In <b>Crystal,</b> a program consists of a system of recursion equations and is interpreted as a parallel system. <b>Crystal</b> views a large complex system as consisting of a hierarchy of parallel sub-systems, built upon a set of <b>Crystal</b> programs by composition and abstraction. There is no mention of explicit communications in a <b>Crystal</b> program. The <b>Crystal</b> compiler automatically incorporates pipelining into programs, and generates a parallel program that is optimal with respect to an algorithm. Each optimizing compiler, targeted for a particular machine, determines the appropriate granular size of parallelism and attains a balance between computations and communications. Based on the language, a unified theory for understanding and generating any systolic design has been devised and it constitues a part of the compiler."
            },
            "slug": "A-parallel-language-and-its-compilation-to-machines-Chen",
            "title": {
                "fragments": [],
                "text": "A parallel language and its compilation to multiprocessor machines or VLSI"
            },
            "tldr": {
                "abstractSimilarityScore": 53,
                "text": "A language and compiler for parallel programming and a unified theory for understanding and generating any systolic design has been devised and it constitues a part of the compiler."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '86"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 5738544,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7cd685371e267a499ded869a934a4cffed591aec",
            "isKey": false,
            "numCitedBy": 454,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "Given a program written in a simple imperative language (assignment statements,for loops, affine indices and loop limits), this paper presents an algorithm for analyzing the patterns along which values flow as the execution proceeds. For each array or scalar reference, the result is the name and iteration vector of the source statement as a function of the iteration vector of the referencing statement. The paper discusses several applications of the method: conversion of a program to a set of recurrence equations, array and scalar expansion, program verification and parallel program construction."
            },
            "slug": "Dataflow-analysis-of-array-and-scalar-references-Feautrier",
            "title": {
                "fragments": [],
                "text": "Dataflow analysis of array and scalar references"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "This paper presents an algorithm for analyzing the patterns along which values flow as the execution proceeds, and discusses several applications of the method: conversion of a program to a set of recurrence equations, array and scalar expansion, program verification and parallel program construction."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144022269"
                        ],
                        "name": "W. Pugh",
                        "slug": "W.-Pugh",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Pugh",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Pugh"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(7) will be nonnegative in the associated domain iff there exists Farkas multipliers #Sk such that:"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14351145,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "01f2893273d7e26dc38dea1069eea7f7314451f6",
            "isKey": false,
            "numCitedBy": 90,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": "Many different kinds of loop transformations have been described, such as loop interchange, loop skewing and loop fusion. Each transformation requires its own particular set of dependence analysis tests and paraltelizing a section of code may require perforfig a series of transformations. The only way to decide if there is a way of parallelizing a section of code is to try all possible sequences of transformations, which presents a difficult search problem. We present a uniform method of performing loop optimization. Rather than optimizing a program by performing a murky search through a series of transformations, our method considers a very powerful class of program transformations that includes any transformation that also can be obtained by any sequence of standard loop transformations. This optimization technique uniformly encompasses the effects of parallelization, loop fusion, loop splitting, loop interchange, loop skewing and statement reordering, as well as transformations not previously described. Thus, we only need to perform one program transformation. We show that standard techniques for representing dependencies (dependence directions and dependence distances) are insufficient for this type of optimization and describe a more powerful technique, dependence relations, that have sufficient descriptive power."
            },
            "slug": "Uniform-techniques-for-loop-optimization-Pugh",
            "title": {
                "fragments": [],
                "text": "Uniform techniques for loop optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "It is shown that standard techniques for representing dependencies (dependence directions and dependence distances) are insufficient for this type of optimization and described a more powerful technique, dependence relations, that have sufficient descriptive power."
            },
            "venue": {
                "fragments": [],
                "text": "ICS '91"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912411"
                        ],
                        "name": "F. Irigoin",
                        "slug": "F.-Irigoin",
                        "structuredName": {
                            "firstName": "Fran\u00e7ois",
                            "lastName": "Irigoin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Irigoin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3317184"
                        ],
                        "name": "R. Triolet",
                        "slug": "R.-Triolet",
                        "structuredName": {
                            "firstName": "R\u00e9mi",
                            "lastName": "Triolet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Triolet"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 2980454,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "38747b103e631e1a3800a0f4aed496d1bf8fb82f",
            "isKey": false,
            "numCitedBy": 584,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Supercompilers must reschedule computations defined by nested DO-loops in order to make an efficient use of supercomputer features (vector units, multiple elementary processors, cache memory, etc\u2026). Many rescheduling techniques like loop interchange, loop strip-mining or rectangular partitioning have been described to speedup program execution. We present here a class of partitionings that encompasses previous techniques and provides enough flexibility to adapt code to multiprocessors with two levels of parallelism and two levels of memory."
            },
            "slug": "Supernode-partitioning-Irigoin-Triolet",
            "title": {
                "fragments": [],
                "text": "Supernode partitioning"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A class of partitionings is presented that encompasses previous techniques and provides enough flexibility to adapt code to multiprocessors with two levels of parallelism and two level of memory."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '88"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1895532"
                        ],
                        "name": "L. Tesler",
                        "slug": "L.-Tesler",
                        "structuredName": {
                            "firstName": "Lawrence",
                            "lastName": "Tesler",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Tesler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1962099"
                        ],
                        "name": "H. Enea",
                        "slug": "H.-Enea",
                        "structuredName": {
                            "firstName": "Horace",
                            "lastName": "Enea",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Enea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 31923343,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "f5cff704fec71c6dd6cc2bda59a00186c360ea03",
            "isKey": false,
            "numCitedBy": 85,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "In conventional programming languages, the sequence of execution is specified by rules such as:\n (1) The statement \"GO TO L\" is followed by the statement labelled \"L\" (Branching rule).\n (2) The last statement in the range of an iteration is followed, under certain conditions, by the first statement in the range (Looping rule).\n (3) The last statement of a subroutine is followed by the statement immediately after its CALL (Out-of-line code rule).\n ... (Other rules)\n (n) In other cases, each statement is followed by the statement immediately after it (Order rule)."
            },
            "slug": "A-language-design-for-concurrent-processes-Tesler-Enea",
            "title": {
                "fragments": [],
                "text": "A language design for concurrent processes"
            },
            "tldr": {
                "abstractSimilarityScore": 99,
                "text": "In conventional programming languages, the sequence of execution is specified by rules such as: The statement \"GO TO L\" is followed by the statement labelled \"L\" (Branching rule)."
            },
            "venue": {
                "fragments": [],
                "text": "AFIPS '68 (Spring)"
            },
            "year": 1968
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144616193"
                        ],
                        "name": "R. Allen",
                        "slug": "R.-Allen",
                        "structuredName": {
                            "firstName": "Randy",
                            "lastName": "Allen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 13978052,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e8ddfb7574926d50b75937424ff907b53d264ca6",
            "isKey": false,
            "numCitedBy": 824,
            "numCiting": 53,
            "paperAbstract": {
                "fragments": [],
                "text": "The recent success of vector computers such as the Cray-1 and array processors such as those manufactured by Floating Point Systems has increased interest in making vector operations available to the FORTRAN programmer. The FORTRAN standards committee is currently considering a successor to FORTRAN 77, usually called FORTRAN 8x, that will permit the programmer to explicitly specify vector and array operations.\nAlthough FORTRAN 8x will make it convenient to specify explicit vector operations in new programs, it does little for existing code. In order to benefit from the power of vector hardware, existing programs will need to be rewritten in some language (presumably FORTRAN 8x) that permits the explicit specification of vector operations. One way to avoid a massive manual recoding effort is to provide a translator that discovers the parallelism implicit in a FORTRAN program and automatically rewrites that program in FORTRAN 8x.\nSuch a translation from FORTRAN to FORTRAN 8x is not straightforward because FORTRAN DO loops are not always semantically equivalent to the corresponding FORTRAN 8x parallel operation. The semantic difference between these two constructs is precisely captured by the concept of dependence. A translation from FORTRAN to FORTRAN 8x preserves the semantics of the original program if it preserves the dependences in that program.\nThe theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form. Dependence is defined and characterized in terms of the conditions that give rise to it; accurate tests to determine dependence are presented; and transformations that use dependence to uncover additional parallelism are discussed."
            },
            "slug": "Automatic-translation-of-FORTRAN-programs-to-vector-Allen-Kennedy",
            "title": {
                "fragments": [],
                "text": "Automatic translation of FORTRAN programs to vector form"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "The theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form and transformations that use dependence to uncover additional parallelism are discussed."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1689196"
                        ],
                        "name": "A. Schrijver",
                        "slug": "A.-Schrijver",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Schrijver",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Schrijver"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "( 11 ) Solutions to the Affine Scheduling Problem I 317"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 29180149,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "3ce2d233cee585ecff73729836918ba87195c18f",
            "isKey": false,
            "numCitedBy": 4874,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Introduction and Preliminaries. Problems, Algorithms, and Complexity. LINEAR ALGEBRA. Linear Algebra and Complexity. LATTICES AND LINEAR DIOPHANTINE EQUATIONS. Theory of Lattices and Linear Diophantine Equations. Algorithms for Linear Diophantine Equations. Diophantine Approximation and Basis Reduction. POLYHEDRA, LINEAR INEQUALITIES, AND LINEAR PROGRAMMING. Fundamental Concepts and Results on Polyhedra, Linear Inequalities, and Linear Programming. The Structure of Polyhedra. Polarity, and Blocking and Anti--Blocking Polyhedra. Sizes and the Theoretical Complexity of Linear Inequalities and Linear Programming. The Simplex Method. Primal--Dual, Elimination, and Relaxation Methods. Khachiyana s Method for Linear Programming. The Ellipsoid Method for Polyhedra More Generally. Further Polynomiality Results in Linear Programming. INTEGER LINEAR PROGRAMMING. Introduction to Integer Linear Programming. Estimates in Integer Linear Programming. The Complexity of Integer Linear Programming. Totally Unimodular Matrices: Fundamental Properties and Examples. Recognizing Total Unimodularity. Further Theory Related to Total Unimodularity. Integral Polyhedra and Total Dual Integrality. Cutting Planes. Further Methods in Integer Linear Programming. References. Indexes."
            },
            "slug": "Theory-of-linear-and-integer-programming-Schrijver",
            "title": {
                "fragments": [],
                "text": "Theory of linear and integer programming"
            },
            "venue": {
                "fragments": [],
                "text": "Wiley-Interscience series in discrete mathematics and optimization"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1679622"
                        ],
                        "name": "L. Lamport",
                        "slug": "L.-Lamport",
                        "structuredName": {
                            "firstName": "Leslie",
                            "lastName": "Lamport",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Lamport"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 113,
                                "start": 110
                            }
                        ],
                        "text": "The use of affine schedules for the construction of parallel programs may be related to the wavefront method, (4) and has be advocated in several recent publications."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(4) When one substitutes appropriate values for x, y, and n in Eqs."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7407863,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f8303a66826d531ec126d69cb3e4346d7d3aba68",
            "isKey": false,
            "numCitedBy": 707,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "Methods are developed for the parallel execution of different iterations of a DO loop. Both asynchronous multiprocessor computers and array computers are considered. Practical application to the design of compilers for such computers is discussed."
            },
            "slug": "The-parallel-execution-of-DO-loops-Lamport",
            "title": {
                "fragments": [],
                "text": "The parallel execution of DO loops"
            },
            "tldr": {
                "abstractSimilarityScore": 72,
                "text": "Methods are developed for the parallel execution of different iterations of a DO loop and practical application to the design of compilers for such computers is discussed."
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1974
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2776445"
                        ],
                        "name": "H. L. Verge",
                        "slug": "H.-L.-Verge",
                        "structuredName": {
                            "firstName": "Herv\u00e9",
                            "lastName": "Verge",
                            "middleNames": [
                                "Le"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. L. Verge"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 123651003,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "a75801c45a43e4db7bd3dfb804a89649807dced6",
            "isKey": false,
            "numCitedBy": 88,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes an implementation of Chernikova's algorithm for finding an irredundant set of vertices for a given polyhedron defined by a set of linear inequalities and equations. This algorithm can also be used for the dual problem : given a set of extremal rays and vertices, find the associated irredundant set of facet supporting hyperplanes. The method is an extension of initial Chernikova's algorithm (non negative domain) and is mainly based on the polyhedral cone duality principle. A new en hancement for extremal ray detection is presented together with its effects on a class of polyedra."
            },
            "slug": "A-Note-on-Chernikova's-algorithm-Verge",
            "title": {
                "fragments": [],
                "text": "A Note on Chernikova's algorithm"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 58913364,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "d6613b9ca5b21506b56b004be7593d9d40fb84da",
            "isKey": false,
            "numCitedBy": 472,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "L'analyse semantique des programmes informatiques conduit a la resolution de problemes de programmation parametrique entiere. L'article s'est ainsi consacre a la construction d'un algorithme de ce type"
            },
            "slug": "Parametric-integer-programming-Feautrier",
            "title": {
                "fragments": [],
                "text": "Parametric integer programming"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3050922"
                        ],
                        "name": "Corinne Ancourt",
                        "slug": "Corinne-Ancourt",
                        "structuredName": {
                            "firstName": "Corinne",
                            "lastName": "Ancourt",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Corinne Ancourt"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912411"
                        ],
                        "name": "F. Irigoin",
                        "slug": "F.-Irigoin",
                        "structuredName": {
                            "firstName": "Fran\u00e7ois",
                            "lastName": "Irigoin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Irigoin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1469859,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6f4f362af709c2890db6c6f920d0b565c91b4521",
            "isKey": false,
            "numCitedBy": 376,
            "numCiting": 32,
            "paperAbstract": {
                "fragments": [],
                "text": "HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not. The documents may come from teaching and research institutions in France or abroad, or from public or private research centers. L\u2019archive ouverte pluridisciplinaire HAL, est destin\u00e9e au d\u00e9p\u00f4t et \u00e0 la diffusion de documents scientifiques de niveau recherche, publi\u00e9s ou non, \u00e9manant des \u00e9tablissements d\u2019enseignement et de recherche fran\u00e7ais ou \u00e9trangers, des laboratoires publics ou priv\u00e9s. Scanning polyhedra with DO loops Corinne Ancourt, Fran\u00e7ois Irigoin"
            },
            "slug": "Scanning-polyhedra-with-DO-loops-Ancourt-Irigoin",
            "title": {
                "fragments": [],
                "text": "Scanning polyhedra with DO loops"
            },
            "tldr": {
                "abstractSimilarityScore": 90,
                "text": "HAL is a multi-disciplinary open access archive for the deposit and dissemination of scientific research documents, whether they are published or not, for teaching and research institutions in France or abroad, or from public or private research centers."
            },
            "venue": {
                "fragments": [],
                "text": "PPOPP '91"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2098795332"
                        ],
                        "name": "Pierrick Gachet",
                        "slug": "Pierrick-Gachet",
                        "structuredName": {
                            "firstName": "Pierrick",
                            "lastName": "Gachet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Pierrick Gachet"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(24) also is a schedule with delay 1 for the program in Fig."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 42,
                                "start": 38
                            }
                        ],
                        "text": "0'(1, i) = i 0'(2, i, j ) = i + j + 1 (24)"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 14,
                                "start": 10
                            }
                        ],
                        "text": "The proof (24) proceeds by coding the halting problem of a Turing machine into a consistency problem for a GDG."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 169167125,
            "fieldsOfStudy": [
                "Philosophy"
            ],
            "id": "3249cfca2fde83d99b4d295d204bd833412a106d",
            "isKey": true,
            "numCitedBy": 11,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "On presente un systeme de conception d'algorithmes et d'architectures systoliques. La methode de projection des dependances constitue le coeur de ce systeme. Elle permet de deriver des algorithmes et des architectures systoliques a partir de systemes d'equations recurrentes uniformes (seru). En amont de cette methode, le systeme est dote d'outils de synthese de seru (mise sous formes recurrente, representation concrete, pipeline, routage) et en aval d'outils d'evaluation et de conception detaillee des processeurs. Ces outils originaux couvrent toutes les etapes de conception d'une architecture systolique de la specification mathematique usuelle du probleme (fonctions de generalisation) a la conception detaillee des cellules de l'architecture. Un noyau de ce systeme est mis en oeuvre par le logiciel diastol."
            },
            "slug": "Conception-d'algorithmes-et-d'architectures-:-de-Gachet",
            "title": {
                "fragments": [],
                "text": "Conception d'algorithmes et d'architectures systoliques : synthese automatique de circuits"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47546648"
                        ],
                        "name": "R. Karp",
                        "slug": "R.-Karp",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Karp",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Karp"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1400120462"
                        ],
                        "name": "Raymond E. Miller",
                        "slug": "Raymond-E.-Miller",
                        "structuredName": {
                            "firstName": "Raymond E.",
                            "lastName": "Miller",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Raymond E. Miller"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1690630"
                        ],
                        "name": "S. Winograd",
                        "slug": "S.-Winograd",
                        "structuredName": {
                            "firstName": "Shmuel",
                            "lastName": "Winograd",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Winograd"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 151,
                                "start": 147
                            }
                        ],
                        "text": "Hence the same reasoning applies, One can introduce Farkas multipliers 2ek and get: me((:) ) O(6(e) ,y)-O(~(e) ,he(Y))- l -2eO+ ~ )'ek Cek\" \"~-dek (16) k = l"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 49,
                                "start": 45
                            }
                        ],
                        "text": "On the other hand, for each edge e, Identity (16) will give one equation for each independent variable, i."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(16) by a process of identification and elimination."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 16568434,
            "fieldsOfStudy": [
                "Physics"
            ],
            "id": "acbd0d8557edad81f05b7098a5500937725acefb",
            "isKey": true,
            "numCitedBy": 636,
            "numCiting": 13,
            "paperAbstract": {
                "fragments": [],
                "text": "A set equations in the quantities <italic>a<subscrpt>i</subscrpt></italic>(<italic>p</italic>), where <italic>i</italic> = 1, 2, \u00b7 \u00b7 \u00b7, <italic>m</italic> and <italic>p</italic> ranges over a set <italic>R</italic> of lattice points in <italic>n</italic>-space, is called a <italic>system of uniform recurrence equations</italic> if the following property holds: If <italic>p</italic> and <italic>q</italic> are in <italic>R</italic> and <italic>w</italic> is an integer <italic>n</italic>-vector, then <italic>a<subscrpt>i</subscrpt></italic>(<italic>p</italic>) depends directly on <italic>a<subscrpt>j</subscrpt></italic>(<italic>p</italic> - <italic>w</italic>) if and only if <italic>a<subscrpt>i</subscrpt></italic>(<italic>q</italic>) depends directly on <italic>a<subscrpt>j</subscrpt></italic>(<italic>q</italic> - <italic>w</italic>). Finite-difference approximations to systems of partial differential equations typically lead to such recurrence equations. The structure of such a system is specified by a <italic>dependence graph G</italic> having <italic>m</italic> vertices, in which the directed edges are labeled with integer <italic>n</italic>-vectors. For certain choices of the set <italic>R</italic>, necessary and sufficient conditions on <italic>G</italic> are given for the existence of a schedule to compute all the quantities <italic>a<subscrpt>i</subscrpt></italic>(<italic>p</italic>) explicitly from their defining equations. Properties of such schedules, such as the degree to which computation can proceed \u201cin parallel,\u201d are characterized. These characterizations depend on a certain iterative decomposition of a dependence graph into subgraphs. Analogous results concerning implicit schedules are also given."
            },
            "slug": "The-Organization-of-Computations-for-Uniform-Karp-Miller",
            "title": {
                "fragments": [],
                "text": "The Organization of Computations for Uniform Recurrence Equations"
            },
            "venue": {
                "fragments": [],
                "text": "JACM"
            },
            "year": 1967
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144803177"
                        ],
                        "name": "P. Quinton",
                        "slug": "P.-Quinton",
                        "structuredName": {
                            "firstName": "Patrice",
                            "lastName": "Quinton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Quinton"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(26), identify, and solve, 6 being treated as the leading unknown, so as to obtain the minimum delay."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 156,
                                "start": 152
                            }
                        ],
                        "text": "Bounded Delay Schedules A bounded delay schedule (3~ is a schedule such that, for all edges of the GDG: (x, y ) ~ ~e ~ 1 ~ 0(6(e), y) - 0(a(e), x) ~< 6 (26)"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 79,
                                "start": 75
                            }
                        ],
                        "text": "One may even dispense with integrality conditions, in view of the following(26):"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 86,
                                "start": 82
                            }
                        ],
                        "text": "There are two basic methods for that; one of them may be called the vertex method (26) and will be briefly reviewed presently."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 56744207,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b12123f9115105652f3d5c4f6606ca2cada2a2ba",
            "isKey": true,
            "numCitedBy": 163,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "The-systematic-design-of-systolic-arrays-Quinton",
            "title": {
                "fragments": [],
                "text": "The systematic design of systolic arrays"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1987
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(14) the relevant hypothesis is the fact that instruction S is executed at least once for at least one value of the structure parameters."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(14)] this will tend to produce good schedules."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(14)--let them be the components of the vector #--and some of the Farkas multipliers in Eq."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 38,
                                "start": 34
                            }
                        ],
                        "text": "Dependence direction vectors (DDV (14)) are a refinement on the idea of depth."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Optimizing Supercompilers for Supereomputers, Pitman and The MIT"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(12) As to the dependence relation, its form depends mainly on the thoroughness of the analysis which has been performed on the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 173,
                                "start": 169
                            }
                        ],
                        "text": "X = 2 ~, Ps + 2Q + Card V - ([nl - 1) Card E S Since Inf is always a small integer and since Card V and Card E are of the same order of magnitude--another empirical fact(12)--one concludes that there are about twice as much unknowns than equations."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 34,
                                "start": 30
                            }
                        ],
                        "text": "The aim of Data Flow Analysis (12) is to reduce ~ to minimal form."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Dataflow analysis of scalar and array references"
            },
            "venue": {
                "fragments": [],
                "text": "IJPP"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(6) by a so-called inspector loop, then exploited for the actual parallel execution of the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 99,
                                "start": 96
                            }
                        ],
                        "text": "If one knows a causal order, the best (or free) schedule is given by: O(u) = max{O(v) lvru} + 1 (6) To be effective, this formula must be evaluated according to any linear extension of the given causal order."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(6), guess a closed form representation, and check that Eq."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Systematic construction of programs for distributed memory systems, Paul Feautrier and Frangois"
            },
            "venue": {
                "fragments": [],
                "text": "Irigoin (eds.), Proc. of the Int'l. Workshop on Compiler for Parallel Computers,"
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 62778439,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "10601cb68eac2e3b27e5d6d16723a899ac2485a2",
            "isKey": false,
            "numCitedBy": 91,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "A common problem in restructuring programs for vector or parallel execution is the suppression of false dependencies which originate in the reuse of the same memory cell for unrelated values. The method is simple and well understood in the case of scalars. This paper gives the general solution for the case of arrays. The expansion is done in two steps: first, modify all definitions of the offending array in order to obtain the single assignment property. Then, reconstruct the original data flow by adapting all uses of the array. This is done with the help of a new algorithm for solving parametric integer programs. The technique is quite general and may be used for other purposes, including program checking, collecting array predicates, etc."
            },
            "slug": "Array-expansion-Feautrier",
            "title": {
                "fragments": [],
                "text": "Array expansion"
            },
            "tldr": {
                "abstractSimilarityScore": 61,
                "text": "The general solution for the case of arrays of false dependencies which originate in the reuse of the same memory cell for unrelated values with the help of a new algorithm for solving parametric integer programs is given."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1988
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 36,
                                "start": 32
                            }
                        ],
                        "text": "For instance; Allen and Kennedy (13) have shown that a fairly good parallel program can be deduced simply from a knowledge of the depth of each dependence, i."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Automatic loop interchange, SIGPLAN Notices"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1984
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 46,
                                "start": 42
                            }
                        ],
                        "text": "\u20221,1 = #2,1 + ]22,4 - - #1,1 - - 21,4 ~ 0 (19)"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(19) and (21) will never be satisfied whathever the value of 21, 4 unless: ]22,1 \" ] -#2 ,4- -#1 ,1 ~ 0"
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "nea, A language design for concurrent processes, SJCC, pp"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1968
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Linear Scheduling is Nearly Optimal, Technical Report 91-35"
            },
            "venue": {
                "fragments": [],
                "text": "LIP-IMAG (November"
            },
            "year": 1991
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "(3) and build the corresponding parallel program."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 106
                            }
                        ],
                        "text": "~(t) be the set of operation which are initiated at time t (the front at t): ~ ( t ) = { u e O I O(u)= t} (3)"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Synthesizing systolic rays from recurrence equations, Parallel Computing"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Frangois Irigoin and R 6 mi Triolet , Supernode partitioning"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(27) is the following linear programming problem:"
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Affine-by-statement Scheduling of Uniform Loop Nest over Parametric Domains, Technical Report 92-16"
            },
            "venue": {
                "fragments": [],
                "text": "LIP-IMAG (April"
            },
            "year": 1992
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "(29) occur in the objective function, this program is not in a form suitable for solution by the PIP softwareJ 29) This situation may be remedied by using one variant of the Linear Programming Duality theorem~n):"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 92,
                                "start": 88
                            }
                        ],
                        "text": "A classical version must be supplied with a linear objective function; the PIP software (29) uses lexical ordering as a ranking principle."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "R6solution de Syst+mes d'In6quations Lin6aires; mode d'emploi du logiciel PIP"
            },
            "venue": {
                "fragments": [],
                "text": "Technical Report 90.2,"
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 23,
                                "start": 20
                            }
                        ],
                        "text": "other hand, Dowling (5) proved that any program instance (in which the structure parameters have been given numerical values), has a linear schedule, and concluded, wrongly, that any program with sufficient"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "DoMing, Optimal code parallelization using unimodular transformations, Parallel Computing"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Synthesizing systolic rays from recurrence equations"
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Computing"
            },
            "year": 1990
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 17,
            "methodology": 7
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 42,
        "totalPages": 5
    },
    "page_url": "https://www.semanticscholar.org/paper/Some-efficient-solutions-to-the-affine-scheduling-Feautrier/16de6f9e2bf6ee1068dbca8c9e5446295c904315?sort=total-citations"
}