{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2108324467"
                        ],
                        "name": "Juan Chen",
                        "slug": "Juan-Chen",
                        "structuredName": {
                            "firstName": "Juan",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Juan Chen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9180687"
                        ],
                        "name": "Dinghao Wu",
                        "slug": "Dinghao-Wu",
                        "structuredName": {
                            "firstName": "Dinghao",
                            "lastName": "Wu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dinghao Wu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1804502"
                        ],
                        "name": "A. Appel",
                        "slug": "A.-Appel",
                        "structuredName": {
                            "firstName": "Andrew",
                            "lastName": "Appel",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Appel"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2113484277"
                        ],
                        "name": "H. Fang",
                        "slug": "H.-Fang",
                        "structuredName": {
                            "firstName": "Hai",
                            "lastName": "Fang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Fang"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15048584,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "661f13c265ca3dadd7c16ac20bbd258b8a1d70e0",
            "isKey": false,
            "numCitedBy": 50,
            "numCiting": 26,
            "paperAbstract": {
                "fragments": [],
                "text": "Typed assembly languages provide a way to generate machine-checkable safety proofs for machine-language programs. But the soundness proofs of most existing typed assembly languages are hand-written and cannot be machine-checked, which is worrisome for such large calculi. We have designed and implemented a low-level typed assembly language (LTAL) with a semantic model and established its soundness from the model. Compared to existing typed assembly languages, LTAL is more scalable and more secure; it has no macro instructions that hinder low-level optimizations such as instruction scheduling; its type constructors are expressive enough to capture dataflow information, support the compiler's choice of data representations and permit typed position-independent code; and its type-checking algorithm is completely syntax-directed.We have built a prototype system, based on Standard ML of New Jersey, that compiles most of core ML to Sparc code. We explain how we were able to make the untyped back end in SML/NJ preserve types during instruction selection and register allocation, without restricting low-level optimizations and without knowledge of any type system pervading the instruction selector and register allocator."
            },
            "slug": "A-provably-sound-TAL-for-back-end-optimization-Chen-Wu",
            "title": {
                "fragments": [],
                "text": "A provably sound TAL for back-end optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This work designed and implemented a low-level typed assembly language (LTAL) with a semantic model and established its soundness from the model, and built a prototype system that compiles most of core ML to Sparc code."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '03"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1402995468"
                        ],
                        "name": "Ali-Reza Adl-Tabatabai",
                        "slug": "Ali-Reza-Adl-Tabatabai",
                        "structuredName": {
                            "firstName": "Ali-Reza",
                            "lastName": "Adl-Tabatabai",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ali-Reza Adl-Tabatabai"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3271473"
                        ],
                        "name": "G. Langdale",
                        "slug": "G.-Langdale",
                        "structuredName": {
                            "firstName": "Geoff",
                            "lastName": "Langdale",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Langdale"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1762171"
                        ],
                        "name": "S. Lucco",
                        "slug": "S.-Lucco",
                        "structuredName": {
                            "firstName": "Steven",
                            "lastName": "Lucco",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Lucco"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2252359"
                        ],
                        "name": "Robert Wahbe",
                        "slug": "Robert-Wahbe",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Wahbe",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Robert Wahbe"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 12,
                                "start": 9
                            }
                        ],
                        "text": "Omniware [1] provides #5 and most of the benefits of #2 (because, like LLVM, it uses a low-level represention that permits extensive static optimization), but at the cost of not providing information for high-level analysis and optimization (i."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 32,
                                "start": 29
                            }
                        ],
                        "text": "The Omniware virtual machine [1] is closer to LLVM, because they use an abstract low-level RISC architecture and can support arbitrary code (including non-type-safe code) from any source language."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 2534344,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "67abc1785a17e3aab704bd68a9d6c219ce4b884e",
            "isKey": false,
            "numCitedBy": 111,
            "numCiting": 69,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper evaluates the design and implementation of Omniware: a safe, efficient, and language-independent system for executing mobile program modules. Previous approaches to implementing mobile code rely on either language semantics or abstract machine interpretation to enforce safety. In the former case, the mobile code system sacrifices universality to gain safety by dictating a particular source language or type system. In the latter case, the mobile code system sacrifices performance to gain safety through abstract machine interpretation.Omniware uses software fault isolation, a technology developed to provide safe extension code for databases and operating systems, to achieve a unique combination of language-independence and excellent performance. Software fault isolation uses only the semantics of the underlying processor to determine whether a mobile code module can corrupt its execution environment. This separation of programming language implementation from program module safety enables our mobile code system to use a radically simplified virtual machine as its basis for portability. We measured the performance of Omniware using a suite of four SPEC92 programs on the Pentium, PowerPC, Mips, and Sparc processor architectures. Including the overhead for enforcing safety on all four processors, OmniVM executed the benchmark programs within 21% as fast as the optimized, unsafe code produced by the vendor-supplied compiler."
            },
            "slug": "Efficient-and-language-independent-mobile-programs-Adl-Tabatabai-Langdale",
            "title": {
                "fragments": [],
                "text": "Efficient and language-independent mobile programs"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Omniware uses software fault isolation, a technology developed to provide safe extension code for databases and operating systems, to achieve a unique combination of language-independence and excellent performance."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '96"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3310105"
                        ],
                        "name": "K. Ebcioglu",
                        "slug": "K.-Ebcioglu",
                        "structuredName": {
                            "firstName": "Kemal",
                            "lastName": "Ebcioglu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Ebcioglu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1682451"
                        ],
                        "name": "E. Altman",
                        "slug": "E.-Altman",
                        "structuredName": {
                            "firstName": "Erik",
                            "lastName": "Altman",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Altman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Allowing lifelong reoptimization of the program gives architects the power to evolve processors and exposed interfaces in more flexible ways [11, 20], while allowing legacy applications to run well on new systems."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "There have also been several systems that perform transparent runtime optimization of native code [6, 20, 16]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14271662,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ec65a506f6f852bbca3cc731e8dace0a562e787a",
            "isKey": false,
            "numCitedBy": 301,
            "numCiting": 74,
            "paperAbstract": {
                "fragments": [],
                "text": "Although VLIW architectures offer the advantages of simplicity of design and high issue rates, a major impediment to their use is that they are not compatible with the existing software base. We describe new simple hardware features for a VLIW machine we call DAISY (Dynamically Architected Instruction Set from Yorktown). DAISY is specifically intended to emulate existing architectures, so that all existing software for an old architecture (including operating system kernel code) runs without changes on the VLIW. Each time a new fragment of code is executed for the first time, the code is translated to VLIW primitives, parallelized and saved in a portion of main memory not visible to the old architecture, by a Virtual Machine Monitor (software) residing in read only memory. Subsequent executions of the same fragment do not require a translation (unless cast out). We discuss the architectural requirements for such a VLIW, to deal with issues including self-modifying code, precise exceptions, and aggressive reordering of memory references in the presence of strong MP consistency and memory mapped I/O. We have implemented the dynamic parallelization algorithms for the PowerPC architecture. The initial results show high degrees of instruction level parallelism with reasonable translation overhead and memory usage."
            },
            "slug": "Daisy:-Dynamic-Compilation-For-10o40-Architectural-Ebcioglu-Altman",
            "title": {
                "fragments": [],
                "text": "Daisy: Dynamic Compilation For 10o?40 Architectural Compatibility"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "The architectural requirements for such a VLIW, to deal with issues including self-modifying code, precise exceptions, and aggressive reordering of memory references in the presence of strong MP consistency and memory mapped I/O are discussed."
            },
            "venue": {
                "fragments": [],
                "text": "Conference Proceedings. The 24th Annual International Symposium on Computer Architecture"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2257959"
                        ],
                        "name": "Amitabh Srivastava",
                        "slug": "Amitabh-Srivastava",
                        "structuredName": {
                            "firstName": "Amitabh",
                            "lastName": "Srivastava",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amitabh Srivastava"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 52
                            }
                        ],
                        "text": "Some operate on assembly code for a given processor [36, 41, 14, 37] (focusing primarily on machinedependent optimizations), while others export additional information from the static compiler, either in the form of an IR or annotations [44, 21, 5, 26]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 141102436,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "6b0083de6e9fa76813551088983a2df54b8e05d0",
            "isKey": false,
            "numCitedBy": 167,
            "numCiting": 133,
            "paperAbstract": {
                "fragments": [],
                "text": "We have developed a system called OM to explore the problem of code optimization at link-time. OM takes a collection of object modules constituting the entire program, and converts the object code into a symbolic Register Transfer Language (RTL) form that can be easily manipulated. This RTL is then transformed by intermodule optimization and finally converted back into object form. Although much high-level information about the program is gone at link-time, this approach enables us to perform optimizations that a compiler looking at a single module cannot see. Since object modules are more or less independent of the particular source language or compiler, this also gives us the chance to improve the code in ways that some compilers might simply have missed. To test the concept, we have used OM to build an optimizer that does interprocedural code motion. It moves simple loop-invariant code out of loops, even when the loop body extends across many procedures and the loop control is in a different procedure from the invariant code. Our technique also easily handles \u2018\u2018loops\u2019\u2019 induced by recursion rather than iteration. Our code motion technique makes use of an interprocedural liveness analysis to discover dead registers that it can use to hold loop-invariant results. This liveness analysis also lets us perform interprocedural dead code elimination. We applied our code motion and dead code removal to SPEC benchmarks compiled with optimization using the standard compilers for the DECstation 5000. Our system improved the performance by 5% on average and by more than 14% in one case. More improvement should be possible soon; at present we move only simple load and load-address operations out of loops, and we scavenge registers to hold these values, rather than completely reallocating them. This paper will appear in the March issue of Journal of Programming Languages. It replaces Technical Note TN-31, an earlier version of the same material."
            },
            "slug": "A-practical-system-fljr-intermodule-code-at-Srivastava-Wall",
            "title": {
                "fragments": [],
                "text": "A practical system fljr intermodule code optimization at link-time"
            },
            "tldr": {
                "abstractSimilarityScore": 63,
                "text": "A system that takes a collection of object modules constituting the entire program, and converts the object code into a symbolic Register Transfer Language form that is then transformed by intermodule optimization and finally converted back into object form to explore the problem of code optimization at link-time."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1765246"
                        ],
                        "name": "Chris Lattner",
                        "slug": "Chris-Lattner",
                        "structuredName": {
                            "firstName": "Chris",
                            "lastName": "Lattner",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chris Lattner"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2297304"
                        ],
                        "name": "Michael Brukman",
                        "slug": "Michael-Brukman",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Brukman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael Brukman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2055375406"
                        ],
                        "name": "Anand Shukla",
                        "slug": "Anand-Shukla",
                        "structuredName": {
                            "firstName": "Anand",
                            "lastName": "Shukla",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Anand Shukla"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2576066"
                        ],
                        "name": "Brian R. Gaeke",
                        "slug": "Brian-R.-Gaeke",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Gaeke",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Brian R. Gaeke"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 445702,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5d29583818f4b3c7a22de39cd82046bb582adcef",
            "isKey": false,
            "numCitedBy": 94,
            "numCiting": 51,
            "paperAbstract": {
                "fragments": [],
                "text": "A virtual instruction set architecture (V-ISA) implemented via a processor-specific software translation layer can provide great flexibility to processor designers. Recent examples such as Crusoe and DAISY, however, have used existing hardware instruction sets as virtual ISAs, which complicates translation and optimization. In fact, there has been little research on specific designs for a virtual ISA for processors. This paper proposes a novel virtual ISA (LLVA) and a translation strategy for implementing it on arbitrary hardware. The instruction set is typed, uses an infinite virtual register set in static single assignment form, and provides explicit control-flow and dataflow information, and yet uses low-level operations closely matched to traditional hardware. It includes novel mechanisms to allow more flexible optimization of native code, including a flexible exception model and minor constraints on self-modifying code. We propose a translation strategy that enables offline translation and transparent offline caching of native code and profile information, while remaining completely OS-independent. It also supports optimizations directly on the representation at install-time, runtime, and offline between executions. We show experimentally that despite its rich information content, virtual object code is comparable in size to native machine code, virtual instructions expand to only 2-4 ordinary hardware instructions on average, and simple translation costs under 1% of total execution time except for very short runs."
            },
            "slug": "LLVA:-a-low-level-virtual-instruction-set-Adve-Lattner",
            "title": {
                "fragments": [],
                "text": "LLVA: a low-level virtual instruction set architecture"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This paper proposes a novel virtual ISA (LLVA) and a translation strategy for implementing it on arbitrary hardware that enables offline translation and transparent offline caching of native code and profile information, while remaining completely OS-independent."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. 36th Annual IEEE/ACM International Symposium on Microarchitecture, 2003. MICRO-36."
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35941003"
                        ],
                        "name": "M. Fern\u00e1ndez",
                        "slug": "M.-Fern\u00e1ndez",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Fern\u00e1ndez",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Fern\u00e1ndez"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 6689871,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "422cbe99a30143ca032437bb8a1768e112741232",
            "isKey": false,
            "numCitedBy": 134,
            "numCiting": 66,
            "paperAbstract": {
                "fragments": [],
                "text": "Modula-3 supports development of modular programs by separating an object's interface from its implementation. This separation induces a runtime overhead in the implementation of objects, because it prevents the compiler from having complete information about a program's type hierarchy. This overhead can be reduced at link time, when the entire type hierarchy becomes available. We describe opportunities for link-time optimization of Modula-3, present two link-time optimizations that reduce the runtime costs of Modula-3's opaque types and methods, and show how link-time optimization could provide C++ which the benefits of opaques types at no additional runtime cost.\nOur optimization techniques are implemented in mld, a retargetable linker for the MIPS, SPARC, and Intel 486, mld links a machine-independent intermediate code that is suitable for link-time optimization and code generation. Linking intermediate code simplifies implementation of the optimizations and makes it possible to evaluate them on a wide range of architectures. mld's optimizations are effective: they reduce the total number of instructions executed by up to 14% and convert as many as 79% of indirect calls to direct calls."
            },
            "slug": "Simple-and-effective-link-time-optimization-of-Fern\u00e1ndez",
            "title": {
                "fragments": [],
                "text": "Simple and effective link-time optimization of Modula-3 programs"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Optimization techniques are implemented in mld, a retargetable linker for the MIPS, SPARC, and Intel 486, mld links a machine-independent intermediate code that is suitable for link-time optimization and code generation."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '95"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2381974"
                        ],
                        "name": "J. Dehnert",
                        "slug": "J.-Dehnert",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Dehnert",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Dehnert"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145484840"
                        ],
                        "name": "B. Grant",
                        "slug": "B.-Grant",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Grant",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Grant"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145355395"
                        ],
                        "name": "J. Banning",
                        "slug": "J.-Banning",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Banning",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Banning"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2157207880"
                        ],
                        "name": "Richard Johnson",
                        "slug": "Richard-Johnson",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Johnson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Richard Johnson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2861277"
                        ],
                        "name": "T. Kistler",
                        "slug": "T.-Kistler",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Kistler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Kistler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2080795"
                        ],
                        "name": "A. Klaiber",
                        "slug": "A.-Klaiber",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Klaiber",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Klaiber"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49580477"
                        ],
                        "name": "J. Mattson",
                        "slug": "J.-Mattson",
                        "structuredName": {
                            "firstName": "Jim",
                            "lastName": "Mattson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mattson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 63,
                                "start": 38
                            }
                        ],
                        "text": "4.2.3 External ISA design \nfor Virtual Instruction Set Computers Virtual Instruction Set Computers [40, 16, 2] are proces\u00adsor designs \nthat use two distinct instruction sets: an exter\u00adnally visible, virtual instruction set (V-ISA) which \nserves as the program representation for all software, and a hid\u00adden implementation-speci.c instruction \nset (I-ISA) that is the actual hardware ISA."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 98
                            }
                        ],
                        "text": "There have also been several systems that perform transparent runtime optimization of native code [6, 20, 16]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 45,
                                "start": 34
                            }
                        ],
                        "text": "Virtual Instruction Set Computers [40, 16, 2] are processor designs that use two distinct instruction sets: an externally visible, virtual instruction set (V-ISA) which serves as the program representation for all software, and a hidden implementation-specific instruction set (I-ISA) that is the actual hardware ISA."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 11827532,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "421f6c91b785a893dfa04a50abeb3f40c6ff62c7",
            "isKey": true,
            "numCitedBy": 200,
            "numCiting": 51,
            "paperAbstract": {
                "fragments": [],
                "text": "Transmeta's Crusoe microprocessor is a full, system-level implementation of the x86 architecture, comprising a native VLIW microprocessor with a software layer, the Code Morphing Software (CMS), that combines an interpreter, dynamic binary translator, optimizer, and runtime system. In its general structure, CMS resembles other binary translation systems described in the literature, but it is unique in several respects. The wide range of PC workloads that CMS must handle gracefully in real-life operation, plus the need for full system-level x86 compatibility, expose several issues that have received little or no attention in previous literature, such as exceptions and interrupts, I/O, DMA, and self-modifying code. In this paper we discuss some of the challenges raised by these issues, and present the techniques developed in Crusoe and CMS to meet those challenges. The key to these solutions is the Crusoe paradigm of aggressive speculation, recovery to a consistent x86 state using unique hardware commit-and-rollback support, and adaptive retranslation when exceptions occur too often to be handled efficiently by interpretation."
            },
            "slug": "The-Transmeta-Code-Morphing#8482;-Software:-using-Dehnert-Grant",
            "title": {
                "fragments": [],
                "text": "The Transmeta Code Morphing#8482; Software: using speculation, recovery, and adaptive retranslation to address real-life challenges"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "The Crusoe paradigm of aggressive speculation, recovery to a consistent x86 state using unique hardware commit-and-rollback support, and adaptive retranslation when exceptions occur too often to be handled efficiently by interpretation are presented."
            },
            "venue": {
                "fragments": [],
                "text": "CGO"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144656147"
                        ],
                        "name": "Zhong Shao",
                        "slug": "Zhong-Shao",
                        "structuredName": {
                            "firstName": "Zhong",
                            "lastName": "Shao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Zhong Shao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2353202"
                        ],
                        "name": "C. League",
                        "slug": "C.-League",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "League",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. League"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3118857"
                        ],
                        "name": "Stefan Monnier",
                        "slug": "Stefan-Monnier",
                        "structuredName": {
                            "firstName": "Stefan",
                            "lastName": "Monnier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stefan Monnier"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[38]) as a natural extension of the source language."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 10572457,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "311b26799d2d6f168a74d9685121600c8f2e237d",
            "isKey": false,
            "numCitedBy": 79,
            "numCiting": 61,
            "paperAbstract": {
                "fragments": [],
                "text": "Recent advances in compiler technology have demonstrated the benefits of using strongly typed intermediate languages to compile richly typed source languages (e.g., ML). A type-preserving compiler can use types to guide advanced optimizations and to help generate provably secure mobile code. Types, unfortunately, are very hard to represent and manipulate efficiently; a naive implementation can easily add exponential overhead to the compilation and execution of a program. This paper describes our experience with implementing the FLINT typed intermediate language in the SML/NJ production compiler. We observe that a type-preserving compiler will not scale to handle large types unless all of its type-preserving stages preserve the asymptotic time and space usage in representing and manipulating types. We present a series of novel techniques for achieving this property and give empirical evidence of their effectiveness."
            },
            "slug": "Implementing-typed-intermediate-languages-Shao-League",
            "title": {
                "fragments": [],
                "text": "Implementing typed intermediate languages"
            },
            "tldr": {
                "abstractSimilarityScore": 49,
                "text": "This paper describes the experience with implementing the FLINT typed intermediate language in the SML/NJ production compiler and observes that a type-preserving compiler will not scale to handle large types unless all of its type- Preserving stages preserve the asymptotic time and space usage in representing and manipulating types."
            },
            "venue": {
                "fragments": [],
                "text": "ICFP '98"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8319903"
                        ],
                        "name": "D. Grossman",
                        "slug": "D.-Grossman",
                        "structuredName": {
                            "firstName": "Dan",
                            "lastName": "Grossman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Grossman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143649399"
                        ],
                        "name": "J. G. Morrisett",
                        "slug": "J.-G.-Morrisett",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Morrisett",
                            "middleNames": [
                                "Gregory"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. G. Morrisett"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145671960"
                        ],
                        "name": "T. Jim",
                        "slug": "T.-Jim",
                        "structuredName": {
                            "firstName": "Trevor",
                            "lastName": "Jim",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Jim"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144578171"
                        ],
                        "name": "M. Hicks",
                        "slug": "M.-Hicks",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Hicks",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Hicks"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2108975917"
                        ],
                        "name": "Yanling Wang",
                        "slug": "Yanling-Wang",
                        "structuredName": {
                            "firstName": "Yanling",
                            "lastName": "Wang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yanling Wang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144320476"
                        ],
                        "name": "J. Cheney",
                        "slug": "J.-Cheney",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Cheney",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Cheney"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 50,
                                "start": 42
                            }
                        ],
                        "text": "to avoid using interprocedural techniques [17, 23])."
                    },
                    "intents": []
                }
            ],
            "corpusId": 7795893,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "562a27c239847fb5940af3601b30f43f7d24f6f7",
            "isKey": false,
            "numCitedBy": 404,
            "numCiting": 39,
            "paperAbstract": {
                "fragments": [],
                "text": "Cyclone is a type-safe programming language derived from C. The primary design goal of Cyclone is to let programmers control data representation and memory management without sacrificing type-safety. In this paper, we focus on the region-based memory management of Cyclone and its static typing discipline. The design incorporates several advancements, including support for region subtyping and a coherent integration with stack allocation and a garbage collector. To support separate compilation, Cyclone requires programmers to write some explicit region annotations, but a combination of default annotations, local type inference, and a novel treatment of region effects reduces this burden. As a result, we integrate C idioms in a region-based framework. In our experience, porting legacy C to Cyclone has required altering about 8% of the code; of the changes, only 6% (of the 8%) were region annotations."
            },
            "slug": "Region-based-memory-management-in-cyclone-Grossman-Morrisett",
            "title": {
                "fragments": [],
                "text": "Region-based memory management in cyclone"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This paper focuses on the region-based memory management of Cyclone and its static typing discipline, and combines default annotations, local type inference, and a novel treatment of region effects to reduce this burden."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '02"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2381974"
                        ],
                        "name": "J. Dehnert",
                        "slug": "J.-Dehnert",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Dehnert",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Dehnert"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145484840"
                        ],
                        "name": "B. Grant",
                        "slug": "B.-Grant",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Grant",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Grant"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145355395"
                        ],
                        "name": "J. Banning",
                        "slug": "J.-Banning",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Banning",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Banning"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2975771"
                        ],
                        "name": "R. Johnson",
                        "slug": "R.-Johnson",
                        "structuredName": {
                            "firstName": "R.",
                            "lastName": "Johnson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Johnson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2861277"
                        ],
                        "name": "T. Kistler",
                        "slug": "T.-Kistler",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Kistler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Kistler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2080795"
                        ],
                        "name": "A. Klaiber",
                        "slug": "A.-Klaiber",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Klaiber",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Klaiber"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49580477"
                        ],
                        "name": "J. Mattson",
                        "slug": "J.-Mattson",
                        "structuredName": {
                            "firstName": "Jim",
                            "lastName": "Mattson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Mattson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "There have also been several systems that perform transparent runtime optimization of native code [6, 20, 16]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [],
                        "text": "Virtual Instruction Set Computers [40, 16, 2] are processor designs that use two distinct instruction sets: an externally visible, virtual instruction set (V-ISA) which serves as the program representation for all software, and a hidden implementation-specific instruction set (I-ISA) that is the actual hardware ISA."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 61166620,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5c17b90a86ab37488215f6a060ecd3350a994ebf",
            "isKey": false,
            "numCitedBy": 314,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "Transmeta's Crusoe microprocessor is a full, system-level implementation of the x86 architecture, comprising a native VLIW microprocessor with a software layer, the Code Morphing Software (CMS), that combines an interpreter, dynamic binary translator, optimizer, and run-time system. In its general structure, CMS resembles other binary translation systems described in the literature, but it is unique in several respects. The wide range of PC workloads that CMS must handle gracefully in real-life operation, plus the need for full system-level x86 compatibility, expose several issues that have received little or no attention in previous literature, such as exceptions and interrupts, I/O, DMA, and self-modifying code. In this paper we discuss some of the challenges raised by these issues, and present the techniques developed in Crusoe and CMS to meet those challenges. The key to these solutions is the Crusoe paradigm of aggressive speculation, recovery to a consistent x86 state using unique hardware commit-and-rollback support, and adaptive retranslation when exceptions occur too often to be handled efficiently by interpretation."
            },
            "slug": "The-Transmeta-Code-Morphing/spl-trade/-Software:-to-Dehnert-Grant",
            "title": {
                "fragments": [],
                "text": "The Transmeta Code Morphing/spl trade/ Software: using speculation, recovery, and adaptive retranslation to address real-life challenges"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "The Crusoe paradigm of aggressive speculation, recovery to a consistent x86 state using unique hardware commit-and-rollback support, and adaptive retranslation when exceptions occur too often to be handled efficiently by interpretation are presented."
            },
            "venue": {
                "fragments": [],
                "text": "International Symposium on Code Generation and Optimization, 2003. CGO 2003."
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2010108"
                        ],
                        "name": "S. Kowshik",
                        "slug": "S.-Kowshik",
                        "structuredName": {
                            "firstName": "Sumant",
                            "lastName": "Kowshik",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Kowshik"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2189585"
                        ],
                        "name": "D. Dhurjati",
                        "slug": "D.-Dhurjati",
                        "structuredName": {
                            "firstName": "Dinakar",
                            "lastName": "Dhurjati",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Dhurjati"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 8874085,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c02ebb1c0e7b9be721fdedbb1afdd231a8ce19d5",
            "isKey": false,
            "numCitedBy": 58,
            "numCiting": 27,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper considers the problem of providing safe programming support and enabling secure online software upgrades for control software in real-time control systems. In such systems, offline techniques for ensuring code safety are greatly preferable to online techniques. We propose a language called Control-C that is essentially a subset of C, but with key restrictions designed to ensure that memory safety of code can be verified entirely by static checking, under certain system assumptions. The language permits pointer-based data structures, restricted dynamic memory allocation, and restricted array operations, without requiring any runtime checks on memory operations and without garbage collection. The language restrictions have been chosen based on an understanding of both compiler technology and the needs of real-time control systems. The paper describes the language design and a compiler implementation for Control-C. We use control codes from three different experimental control systems to evaluate the suitability of the language for these codes, the effort required to port them to Control-C, and the effectiveness of the compiler in detecting a wide range of potential security violations for one of the systems."
            },
            "slug": "Ensuring-code-safety-without-runtime-checks-for-Kowshik-Dhurjati",
            "title": {
                "fragments": [],
                "text": "Ensuring code safety without runtime checks for real-time control systems"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "A language called Control-C is proposed that is essentially a subset of C, but with key restrictions designed to ensure that memory safety of code can be verified entirely by static checking, under certain system assumptions."
            },
            "venue": {
                "fragments": [],
                "text": "CASES '02"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2189585"
                        ],
                        "name": "D. Dhurjati",
                        "slug": "D.-Dhurjati",
                        "structuredName": {
                            "firstName": "Dinakar",
                            "lastName": "Dhurjati",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Dhurjati"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2010108"
                        ],
                        "name": "S. Kowshik",
                        "slug": "S.-Kowshik",
                        "structuredName": {
                            "firstName": "Sumant",
                            "lastName": "Kowshik",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Kowshik"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1765246"
                        ],
                        "name": "Chris Lattner",
                        "slug": "Chris-Lattner",
                        "structuredName": {
                            "firstName": "Chris",
                            "lastName": "Lattner",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chris Lattner"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 85
                            }
                        ],
                        "text": "We de\u00adscribe \nthe design of the LLVM representation and compiler framework, and evaluate the design in three ways: \n(a) the size and e.ectiveness of the representation, including the type information it provides; (b) \ncompiler performance for several interprocedural problems; and (c) illustrative\u2026"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1459540,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2ce7803031fcba0fa5a397e85039e762cee59f83",
            "isKey": false,
            "numCitedBy": 88,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "Traditional approaches to enforcing memory safety of programs rely heavily on runtime checks of memory accesses and on garbage collection, both of which are unattractive for embedded applications. The long-term goal of our work is to enable 100% static enforcement of memory safety for embedded programs through advanced compiler techniques and minimal semantic restrictions on programs. The key result of this paper is a compiler technique that ensures memory safety of dynamically allocated memory without programmer annotations, runtime checks, or garbage collection, and works for a large subclass of type-safe C programs. The technique is based on a fully automatic pool allocation (i.e., region-inference) algorithm for C programs we developed previously, and it ensures safety of dynamically allocated memory while retaining explicit deallocation of individual objects within regions (to avoid garbage collection). For a diverse set of embedded C programs (and using a previous technique to avoid null pointer checks), we show that we are able to statically ensure the safety of pointer and dynamic memory usage in all these programs. We also describe some improvements over our previous work in static checking of array accesses. Overall, we achieve 100% static enforcement of memory safety without new language syntax for a significant subclass of embedded C programs, and the subclass is much broader if array bounds checks are ignored. Overall, these techniques greatly expand the class of embedded programs for which 100% static enforcement of memory safety is possible, and furthermore can be achieved without new language support."
            },
            "slug": "Memory-safety-without-runtime-checks-or-garbage-Dhurjati-Kowshik",
            "title": {
                "fragments": [],
                "text": "Memory safety without runtime checks or garbage collection"
            },
            "tldr": {
                "abstractSimilarityScore": 48,
                "text": "A compiler technique is created that ensures memory safety of dynamically allocated memory without programmer annotations, runtime checks, or garbage collection, and works for a large subclass of type-safe C programs."
            },
            "venue": {
                "fragments": [],
                "text": "LCTES '03"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2156668479"
                        ],
                        "name": "Christopher Arthur Lattner",
                        "slug": "Christopher-Arthur-Lattner",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "Lattner",
                            "middleNames": [
                                "Arthur"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christopher Arthur Lattner"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 114,
                                "start": 110
                            }
                        ],
                        "text": "It is interesting to note, however, that those times also are relatively fast compared with GCC compile times [31]."
                    },
                    "intents": [
                        {
                            "id": "result"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 117
                            }
                        ],
                        "text": "It is important to note that similar results would be very di.cult to obtain if \nLLVM had been an untyped representa\u00ad 8DSA is actually quite aggressive: it can often extract type information \nfor objects stored into and loaded out of generic void* data structure, despite the casts to and from \nvoid*. tion."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 97,
                                "start": 94
                            }
                        ],
                        "text": "Overall, despite the use of custom allocators, casting to and from void*, \nand other C tricks, DSA is still able to verify the type information for an average of 68% of accesses \nacross these programs."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 367,
                                "start": 364
                            }
                        ],
                        "text": "These techniques inherit a few signi.cant bene.ts from LLVM, especially, \n(a) these techniques are only e.ective if most of the program is avail\u00adable, i.e., at link-time; (b) \ntype information is crucial for their e.ectiveness, especially pointers and structures; (c) the techniques \nare source-language independent; and (d) SSA signi.cantly improves the precision of DSA, which is .ow\u00adinsensitive."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 48,
                                "start": 45
                            }
                        ],
                        "text": "Several transformations in LLVM are based \non DSA, including Automatic Pool Allocation [30])."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 227,
                                "start": 223
                            }
                        ],
                        "text": "A key question is how much reliable type information is available in programs compiled to LLVM? LLVM includes a flow-insensitive, field-sensitive and contextsensitive points-to analysis called Data Structure Analysis (DSA) [31]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 123,
                                "start": 120
                            }
                        ],
                        "text": "LLVM includes a .ow-insensitive, .eld-sensitive and context\u00adsensitive \npoints-to analysis called Data Structure Analysis (DSA) [31]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 138,
                                "start": 134
                            }
                        ],
                        "text": "LLVM currently includes a number of interprocedural analyses, such as a context-sensitive points-to analysis (Data Structure Analysis [31]), call graph construction, and Mod/Ref analysis, and interprocedural transformations like inlining, dead global elimination, dead argument elimination, dead type elimination, constant propagation, array bounds check elimination [28], simple structure field reordering, and Auto-"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 6,
                                "start": 3
                            }
                        ],
                        "text": "10 DSA (Data Structure Analysis) is a much more complex \nanalysis, and it spends a negligible fraction of its time pro\u00adcessing the code representation itself, \nso its run times are not indicative of the e.ciency of the representation."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 23,
                                "start": 5
                            }
                        ],
                        "text": "Data Structure \nAnalysis: A Fast and Scalable Context-Sensitive Heap Analysis."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 299,
                                "start": 296
                            }
                        ],
                        "text": "The leading cause of loss of type information in the remaining programs is the use of custom \nmemory alloca\u00adtors (in 197, 254, &#38; 255), inherently non-type-safe program constructs such as using \ndi.erent structure types for the same objects in di.erent places (176, 253 &#38; 254) and impre\u00adcision \ndue to DSA (in 177 &#38; 188)."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 178,
                                "start": 175
                            }
                        ],
                        "text": "For a wide range of benchmarks, we measured the fraction of static load and store operations for which \nreliable type information about the accessed objects is available using DSA."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 28,
                                "start": 25
                            }
                        ],
                        "text": "As part of the analysis, DSA extracts LLVM types for \na subset of mem\u00adory objects in the program."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 28,
                                "start": 25
                            }
                        ],
                        "text": "Data Structure \nAnalysis (DSA) and Automatic Pool Allo\u00adcation [30], which analyze and transform programs in terms of \ntheir logical data structures."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 133,
                                "start": 115
                            }
                        ],
                        "text": "LLVM currently includes a number of interprocedural \nanalyses, such as a context-sensitive points-to analysis (Data Structure Anal\u00adysis [31]), call graph \nconstruction, and Mod/Ref analy\u00adsis, and interprocedural transformations like inlining, dead global elimination, \ndead argument elimination, dead type elimination, constant propagation, array bounds check elim\u00adination \n[28], simple structure .eld reordering, and Auto\u00ad 7Note that shared libraries and system libraries may \nnot be available for analysis at link time, or may be compiled directly to native code.  matic Pool \nAllocation [30]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 47
                            }
                        ],
                        "text": "For example, fieldsensitive points-to analyses [25, 31], call graph construction (including for object-oriented languages like C++), scalar promotion of aggregates, and structure field reordering transformations [12], only use pointers, structures, functions, and primitive data types, while array dependence"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 165,
                                "start": 162
                            }
                        ],
                        "text": "As an exam\u00adple, an earlier version \nof the LLVM C front-end was based on GCC s RTL internal representation, which provided lit\u00adtle useful \ntype information, and both DSA and pool alloca\u00adtion were much less e.ective."
                    },
                    "intents": []
                }
            ],
            "corpusId": 14824191,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5516d34a6699c317c7852c4d04a7aaa50f479334",
            "isKey": false,
            "numCitedBy": 28,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper describes a scalable heap analysis algorithm, Data Structure Analysis, designed to enable analyses and transformations of programs at the level of entire logical data structures. Data Structure Analysis attempts to identify disjoint instances of logical program data structures and their internal and external connectivity properties (without trying to categorize their \u201cshape\u201d). To achieve this, Data Structure Analysis is fully context-sensitive (in the sense that it names memory objects by entire acyclic call paths), is fieldsensitive, builds an explicit model of the heap, and is robust enough to handle the full generality of C. Despite these aggressive features, the algorithm is both extremely fast (requiring 2-7 seconds for C programs in the range of 100K lines of code) and is scalable in practice. It has three features we believe are novel: (a) it incrementally builds a precise program call graph during the analysis; (b) it distinguishes complete and incomplete information in a manner that simplifies analysis of libraries or other portions of programs; and (c) it uses speculative field-senstivity in typeunsafe programs in order to preserve efficiency and scalability. Finally, it shows that the key to achieving scalability in a fully context-sensitive algorithm is the use of a unificationbased approach, a combination that has been used before but whose importance has not been clearly articulated."
            },
            "slug": "Data-Structure-Analysis:-A-Fast-and-Scalable-Heap-Lattner-Adve",
            "title": {
                "fragments": [],
                "text": "Data Structure Analysis: A Fast and Scalable Context-Sensitive Heap Analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 67,
                "text": "A scalable heap analysis algorithm designed to enable analyses and transformations of programs at the level of entire logical data structures is described, which shows that the key to achieving scalability in a fully context-sensitive algorithm is the use of a unificationbased approach."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144226633"
                        ],
                        "name": "A. Ayers",
                        "slug": "A.-Ayers",
                        "structuredName": {
                            "firstName": "Andrew",
                            "lastName": "Ayers",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Ayers"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2171969195"
                        ],
                        "name": "Stuart de Jong",
                        "slug": "Stuart-de-Jong",
                        "structuredName": {
                            "firstName": "Stuart",
                            "lastName": "Jong",
                            "middleNames": [
                                "de"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stuart de Jong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144309692"
                        ],
                        "name": "John Peyton",
                        "slug": "John-Peyton",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Peyton",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John Peyton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2256275"
                        ],
                        "name": "R. Schooler",
                        "slug": "R.-Schooler",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Schooler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Schooler"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 10794393,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b4cb3217d77b28623da535563d23f913e1aa55c3",
            "isKey": false,
            "numCitedBy": 40,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "Large applications are typically partitioned into separately compiled modules. Large performance gains in these applications are available by optimizing across module boundaries. One barrier to applying crossmodule optimization (CMO) to large applications is the potentially enormous amount of time and space consumed by the optimization process.We describe a framework for scalable CMO that provides large gains in performance on applications that contain millions of lines of code. Two major techniques are described. First, careful management of in-memory data structures results in sub-linear memory occupancy when compared to the number of lines of code being optimized. Second, profile data is used to focus optimization effort on the performance-critical portions of applications. We also present practical issues that arise in deploying this framework in a production environment. These issues include debuggability and compatibility with existing development tools, such as make. Our framework is deployed in Hewlett-Packard's (HP) UNIX compiler products and speeds up shipped independent software vendors' applications by as much as 71%."
            },
            "slug": "Scalable-cross-module-optimization-Ayers-Jong",
            "title": {
                "fragments": [],
                "text": "Scalable cross-module optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "A framework for scalable CMO that provides large gains in performance on applications that contain millions of lines of code and is deployed in Hewlett-Packard's UNIX compiler products and speeds up shipped independent software vendors' applications by as much as 71%."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109847187"
                        ],
                        "name": "J.E. Smith",
                        "slug": "J.E.-Smith",
                        "structuredName": {
                            "firstName": "J.E.",
                            "lastName": "Smith",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J.E. Smith"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35069133"
                        ],
                        "name": "S. Sastry",
                        "slug": "S.-Sastry",
                        "structuredName": {
                            "firstName": "S.",
                            "lastName": "Sastry",
                            "middleNames": [
                                "Subramanya"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Sastry"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2942058"
                        ],
                        "name": "T. Heil",
                        "slug": "T.-Heil",
                        "structuredName": {
                            "firstName": "Timothy",
                            "lastName": "Heil",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Heil"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69019849"
                        ],
                        "name": "T. Bezenek",
                        "slug": "T.-Bezenek",
                        "structuredName": {
                            "firstName": "Todd",
                            "lastName": "Bezenek",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Bezenek"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 63,
                                "start": 38
                            }
                        ],
                        "text": "4.2.3 External ISA design \nfor Virtual Instruction Set Computers Virtual Instruction Set Computers [40, 16, 2] are proces\u00adsor designs \nthat use two distinct instruction sets: an exter\u00adnally visible, virtual instruction set (V-ISA) which \nserves as the program representation for all software, and a hid\u00adden implementation-speci.c instruction \nset (I-ISA) that is the actual hardware ISA."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 45,
                                "start": 34
                            }
                        ],
                        "text": "Virtual Instruction Set Computers [40, 16, 2] are processor designs that use two distinct instruction sets: an externally visible, virtual instruction set (V-ISA) which serves as the program representation for all software, and a hidden implementation-specific instruction set (I-ISA) that is the actual hardware ISA."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1606117,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "140944f7d6eb92000ac28c60ba9c3e5dae8906e6",
            "isKey": true,
            "numCitedBy": 37,
            "numCiting": 60,
            "paperAbstract": {
                "fragments": [],
                "text": "A virtual machine (VM) uses software to support a virtual instruction set architecture on a hardware platjonn executing a native instruction set. By co-designing the hardware and software elements of a VM, and by using an implementation-dependent native instruction set, there will be many new opportunities for improved performance and flexibility. Because the hardware-supported instruction set is implementation dependent, performance optimizations can be more easily passed from software through to hardware, and performance feedback infonnation can be more easily passed from hardware up to the software. Furthermore, optimizations can be performed by software dynamically, as the program runs. A codesigned virtual machine may include adaptive hardware Performance features, continuous hardware performance feedback, and on-the-fly optimizing re-compilation by the VM. Hardware and software can cooperate in jinding instruction level parallelism across large blocks of dynamic instructions, and can eflciently implement of a number of advanced microarchitecture techniques involving control independence, prediction, speculation, and cache hierarchy management."
            },
            "slug": "Achieving-high-performance-via-co-designed-virtual-Smith-Sastry",
            "title": {
                "fragments": [],
                "text": "Achieving high performance via co-designed virtual machines"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "A codesigned virtual machine may include adaptive hardware Performance features, continuous hardware performance feedback, and on-the-fly optimizing re-compilation by the VM."
            },
            "venue": {
                "fragments": [],
                "text": "Innovative Architecture for Future Generation High-Performance Processors and Systems"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2042452"
                        ],
                        "name": "David L. Heine",
                        "slug": "David-L.-Heine",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Heine",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David L. Heine"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1636685,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "12b3a54b72f2fc99c2c689731d6df5e3d7e1dfa8",
            "isKey": false,
            "numCitedBy": 175,
            "numCiting": 28,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents a static analysis tool that can automatically find memory leaks and deletions of dangling pointers in large C and C++ applications.We have developed a type system to formalize a practical ownership model of memory management. In this model, every object is pointed to by one and only one owning pointer, which holds the exclusive right and obligation to either delete the object or to transfer the right to another owning pointer. In addition, a pointer-typed class member field is required to either always or never own its pointee at public method boundaries. Programs satisfying this model do not leak memory or delete the same object more than once.We have also developed a flow-sensitive and context-sensitive algorithm to automatically infer the likely ownership interfaces of methods in a program. It identifies statements inconsistent with the model as sources of potential leaks or double deletes. The algorithm is sound with respect to a large subset of the C and C++ language in that it will report all possible errors. It is also practical and useful as it identifies those warnings likely to correspond to errors and helps the user understand the reported errors by showing them the assumed method interfaces.Our techniques are validated with an implementation of a tool we call Clouseau. We applied Clouseau to a suite of applications: two web servers, a chat client, secure shell tools, executable object manipulation tools, and a compiler. The tool found a total of 134 serious memory errors in these applications. The tool analyzes over 50K lines of C++ code in about 9 minutes on a 2 GHz Pentium 4 machine and over 70K lines of C code in just over a minute."
            },
            "slug": "A-practical-flow-sensitive-and-context-sensitive-C-Heine-Lam",
            "title": {
                "fragments": [],
                "text": "A practical flow-sensitive and context-sensitive C and C++ memory leak detector"
            },
            "tldr": {
                "abstractSimilarityScore": 69,
                "text": "A static analysis tool that can automatically find memory leaks and deletions of dangling pointers in large C and C++ applications and develops a flow-sensitive and context-sensitive algorithm to automatically infer the likely ownership interfaces of methods in a program."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '03"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2861277"
                        ],
                        "name": "T. Kistler",
                        "slug": "T.-Kistler",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Kistler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Kistler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2060899412"
                        ],
                        "name": "M. Franz",
                        "slug": "M.-Franz",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Franz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Franz"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 196,
                                "start": 192
                            }
                        ],
                        "text": "Kistler and Franz describe a compilation architecture for performing optimization in the field, using simple initial load-time code generation, followed by profile-guided runtime optimization [27]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 6046607,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a4aadc836ddee9f9b9a9ed0d8020fd053fbf4b92",
            "isKey": false,
            "numCitedBy": 107,
            "numCiting": 106,
            "paperAbstract": {
                "fragments": [],
                "text": "Much of the software in everyday operation is not making optimal use of the hardware on which it actually runs. Among the reasons for this discrepancy are hardware/software mismatches, modularization overheads introduced by software engineering considerations, and the inability of systems to adapt to users' behaviors.A solution to these problems is to delay code generation until load time. This is the earliest point at which a piece of software can be fine-tuned to the actual capabilities of the hardware on which it is about to be executed, and also the earliest point at wich modularization overheads can be overcome by global optimization.A still better match between software and hardware can be achieved by replacing the already executing software at regular intervals by new versions constructed on-the-fly using a background code re-optimizer. This not only enables the use of live profiling data to guide optimization decisions, but also facilitates adaptation to changing usage patterns and the late addition of dynamic link libraries.This paper presents a system that provides code generation at load-time and continuous program optimization at run-time. First, the architecture of the system is presented. Then, two optimization techniques are discussed that were developed specifically in the context of continuous optimization. The first of these optimizations continually adjusts the storage layouts of dynamic data structures to maximize data cache locality, while the second performs profile-driven instruction re-scheduling to increase instruction-level parallelism. These two optimizations have very different cost/benefit ratios, presented in a series of benchmarks. The paper concludes with an outlook to future research directions and an enumeration of some remaining research problems.The empirical results presented in this paper make a case in favor of continuous optimization, but indicate that it needs to be applied judiciously. In many situations, the costs of dynamic optimizations outweigh their benefit, so that no break-even point is ever reached. In favorable circumstances, on the other hand, speed-ups of over 120% have been observed. It appears as if the main beneficiaries of continuous optimization are shared libraries, which at different times can be optimized in the context of the currently dominant client application."
            },
            "slug": "Continuous-program-optimization:-A-case-study-Kistler-Franz",
            "title": {
                "fragments": [],
                "text": "Continuous program optimization: A case study"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "A system that provides code generation at load-time and continuous program optimization at run-time is presented, and a case in favor of continuous optimization is made, but it needs to be applied judiciously."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1765246"
                        ],
                        "name": "Chris Lattner",
                        "slug": "Chris-Lattner",
                        "structuredName": {
                            "firstName": "Chris",
                            "lastName": "Lattner",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chris Lattner"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 90,
                                "start": 86
                            }
                        ],
                        "text": "Several transformations in LLVM are based on DSA, including Automatic Pool Allocation [30])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 85,
                                "start": 60
                            }
                        ],
                        "text": "Several transformations in LLVM are based \non DSA, including Automatic Pool Allocation [30])."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 25,
                                "start": 0
                            }
                        ],
                        "text": "Automatic Pool Allocation for Disjoint Data Structures."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 101
                            }
                        ],
                        "text": "be difficult otherwise, such as reordering two fields of a structure or optimizing memory management [12, 30]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 64,
                                "start": 60
                            }
                        ],
                        "text": "Data Structure Analysis (DSA) and Automatic Pool Allocation [30], which analyze and transform programs in terms of their logical data structures."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 59,
                                "start": 34
                            }
                        ],
                        "text": "Data Structure \nAnalysis (DSA) and Automatic Pool Allo\u00adcation [30], which analyze and transform programs in terms of \ntheir logical data structures."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 237,
                                "start": 233
                            }
                        ],
                        "text": "Other applications of static analysis are fundamentally interprocedural, and are therefore most convenient to perform at link-time (examples include static debugging, static leak detection [24], and memory management transformations [30])."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8492899,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d12c194de115bc60a566a67e98afe0cbcc884e1c",
            "isKey": false,
            "numCitedBy": 30,
            "numCiting": 46,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents an analysis technique and a novel program transformation that can enable powerful optimizations for entire linked data structures. The fully automatic transformation converts ordinary programs to use pool (aka region) allocation for heap-based data structures. The transformation relies on an efficient link-time interprocedural analysis to identify disjoint data structures in the program, to check whether these data structures are accessed in a type-safe manner, and to construct a Disjoint Data Structure Graph that describes the connectivity pattern within such structures. We present preliminary experimental results showing that the data structure analysis and pool allocation are effective for a set of pointer intensive programs in the Olden benchmark suite. To illustrate the optimizations that can be enabled by these techniques, we describe a novel pointer compression transformation and briefly discuss several other optimization possibilities for linked data structures."
            },
            "slug": "Automatic-pool-allocation-for-disjoint-data-Lattner-Adve",
            "title": {
                "fragments": [],
                "text": "Automatic pool allocation for disjoint data structures"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "Preliminary experimental results are presented showing that the data structure analysis and pool allocation are effective for a set of pointer intensive programs in the Olden benchmark suite."
            },
            "venue": {
                "fragments": [],
                "text": "MSP '02"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2052753016"
                        ],
                        "name": "David R. Chase",
                        "slug": "David-R.-Chase",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Chase",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David R. Chase"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34798639"
                        ],
                        "name": "Mick J. Jordan",
                        "slug": "Mick-J.-Jordan",
                        "structuredName": {
                            "firstName": "Mick",
                            "lastName": "Jordan",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mick J. Jordan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2778410"
                        ],
                        "name": "Wayne Gramlich",
                        "slug": "Wayne-Gramlich",
                        "structuredName": {
                            "firstName": "Wayne",
                            "lastName": "Gramlich",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Wayne Gramlich"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "113767307"
                        ],
                        "name": "Kinman Chung",
                        "slug": "Kinman-Chung",
                        "structuredName": {
                            "firstName": "Kinman",
                            "lastName": "Chung",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kinman Chung"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "117863651"
                        ],
                        "name": "H. Gayle",
                        "slug": "H.-Gayle",
                        "structuredName": {
                            "firstName": "H",
                            "lastName": "Gayle",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Gayle"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "114406956"
                        ],
                        "name": "Peter Kiehtreiber",
                        "slug": "Peter-Kiehtreiber",
                        "structuredName": {
                            "firstName": "Peter",
                            "lastName": "Kiehtreiber",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Peter Kiehtreiber"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "stack unwinding (though LLVM-to-native code generators may use either \u201czero cost\u201d table-driven methods [9] or setjmp/longjmp to implement the instructions)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 50125860,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0f1fc934a4ccdf99c28ecf6972ad583d4b80e17e",
            "isKey": false,
            "numCitedBy": 10,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Exception-handling is a feature found in one form or another in various languages. Recent examples include Ada, Modula-2+, C++, Modula-3 and Eiffel. These languages all share the \u201ctermination model\u201d of exception handling, where control transfers into the scope of the handler and activation records separating the exceptional event from its handler are discarded. One important goal for exception-handling is that the unexceptional case should execute as quickly as possible, and it is generally assumed that execution of the exceptional case may be made more expensive to further this goal (the Modula-3 report provides guidelines, both to implementors and programmers\u2014it suggests that 10000 instructions may be spent in the exceptional case to save one instruction in the normal case). Another important goal is that a debugger should be able to manipulate exceptional events\u2014given an exception, it should be able to determine where the exception will be caught (if anywhere) and if an exception will not be caught, then the debugger should be notified of this event in the context in which the exception was raised. It is desirable that exception-handling not impede optimization of programs, and there are situations in which support for asynchronous exceptions would be useful. This article discusses implementation techniques for exception handling, and how these goals are met (or not). Specific examples (at the machine-code level) will be presented in terms of Sparc assembly language and the Sparc System V Release 4 Processor-specific Applications Binary Interface (abbreviated as \u201cthe ABI\u201d). The ABI (and machines which implement it, or the very-similar SunOS 4.x calling conventions) are widely available, and the author is extremely familiar with the details of this architecture and ABI. (The important things to know for most examples in this article are that call writes the current PC into register %o7, executes the next (delay slot) instruction, and transfers control to the target of the call. The standard callee-side linkage includes a save instruction, which renames register %o7 to be %i7.) I don\u2019t know of any good references describing most of the techniques discussed in this paper. Most of what I learned, I either learned from or in the"
            },
            "slug": "Implementation-of-exception-handling-Chase-Jordan",
            "title": {
                "fragments": [],
                "text": "Implementation of exception handling"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "This article discusses implementation techniques for exception handling, and how these goals are met (or not)."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2003
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "24981170"
                        ],
                        "name": "D. W. Wall",
                        "slug": "D.-W.-Wall",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Wall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. W. Wall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 252,
                                "start": 237
                            }
                        ],
                        "text": "Some operate on assembly code for a given processor [36, 41, 14, 37] (focusing primarily on machinedependent optimizations), while others export additional information from the static compiler, either in the form of an IR or annotations [44, 21, 5, 26]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7976499,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "83c970a83e1949f59dc5964b4b61865213dce835",
            "isKey": false,
            "numCitedBy": 194,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "In previous work in global register allocation, the compiler colors a conflict graph constructed from liveness dataflow information, in order to allocate the same register to many variables that are not simultaneously live. If two procedures are in separately compiled modules, however, the compiler must do this allocation separately for each procedure. As a result, the two procedures might use different registers for the same global, or the same register for different locals.\nWe can remove these problems if we delay the register allocation until link time. Our compiler produces object modules that can be linked and run without global register allocation, but includes with each object module a body of information describing how the module uses variables and procedures. A link-time register allocator then decides which variables are used most frequently, selects registers for them, and rewrites the code to reflect the decision that these variables reside in registers rather than in memory. Construction of the call graph allows us to use the same register for locals of procedures that are not simultaneously active, giving us most of the advantages of a full-scale coloring without the expense.\nWhen we use our method for 52 registers, our benchmarks speed up by 10 to 25 percent. Even with only 8 registers, the speedup can be nearly that large if we use previously collected profile information to guide the allocation. We cannot do much better, because programs whose variables all fit in registers rarely speed up by more than 30%. Moreover, profiling shows us that we usually remove 60% to 90% of the loads and stores of scalar variables that the program performs during its execution, and often much more."
            },
            "slug": "Global-register-allocation-at-link-time-Wall",
            "title": {
                "fragments": [],
                "text": "Global register allocation at link time"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Construction of the call graph allows us to use the same register for locals of procedures that are not simultaneously active, giving us most of the advantages of a full-scale coloring without the expense."
            },
            "venue": {
                "fragments": [],
                "text": "SIGPLAN '86"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1710751"
                        ],
                        "name": "R. DeLine",
                        "slug": "R.-DeLine",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "DeLine",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. DeLine"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1741655"
                        ],
                        "name": "Manuel F\u00e4hndrich",
                        "slug": "Manuel-F\u00e4hndrich",
                        "structuredName": {
                            "firstName": "Manuel",
                            "lastName": "F\u00e4hndrich",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Manuel F\u00e4hndrich"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 50,
                                "start": 42
                            }
                        ],
                        "text": "to avoid using interprocedural techniques [17, 23])."
                    },
                    "intents": []
                }
            ],
            "corpusId": 2097396,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "34ea8ffd27f9bbb7fef494cfca41bed5f356be56",
            "isKey": false,
            "numCitedBy": 479,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "The reliability of infrastructure software, such as operating systems and web servers, is often hampered by the mismanagement of resources, such as memory and network connections. The Vault programming language allows a programmer to describe resource management protocols that the compiler can statically enforce. Such a protocol can specify that operations must be performed in a certain order and that certain operations must be performed before accessing a given data object. Furthermore, Vault enforces statically that resources cannot be leaked. We validate the utility of our approach by enforcing protocols present in the interface between the Windows 2000 kernel and its device drivers."
            },
            "slug": "Enforcing-high-level-protocols-in-low-level-DeLine-F\u00e4hndrich",
            "title": {
                "fragments": [],
                "text": "Enforcing high-level protocols in low-level software"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "The utility of this approach is validated by enforcing protocols present in the interface between the Windows 2000 kernel and its device drivers, which enforces statically that resources cannot be leaked."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '01"
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145734202"
                        ],
                        "name": "L. Deutsch",
                        "slug": "L.-Deutsch",
                        "structuredName": {
                            "firstName": "L.",
                            "lastName": "Deutsch",
                            "middleNames": [
                                "Peter"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Deutsch"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2671201"
                        ],
                        "name": "A. Schiffman",
                        "slug": "A.-Schiffman",
                        "structuredName": {
                            "firstName": "Allan",
                            "lastName": "Schiffman",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Schiffman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 131,
                                "start": 127
                            }
                        ],
                        "text": "This includes type information, explicit control \n.ow graphs, and an explicit data.ow representation (using an in.nite, typed register set in Static Single \nAssignment form [15])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 3045432,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2f4002755b309cdb91e18116b8028005497d8400",
            "isKey": false,
            "numCitedBy": 602,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "The Smalltalk-80* programming language includes dynamic storage allocation, full upward funargs, and universally polymorphic procedures; the Smalltalk-80 programming system features interactive execution with incremental compilation, and implementation portability. These features of modern programming systems are among the most difficult to implement efficiently, even individually. A new implementation of the Smalltalk-80 system, hosted on a small microprocessor-based computer, achieves high performance while retaining complete (object code) compatibility with existing implementations. This paper discusses the most significant optimization techniques developed over the course of the project, many of which are applicable to other languages. The key idea is to represent certain runtime state (both code and data) in more than one form, and to convert between forms when needed."
            },
            "slug": "Efficient-implementation-of-the-smalltalk-80-system-Deutsch-Schiffman",
            "title": {
                "fragments": [],
                "text": "Efficient implementation of the smalltalk-80 system"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The most significant optimization techniques developed over the course of the Smalltalk-80 programming system are discussed, many of which are applicable to other languages."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '84"
            },
            "year": 1984
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69048861"
                        ],
                        "name": "R. Cytron",
                        "slug": "R.-Cytron",
                        "structuredName": {
                            "firstName": "Ronald",
                            "lastName": "Cytron",
                            "middleNames": [
                                "Gary"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Cytron"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144704592"
                        ],
                        "name": "J. Ferrante",
                        "slug": "J.-Ferrante",
                        "structuredName": {
                            "firstName": "Jeanne",
                            "lastName": "Ferrante",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ferrante"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1685689"
                        ],
                        "name": "B. Rosen",
                        "slug": "B.-Rosen",
                        "structuredName": {
                            "firstName": "Barry",
                            "lastName": "Rosen",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Rosen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36114502"
                        ],
                        "name": "M. Wegman",
                        "slug": "M.-Wegman",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Wegman",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wegman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2386609"
                        ],
                        "name": "F. K. Zadeck",
                        "slug": "F.-K.-Zadeck",
                        "structuredName": {
                            "firstName": "F.",
                            "lastName": "Zadeck",
                            "middleNames": [
                                "Kenneth"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. K. Zadeck"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 239,
                                "start": 235
                            }
                        ],
                        "text": "\u2026performed at link-time (to preserve the bene.ts of separate compilation), machine-dependent \noptimizations at install time on each system, dynamic optimization at run\u00adtime, and pro.le-guided optimization \nbetween runs ( idle time ) using pro.le information collected from the end-user."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 13243943,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cd65db4d7091b8f42333ed755ed7150f14b3be5c",
            "isKey": false,
            "numCitedBy": 2354,
            "numCiting": 84,
            "paperAbstract": {
                "fragments": [],
                "text": "In optimizing compilers, data structure choices directly influence the power and efficiency of practical program optimization. A poor choice of data structure can inhibit optimization or slow compilation to the point that advanced optimization features become undesirable. Recently, static single assignment form and the control dependence graph have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. Although both of these structures are attractive, the difficulty of their construction and their potential size have discouraged their use. We present new algorithms that efficiently compute these data structures for arbitrary control flow graphs. The algorithms use {\\em dominance frontiers}, a new concept that may have other applications. We also give analytical and experimental evidence that all of these data structures are usually linear in the size of the original program. This paper thus presents strong evidence that these structures can be of practical use in optimization."
            },
            "slug": "Efficiently-computing-static-single-assignment-form-Cytron-Ferrante",
            "title": {
                "fragments": [],
                "text": "Efficiently computing static single assignment form and the control dependence graph"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "New algorithms that efficiently compute static single assignment form and control dependence graph data structures for arbitrary control flow graphs are presented and it is given that all of these data structures are usually linear in the size of the original program."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39912486"
                        ],
                        "name": "T. Romer",
                        "slug": "T.-Romer",
                        "structuredName": {
                            "firstName": "Theodore",
                            "lastName": "Romer",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Romer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1739245"
                        ],
                        "name": "G. Voelker",
                        "slug": "G.-Voelker",
                        "structuredName": {
                            "firstName": "Geoffrey",
                            "lastName": "Voelker",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Voelker"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2115357197"
                        ],
                        "name": "Dennis Lee",
                        "slug": "Dennis-Lee",
                        "structuredName": {
                            "firstName": "Dennis",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dennis Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1793636"
                        ],
                        "name": "A. Wolman",
                        "slug": "A.-Wolman",
                        "structuredName": {
                            "firstName": "Alec",
                            "lastName": "Wolman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Wolman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2093341086"
                        ],
                        "name": "Wayne A. Wong",
                        "slug": "Wayne-A.-Wong",
                        "structuredName": {
                            "firstName": "Wayne",
                            "lastName": "Wong",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Wayne A. Wong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36105267"
                        ],
                        "name": "H. Levy",
                        "slug": "H.-Levy",
                        "structuredName": {
                            "firstName": "Henry",
                            "lastName": "Levy",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Levy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2990863"
                        ],
                        "name": "B. Bershad",
                        "slug": "B.-Bershad",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Bershad",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Bershad"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143852866"
                        ],
                        "name": "Brad Chen",
                        "slug": "Brad-Chen",
                        "structuredName": {
                            "firstName": "Brad",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Brad Chen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 52
                            }
                        ],
                        "text": "Some operate on assembly code for a given processor [36, 41, 14, 37] (focusing primarily on machinedependent optimizations), while others export additional information from the static compiler, either in the form of an IR or annotations [44, 21, 5, 26]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8220439,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "611d5db3b12d3727310e618807191dc93dd37911",
            "isKey": false,
            "numCitedBy": 231,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": "Etch is a general-purpose tool for rewriting arbitrary Win32/x86 binaries without requiring source code. Etch provides a framework for modifying executables for both measurement and optimization. Etch handles the complexities of the Win32 executable file format and the x86 instruction set, allowing tool builders to focus on specifying transformations. Etch also handles the complexities of the Win32 execution environment, allowing tool users to focus on performing experiments. This paper describes Etch and some of the tools that we have built using Etch, including a hierarchical call graph profiler and an instruction layout optimization tool."
            },
            "slug": "Instrumentation-and-optimization-of-Win32/intel-Romer-Voelker",
            "title": {
                "fragments": [],
                "text": "Instrumentation and optimization of Win32/intel executables using Etch"
            },
            "tldr": {
                "abstractSimilarityScore": 62,
                "text": "Etch is a general-purpose tool for rewriting arbitrary Win32/x86 binaries without requiring source code and some of the tools that are built using it are described, including a hierarchical call graph profiler and an instruction layout optimization tool."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3191220"
                        ],
                        "name": "Trishul M. Chilimbi",
                        "slug": "Trishul-M.-Chilimbi",
                        "structuredName": {
                            "firstName": "Trishul",
                            "lastName": "Chilimbi",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Trishul M. Chilimbi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47080925"
                        ],
                        "name": "Bob Davidson",
                        "slug": "Bob-Davidson",
                        "structuredName": {
                            "firstName": "Bob",
                            "lastName": "Davidson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bob Davidson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1752633"
                        ],
                        "name": "J. Larus",
                        "slug": "J.-Larus",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Larus",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Larus"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 216,
                                "start": 212
                            }
                        ],
                        "text": "For example, fieldsensitive points-to analyses [25, 31], call graph construction (including for object-oriented languages like C++), scalar promotion of aggregates, and structure field reordering transformations [12], only use pointers, structures, functions, and primitive data types, while array dependence"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 101
                            }
                        ],
                        "text": "be difficult otherwise, such as reordering two fields of a structure or optimizing memory management [12, 30]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1334698,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e704ac5d200267df68da3176c89dedcff255ff3c",
            "isKey": false,
            "numCitedBy": 263,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "A program's cache performance can be improved by changing the organization and layout of its data---even complex, pointer-based data structures. Previous techniques improved the cache performance of these structures by arranging distinct instances to increase reference locality. These techniques produced significant performance improvements, but worked best for small structures that could be packed into a cache block.This paper extends that work by concentrating on the internal organization of fields in a data structure. It describes two techniques---structure splitting and field reordering---that improve the cache behavior of structures larger than a cache block. For structures comparable in size to a cache block, structure splitting can increase the number of hot fields that can be placed in a cache block. In five Java programs, structure splitting reduced cache miss rates 10--27% and improved performance 6--18% beyond the benefits of previously described cache-conscious reorganization techniques.For large structures, which span many cache blocks, reordering fields, to place those with high temporal affinity in the same cache block can also improve cache utilization. This paper describes bbcache, a tool that recommends C structure field reorderings. Preliminary measurements indicate that reordering fields in 5 active structures improves the performance of Microsoft SQL Server 7.0 2--3%."
            },
            "slug": "Cache-conscious-structure-definition-Chilimbi-Davidson",
            "title": {
                "fragments": [],
                "text": "Cache-conscious structure definition"
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '99"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145155335"
                        ],
                        "name": "M. Hind",
                        "slug": "M.-Hind",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Hind",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Hind"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2578192"
                        ],
                        "name": "Anthony Pioli",
                        "slug": "Anthony-Pioli",
                        "structuredName": {
                            "firstName": "Anthony",
                            "lastName": "Pioli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Anthony Pioli"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 47
                            }
                        ],
                        "text": "For example, fieldsensitive points-to analyses [25, 31], call graph construction (including for object-oriented languages like C++), scalar promotion of aggregates, and structure field reordering transformations [12], only use pointers, structures, functions, and primitive data types, while array dependence analysis and loop transformations use all those plus array types."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14462399,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b5829a1f245a04266b5268098009736114feaf76",
            "isKey": false,
            "numCitedBy": 213,
            "numCiting": 52,
            "paperAbstract": {
                "fragments": [],
                "text": "During the past two decades many different pointer analysis algorithms have been published. Although some descriptions include measurements of the effectiveness of the algorithm, qualitative comparisons among algorithms are difficult because of varying infrastructure, benchmarks, and performance metrics. Without such comparisons it is not only difficult for an implementor to determine which pointer analysis is appropriate for their application, but also for a researcher to know which algorithms should be used as a basis for future advances.\nThis paper describes an empirical comparison of the effectiveness of five pointer analysis algorithms on C programs. The algorithms vary in their use of control flow information (flow-sensitivity) and alias data structure, resulting in worst-case complexity from linear to polynomial. The effectiveness of the analyses is quantified in terms of compile-time precision and efficiency. In addition to measuring the direct effects of pointer analysis, precision is also reported by determining how the information computed by the five pointer analyses affects typical client analyses of pointer information: Mod/Ref analysis, live variable analysis and dead assignment identification, reaching definitions analysis, dependence analysis, and conditional constant propagation and unreachable code identification. Efficiency is reported by measuring analysis time and memory consumption of the pointer analyses and their clients."
            },
            "slug": "Which-pointer-analysis-should-I-use-Hind-Pioli",
            "title": {
                "fragments": [],
                "text": "Which pointer analysis should I use?"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "An empirical comparison of the effectiveness of five pointer analysis algorithms on C programs is described, resulting in best-case complexity from linear to polynomial and efficiency in terms of compile-time precision and efficiency."
            },
            "venue": {
                "fragments": [],
                "text": "ISSTA '00"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2293378"
                        ],
                        "name": "T. Steel",
                        "slug": "T.-Steel",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Steel",
                            "middleNames": [
                                "B."
                            ],
                            "suffix": "Jr."
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Steel"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 94,
                                "start": 90
                            }
                        ],
                        "text": "These have largely failed, ranging from the original UNiversal Computer Oriented Language [42] (UNCOL), which was discussed but never implemented, to the more recent Architecture and language Neutral Distribution Format [4] (ANDF), which was implemented but has seen limited use."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 53
                            }
                        ],
                        "text": "These have largely \nfailed, rang\u00ading from the original UNiversal Computer Oriented Lan\u00adguage [42] (UNCOL), which was discussed \nbut never im\u00adplemented, to the more recent Architecture and language Neutral Distribution Format [4] \n(ANDF), which was im\u00adplemented but has seen limited use."
                    },
                    "intents": []
                }
            ],
            "corpusId": 62199641,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2c897818d567a0362dbb988d088493b1cb54403e",
            "isKey": false,
            "numCitedBy": 35,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "UNCOL:-The-myth-and-the-fact-Steel",
            "title": {
                "fragments": [],
                "text": "UNCOL: The myth and the fact"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1961
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48330172"
                        ],
                        "name": "Tim Lindholm",
                        "slug": "Tim-Lindholm",
                        "structuredName": {
                            "firstName": "Tim",
                            "lastName": "Lindholm",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tim Lindholm"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2553666"
                        ],
                        "name": "Frank Yellin",
                        "slug": "Frank-Yellin",
                        "structuredName": {
                            "firstName": "Frank",
                            "lastName": "Yellin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Frank Yellin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 35,
                                "start": 29
                            }
                        ],
                        "text": "The virtual registers are in Static Single Assignment (SSA) form \n[15]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 152,
                                "start": 148
                            }
                        ],
                        "text": "This includes type information, explicit control \n.ow graphs, and an explicit data.ow representation (using an in.nite, typed register set in Static Single \nAssignment form [15])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 55
                            }
                        ],
                        "text": "LLVM de.nes a common, low-level code representation in Static Single Assignment (SSA) form, with \nseveral novel features: a simple, language-independent type-system that exposes the primitives commonly \nused to implement high-level language features; an instruction for typed address arithmetic; and a simple \nmechanism that can be used to implement the exception handling features of high-level languages (and \nsetjmp/longjmp in C) uniformly and e.ciently."
                    },
                    "intents": []
                }
            ],
            "corpusId": 10630180,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9c08eff8b9f3591cdb6bff607fd53b96c9c06c52",
            "isKey": false,
            "numCitedBy": 3466,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "From the Publisher: \nThe nucleus of the Java 2 platform, the Java virtual machine is the technology that enables the Java 2 platform to host applications on any computer or operating system without rewriting or recompiling. This book was written by those directly responsible for the design and implementation of the Java virtual machine, and is the complete and definitive specification for the technology. It is an essential reference for writers of compilers for the Java programming language and implementors of the Java virtual machine. This second edition specifies the newest version of the Java virtual machine and provides a fascinating view into the inner workings of the Java 2 platform."
            },
            "slug": "The-Java-Virtual-Machine-Specification-Lindholm-Yellin",
            "title": {
                "fragments": [],
                "text": "The Java Virtual Machine Specification"
            },
            "tldr": {
                "abstractSimilarityScore": 49,
                "text": "This second edition specifies the newest version of the Java virtual machine and provides a fascinating view into the inner workings of theJava 2 platform."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1722615"
                        ],
                        "name": "D. Ungar",
                        "slug": "D.-Ungar",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Ungar",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Ungar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2108984834"
                        ],
                        "name": "Randall B. Smith",
                        "slug": "Randall-B.-Smith",
                        "structuredName": {
                            "firstName": "Randall",
                            "lastName": "Smith",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Randall B. Smith"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 142,
                                "start": 138
                            }
                        ],
                        "text": "This includes type information, explicit control \n.ow graphs, and an explicit data.ow representation (using an in.nite, typed register set in Static Single \nAssignment form [15])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 3112501,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0442ff9c4ce57e3b080523a170c4204fa83c9e55",
            "isKey": false,
            "numCitedBy": 732,
            "numCiting": 39,
            "paperAbstract": {
                "fragments": [],
                "text": "SELF is an object-oriented language for exploratory programming based on a small number of simple and concrete ideas: prototypes, slots, and behavior. Prototypes combine inheritance and instantiation to provide a framework that is simpler and more flexible than most object-oriented languages. Slots unite variables and procedures into a single construct. This permits the inheritance hierarchy to take over the function of lexical scoping in conventional languages. Finally, because SELF does not distinguish state from behavior, it narrows the gaps between ordinary objects, procedures, and closures. SELF's simplicity and expressiveness offer new insights into object-oriented computation.To thine own self be true. \u2014 William Shakespeare laggy"
            },
            "slug": "SELF:-The-power-of-simplicity-Ungar-Smith",
            "title": {
                "fragments": [],
                "text": "Self: The power of simplicity"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "Because SELF does not distinguish state from behavior, it narrows the gaps between ordinary objects, procedures, and closures, and offers new insights into object-oriented computation."
            },
            "venue": {
                "fragments": [],
                "text": "OOPSLA '87"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143935580"
                        ],
                        "name": "R. Cohn",
                        "slug": "R.-Cohn",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Cohn",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Cohn"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "5821739"
                        ],
                        "name": "D. Goodwin",
                        "slug": "D.-Goodwin",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Goodwin",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Goodwin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145819402"
                        ],
                        "name": "P. G. Lowney",
                        "slug": "P.-G.-Lowney",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Lowney",
                            "middleNames": [
                                "Geoffrey"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. G. Lowney"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145288598"
                        ],
                        "name": "Norman Rubin",
                        "slug": "Norman-Rubin",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Rubin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Norman Rubin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Some operate on assembly code for a given processor [29, 32, 12, 30] (focusing primarily on machinedependent optimizations), while others export additional information from the static compiler, either in the form of an IR or annotations) [34, 19, 4, 23]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14444073,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b488238485110f43aa014d2797d3bd4755dd9dd9",
            "isKey": false,
            "numCitedBy": 80,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "Spike is a profile-directed optimizer for Alpha/NT executables that is actively being used to optimize shipping products. Spike consists of the Spike Optimization Environment (SOE) and the Spike Optimizer. Through both a graphical interface and a command-line interface, the Spike Optimization Environment provides a simple means to instrument and optimize large applications consisting of many images. SOE manages the instrumented and optimized images as well as any profile information collected for those images, freeing the user from many tedious and error-prone tasks typically associated with profile-directed optimization. SOE also simplifies the collection of profile information with Transparent Application Substitution (TAS). With TAS, the user invokes the original version of the application and the instrumented or optimized version of the application is transparently executed in its. SOE uses the Spike Optimizer to optimize images. The Spike Optimizer performs code layout to improve instruction cache behavior [Pettis90], hot cold optimization [Cohn96] and register allocation. The optimizations are targeted at large call-intensive applications, where loops span multiple routines, and each routine contains complex control-flow. For this class of applications, Spike provides significant performance improvement, reducing execution time by as much as 20%."
            },
            "slug": "Spike:-an-optimizer-for-alpha/NT-executables-Cohn-Goodwin",
            "title": {
                "fragments": [],
                "text": "Spike: an optimizer for alpha/NT executables"
            },
            "tldr": {
                "abstractSimilarityScore": 75,
                "text": "Spike is a profile-directed optimizer for Alpha/NT executables that is actively being used to optimize shipping products, and provides significant performance improvement, reducing execution time by as much as 20%."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143935580"
                        ],
                        "name": "R. Cohn",
                        "slug": "R.-Cohn",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Cohn",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Cohn"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "5821739"
                        ],
                        "name": "D. Goodwin",
                        "slug": "D.-Goodwin",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Goodwin",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Goodwin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145819402"
                        ],
                        "name": "P. G. Lowney",
                        "slug": "P.-G.-Lowney",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Lowney",
                            "middleNames": [
                                "Geoffrey"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. G. Lowney"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 147,
                                "start": 143
                            }
                        ],
                        "text": "\u2026http://llvm.cs.uiuc.edu/ \n ABSTRACT This paper describes LLVM (Low Level Virtual Machine), a compiler framework designed to support \ntransparent, life\u00adlong program analysis and transformation for arbitrary pro\u00adgrams, by providing high-level \ninformation to compiler transformations at\u2026"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 18102621,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0f7a505425507445d7a1109c492f9ae51037daa4",
            "isKey": false,
            "numCitedBy": 73,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "Vol. 9 No. 4 1997 3 Spike is a performance tool developed by DIGITAL to optimize Alpha executables on the Windows NT operating system. This optimization system has two main components: the Spike Optimizer and the Spike Optimization Environment. The Spike Optimizer reads in an executable, optimizes the code, and writes out the optimized version. The Optimizer uses profile feedback from previous runs of an application to guide its optimizations. Profile feedback is not commonly used in practice because it is difficult to collect, manage, and apply profile information. The Spike Optimization Environment provides a user-transparent profile feedback system that solves most of these problems, allowing a user to easily optimize large applications composed of many executables and dynamic link libraries (DLLs). Optimizing an executable image after it has been compiled and linked has several advantages. The Spike Optimizer can see the entire image and perform interprocedural optimizations, particularly with regard to code layout. The Optimizer can use profile feedback easily, because the executable that is profiled is the same executable that is optimized; no awkward mapping of profile data back to the source language takes place. Also, Spike can be used when the sources to an application are not available, which is beneficial when DIGITAL is working with independent software vendors (ISVs) to tune applications. Applications can be loosely classified into two categories: loop-intensive programs and call-intensive programs. Conventional compiler technology is well suited to loop-intensive programs. The important loops in a program in this category are within a single procedure, which is typically the unit of compilation. The control flow is predictable, and the compiler can use simple heuristics to determine the frequently executed parts of the procedure. Spike is designed for large, call-intensive programs; it uses interprocedural optimization and profile feedback. In call-intensive programs, the important loops span multiple procedures, and the loop bodies contain procedure calls. Consequently, optimizations on the loops must be interprocedural. The control flow is Optimizing Alpha Executables on Windows NT with Spike Robert S. Cohn David W. Goodwin P. Geoffrey Lowney"
            },
            "slug": "Optimizing-Alpha-Executables-on-Windows-NT-with-Cohn-Goodwin",
            "title": {
                "fragments": [],
                "text": "Optimizing Alpha Executables on Windows NT with Spike"
            },
            "venue": {
                "fragments": [],
                "text": "Digit. Tech. J."
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145426175"
                        ],
                        "name": "R. Muth",
                        "slug": "R.-Muth",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Muth",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Muth"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1695853"
                        ],
                        "name": "S. Debray",
                        "slug": "S.-Debray",
                        "structuredName": {
                            "firstName": "Saumya",
                            "lastName": "Debray",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Debray"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1416893,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "16314fc2bfaf094b15478d4377d50533cce9302b",
            "isKey": false,
            "numCitedBy": 26,
            "numCiting": 85,
            "paperAbstract": {
                "fragments": [],
                "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 CHAPTER 1: INTRODUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . 14 1.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 1.2 Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 1.3 Contributions of Alto . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 CHAPTER 2: OVERVIEW OF THE ALTO SYSTEM . . . . . . . . . . . . . . 30 2.1 Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 2.1.1 Code Discovery . . . . . . . . . . . . . . . . . . . . . . . . . 32 2.1.2 Control Flow Graph Construction . . . . . . . . . . . . . . . 32 2.1.3 Computed Indirect Jumps . . . . . . . . . . . . . . . . . . . . 36 2.1.4 Control Flow Anomalies . . . . . . . . . . . . . . . . . . . . 36 2.2 Editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 2.2.1 Scale Problems . . . . . . . . . . . . . . . . . . . . . . . . . 38 2.2.2 Self Modifying Code . . . . . . . . . . . . . . . . . . . . . . 40 2.3 Code Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 2.3.1 Address Translation . . . . . . . . . . . . . . . . . . . . . . . 41 2.3.2 Segment Growing . . . . . . . . . . . . . . . . . . . . . . . . 43"
            },
            "slug": "Alto:-a-platform-for-object-code-modification-Muth-Debray",
            "title": {
                "fragments": [],
                "text": "Alto: a platform for object code modification"
            },
            "tldr": {
                "abstractSimilarityScore": 37,
                "text": "The author reveals how the design of the Alto system evolved from a simple model to a system that addressed many of the challenges faced in the rapidly changing world of web development."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3282821"
                        ],
                        "name": "W. Amme",
                        "slug": "W.-Amme",
                        "structuredName": {
                            "firstName": "Wolfram",
                            "lastName": "Amme",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Amme"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145213451"
                        ],
                        "name": "N. Dalton",
                        "slug": "N.-Dalton",
                        "structuredName": {
                            "firstName": "Niall",
                            "lastName": "Dalton",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Dalton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2060899412"
                        ],
                        "name": "M. Franz",
                        "slug": "M.-Franz",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Franz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Franz"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1792494"
                        ],
                        "name": "J. Ronne",
                        "slug": "J.-Ronne",
                        "structuredName": {
                            "firstName": "Jeffery",
                            "lastName": "Ronne",
                            "middleNames": [
                                "von"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ronne"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 11,
                                "start": 4
                            }
                        ],
                        "text": "The SafeTSA \n[3] representation is a combination of type information with SSA form, which aims to provide a safe but \nmore e.cient representation than JVM bytecode for Java programs."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 15,
                                "start": 12
                            }
                        ],
                        "text": "The SafeTSA [3] representation is a combination of type information with SSA form, which aims to provide a safe but more efficient representation than JVM bytecode for Java programs."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 7,
                                "start": 0
                            }
                        ],
                        "text": "SafeTSA: \nA type safe and referentially secure mobile-code representation based on static single assignment form."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 259,
                                "start": 256
                            }
                        ],
                        "text": "\u2022 Higher-level virtual machines like JVM and CLI provide benefit #3 and partially provide #1 (in particular, they focus on runtime optimization, because the need for bytecode verification greatly restricts the optimizations that may be done before runtime [3])."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 582614,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e00a51f450e7503a4f37fcfc01ada25b24becf6b",
            "isKey": true,
            "numCitedBy": 104,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "This tines assembly is for attachment to a drive shaft and includes a front shaft portion, a rear shaft portion connected between the front shaft portion and the drive shaft, and front and rear tines mounted in removable relation to the rear shaft portion. The front tines, front shaft and rear shaft are connected and located by a pin, and the rear tines, rear shaft and drive shaft are connected and located by a pin."
            },
            "slug": "SafeTSA:-a-type-safe-and-referentially-secure-based-Amme-Dalton",
            "title": {
                "fragments": [],
                "text": "SafeTSA: a type safe and referentially secure mobile-code representation based on static single assignment form"
            },
            "tldr": {
                "abstractSimilarityScore": 97,
                "text": "This tines assembly is for attachment to a drive shaft and includes a front shaft portion, a rear shaft portion connected between the front shaft and the drive shaft, and front and rear tines mounted in removable relation to the rear shaft portions."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '01"
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2060899412"
                        ],
                        "name": "M. Franz",
                        "slug": "M.-Franz",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Franz",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Franz"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2861277"
                        ],
                        "name": "T. Kistler",
                        "slug": "T.-Kistler",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Kistler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Kistler"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 61
                            }
                        ],
                        "text": "Their system targets the Oberon language, uses Slim Binaries [22] as its code representation, and provides type safety and memory management similar to other high-level virtual machines."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 60,
                                "start": 47
                            }
                        ],
                        "text": "Their system targets \nthe Oberon language, uses Slim Binaries [22] as its code representation, and provides type safety and \nmemory management similar to other high-level virtual machines."
                    },
                    "intents": []
                }
            ],
            "corpusId": 10418624,
            "fieldsOfStudy": [
                "Geology",
                "Computer Science",
                "Linguistics"
            ],
            "id": "1955247dc923423b7aeb5b99105b872cb88c7b94",
            "isKey": false,
            "numCitedBy": 177,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "syntax tree data dictionary object file write sequence update dictionary find best sequence write interface add symbols i, j, P := i 1 i+1 P(\u2022) i+1 +"
            },
            "slug": "Slim-binaries-Franz-Kistler",
            "title": {
                "fragments": [],
                "text": "Slim binaries"
            },
            "venue": {
                "fragments": [],
                "text": "CACM"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144331168"
                        ],
                        "name": "A. Chernoff",
                        "slug": "A.-Chernoff",
                        "structuredName": {
                            "firstName": "Anton",
                            "lastName": "Chernoff",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Chernoff"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3083320"
                        ],
                        "name": "Mark A. Herdeg",
                        "slug": "Mark-A.-Herdeg",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Herdeg",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mark A. Herdeg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2458903"
                        ],
                        "name": "R. Hookway",
                        "slug": "R.-Hookway",
                        "structuredName": {
                            "firstName": "Raymond",
                            "lastName": "Hookway",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Hookway"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40025080"
                        ],
                        "name": "Chris Reeve",
                        "slug": "Chris-Reeve",
                        "structuredName": {
                            "firstName": "Chris",
                            "lastName": "Reeve",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chris Reeve"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145288598"
                        ],
                        "name": "Norman Rubin",
                        "slug": "Norman-Rubin",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Rubin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Norman Rubin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145302659"
                        ],
                        "name": "T. Tye",
                        "slug": "T.-Tye",
                        "structuredName": {
                            "firstName": "Tony",
                            "lastName": "Tye",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Tye"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145020093"
                        ],
                        "name": "S. B. Yadavalli",
                        "slug": "S.-B.-Yadavalli",
                        "structuredName": {
                            "firstName": "S.",
                            "lastName": "Yadavalli",
                            "middleNames": [
                                "Bharadwaj"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. B. Yadavalli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143613690"
                        ],
                        "name": "John Yates",
                        "slug": "John-Yates",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Yates",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John Yates"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 148,
                                "start": 144
                            }
                        ],
                        "text": "\u2026the design in three ways: \n(a) the size and e.ectiveness of the representation, including the type information it provides; (b) \ncompiler performance for several interprocedural problems; and (c) illustrative exam\u00adples of the bene.ts \nLLVM provides for several challenging compiler problems."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6146642,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "df7eba8343d5e4be442f8f96ca68dcffcd60d0df",
            "isKey": false,
            "numCitedBy": 216,
            "numCiting": 8,
            "paperAbstract": {
                "fragments": [],
                "text": "A new innovation from Digital allows most x86 Windows applications to run on Alpha platforms with good performance."
            },
            "slug": "FX!32-a-profile-directed-binary-translator-Chernoff-Herdeg",
            "title": {
                "fragments": [],
                "text": "FX!32 a profile-directed binary translator"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "A new innovation from Digital allows most x86 Windows applications to run on Alpha platforms with good performance."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Micro"
            },
            "year": 1998
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 113,
                                "start": 110
                            }
                        ],
                        "text": "We are currently ex\u00adploring the potential bene.ts of implementing higher-level \nvirtual machines such as JVM or CLI on top of LLVM."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 25,
                                "start": 22
                            }
                        ],
                        "text": "Un\u00admanaged mode allows CLI to represent code in arbitrary lan\u00adguages, \nincluding those that do not conform to its type sys\u00adtem or runtime framework, e.g., ANSI-standard C++ \n[34]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 110,
                                "start": 107
                            }
                        ],
                        "text": "We are currently exploring \nwhether LLVM can be bene.cial for implementing dynamic runtimes such as JVM and CLI."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 102,
                                "start": 99
                            }
                        ],
                        "text": "All timings were collected on a 3.06GHz Intel \nScheme, the ML family, SmallTalk, Java and Microsoft CLI."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 59,
                                "start": 56
                            }
                        ],
                        "text": "Additionally, programs in these representations (except CLI) are required to be type\u00adsafe."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "CLI partially provides #5 \nbecause it can support code in multiple languages, but any low-level system code and   Figure 4: LLVM \nsystem architecture diagram code in non-conforming languages is executed as un\u00admanaged code ."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 59,
                                "start": 55
                            }
                        ],
                        "text": ", SmallTalk [18], Self [43], JVM [32], Microsoft\u2019s CLI [33], and others), and not an alternative to these systems."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 55
                            }
                        ],
                        "text": "Such code \nis represented in native form and not in the CLI intermediate representation, so it is not exposed to \nCLI optimizations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 78,
                                "start": 75
                            }
                        ],
                        "text": "A second key di.erence is that LLVM lacks the interoperability features of CLI but also does \nnot require source-languages to match the runtime and object model for interoperability."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 46,
                                "start": 43
                            }
                        ],
                        "text": "Higher-level virtual machines like JVM and CLI pro\u00advide bene.t"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 14
                            }
                        ],
                        "text": "The Microsoft CLI virtual machine \nhas a number of fea\u00adtures that distinguish it from other high-level virtual ma\u00adchines, including explicit \nsupport for a wide range of features from multiple languages, language interoperability support, non-type-safe \ncode, and unmanaged execution mode."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 164,
                                "start": 161
                            }
                        ],
                        "text": "Because of the di.ering goals and representations, LLVM is \ncomplementary to high-level virtual machines (e.g., Small-Talk [18], Self [43], JVM [32], Microsoft s \nCLI [33], and oth\u00aders), and not an alternative to these systems."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 46,
                                "start": 43
                            }
                        ],
                        "text": "High-level virtual machines such as JVM or CLI provide"
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 184,
                                "start": 181
                            }
                        ],
                        "text": "As noted in the introduction, the goals of LLVM are com\u00adplementary \nto those of higher-level language virtual ma\u00adchines such as SmallTalk, Self, JVM, and the managed mode \nof Microsoft CLI."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 58
                            }
                        ],
                        "text": "However, code in unmanaged mode is not represented in the CLI intermediate representation (MSIL), \nand therefore is not subject to dynamic optimization in CLI."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": true,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A technical overview of the Commmon"
            },
            "venue": {
                "fragments": [],
                "text": "Language Infrastructure,"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1643921721"
                        ],
                        "name": "MorrisettGreg",
                        "slug": "MorrisettGreg",
                        "structuredName": {
                            "firstName": "",
                            "lastName": "MorrisettGreg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "MorrisettGreg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "123280695"
                        ],
                        "name": "WalkerDavid",
                        "slug": "WalkerDavid",
                        "structuredName": {
                            "firstName": "",
                            "lastName": "WalkerDavid",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "WalkerDavid"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1643944775"
                        ],
                        "name": "CraryKarl",
                        "slug": "CraryKarl",
                        "structuredName": {
                            "firstName": "",
                            "lastName": "CraryKarl",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "CraryKarl"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1643848725"
                        ],
                        "name": "GlewNeal",
                        "slug": "GlewNeal",
                        "structuredName": {
                            "firstName": "",
                            "lastName": "GlewNeal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "GlewNeal"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 20,
                                "start": 17
                            }
                        ],
                        "text": "A provably sound TAL for back-end optimization."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 48,
                                "start": 45
                            }
                        ],
                        "text": "Pro jects on typed assembly lan\u00adguages (e.g., TAL [35] and LTAL [10]) focus on \npreserving high-level type information and type safety during compi\u00adlation and optimizations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 10,
                                "start": 6
                            }
                        ],
                        "text": ", TAL [35] and LTAL [10]) focus on preserving high-level type information and type safety during compilation and optimizations."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 215896794,
            "fieldsOfStudy": [
                "Linguistics"
            ],
            "id": "c6600b0979f5cb7618cbbff98427518452deb2ce",
            "isKey": true,
            "numCitedBy": 702,
            "numCiting": 78,
            "paperAbstract": {
                "fragments": [],
                "text": "We motivate the design of typed assembly language (TAL) and present a type-preserving ttranslation from Systemn F to TAL. The typed assembly language we pressent is based on a conventional RISC ass..."
            },
            "slug": "From-system-F-to-typed-assembly-language-MorrisettGreg-WalkerDavid",
            "title": {
                "fragments": [],
                "text": "From system F to typed assembly language"
            },
            "tldr": {
                "abstractSimilarityScore": 70,
                "text": "The design of typed assembly language (TAL) is motivated and a type-preserving ttranslation from Systemn F to TAL is presented, based on a conventional RISC architecture."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3310105"
                        ],
                        "name": "K. Ebcioglu",
                        "slug": "K.-Ebcioglu",
                        "structuredName": {
                            "firstName": "Kemal",
                            "lastName": "Ebcioglu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Ebcioglu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1682451"
                        ],
                        "name": "E. Altman",
                        "slug": "E.-Altman",
                        "structuredName": {
                            "firstName": "Erik",
                            "lastName": "Altman",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Altman"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 153,
                                "start": 149
                            }
                        ],
                        "text": "\u2026the design in three ways: \n(a) the size and e.ectiveness of the representation, including the type information it provides; (b) \ncompiler performance for several interprocedural problems; and (c) illustrative exam\u00adples of the bene.ts \nLLVM provides for several challenging compiler problems."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 52861112,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "efecca9c50a6b9310226f0273c7125f4be079e69",
            "isKey": false,
            "numCitedBy": 355,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "DAISY:-Dynamic-Compilation-for-100-Architectural-Ebcioglu-Altman",
            "title": {
                "fragments": [],
                "text": "DAISY: Dynamic Compilation for 100% Architectural Compatibility"
            },
            "venue": {
                "fragments": [],
                "text": "ISCA"
            },
            "year": 1997
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "corpusId": 53223267,
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Dynamo: a transparent dynamic optimization system"
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '00"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145841853"
                        ],
                        "name": "M. Burke",
                        "slug": "M.-Burke",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Burke",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Burke"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1750325"
                        ],
                        "name": "Linda Torczon",
                        "slug": "Linda-Torczon",
                        "structuredName": {
                            "firstName": "Linda",
                            "lastName": "Torczon",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Linda Torczon"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 122,
                                "start": 119
                            }
                        ],
                        "text": "This technique can dramatically speed up incremental compilation when a small number of translation units are modified [7]."
                    },
                    "intents": []
                }
            ],
            "corpusId": 5390362,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c5190c993471c816694f6e7f09a671e1aeb5ef26",
            "isKey": false,
            "numCitedBy": 65,
            "numCiting": 56,
            "paperAbstract": {
                "fragments": [],
                "text": "While efficient new algorithms for interprocedural data-flow analysis have made these techniques practical for use in production compilation systems, a new problem has arisen: collecting and using interprocedural information in a compiler introduces subtle dependences among the procedures of a program. If the compiler depends on interprocedural information to optimize a given module, a subsequent editing change to another module in the program may change the interprocedural information and necessitate recompilation. To avoid having to recompile every module in a program in response to a single editing change to one module, we have developed techniques to more precisely determine which compilations have actually been invalidated by a change to the program's source"
            },
            "slug": "Interprocedural-optimization:-eliminating-Burke-Torczon",
            "title": {
                "fragments": [],
                "text": "Interprocedural optimization: eliminating unnecessary recompilation"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "This work has developed techniques to more precisely determine which compilations have actually been invalidated by a change to the program's source."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1993
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Instrumentation and optimization of Win 32 / Intel executables using Etch Implementing Typed Intermediate Languages"
            },
            "venue": {
                "fragments": [],
                "text": "International Conference on Functional Programming"
            },
            "year": 1999
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 162,
                                "start": 151
                            }
                        ],
                        "text": "\u2022 Several commercial compilers provide the additional benefit of #1 and #5 at link-time by exporting their intermediate representation to object files [21, 5, 26] and performing optimizations at link-time."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 48,
                                "start": 37
                            }
                        ],
                        "text": "Link-time interprocedural optimizers [21, 5, 26], common in commercial compilers, provide the additional capability of #1 and #5 but only up to link-time."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 252,
                                "start": 237
                            }
                        ],
                        "text": "Some operate on assembly code for a given processor [36, 41, 14, 37] (focusing primarily on machinedependent optimizations), while others export additional information from the static compiler, either in the form of an IR or annotations [44, 21, 5, 26]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "XL FORTRAN: Eight Ways to Boost Performance"
            },
            "venue": {
                "fragments": [],
                "text": "White Paper,"
            },
            "year": 2000
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Implementation of exception handling. The Journal of C Language Translation"
            },
            "venue": {
                "fragments": [],
                "text": "Implementation of exception handling. The Journal of C Language Translation"
            },
            "year": 1994
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "6 In contrast, typical JVM implementations convert from the stack-based bytecode language used offline to an appropriate representation for compiler transformations, and some even convert to SSA form for this purpose (e.g., [ 8 ])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Jalape\u00f1o Dynamic Optimizing Compiler for Java"
            },
            "venue": {
                "fragments": [],
                "text": "The Jalape\u00f1o Dynamic Optimizing Compiler for Java"
            },
            "year": 1999
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Lightweight, cross-procedure tracing for runtime optimization. Master's thesis"
            },
            "venue": {
                "fragments": [],
                "text": "Comp. Sci. Dept., Univ. of Illinois at Urbana-Champ aign"
            },
            "year": 2003
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 147,
                                "start": 143
                            }
                        ],
                        "text": "As a program executes, the most frequently executed execution paths are identified through a combination of offline and online instrumentation [39]."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Lightweight, cross-procedure tracing for runtime optimization"
            },
            "venue": {
                "fragments": [],
                "text": "Master\u2019s thesis, Comp. Sci. Dept., Univ. of Illinois at Urbana-Champ aign, Urbana, IL, Aug"
            },
            "year": 2003
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Architectural Neutral Distribution Format"
            },
            "venue": {
                "fragments": [],
                "text": "The Architectural Neutral Distribution Format"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Instrumentation and optimization of Win 32 / Intel executables using Etch Implementing Typed Intermediate Languages"
            },
            "venue": {
                "fragments": [],
                "text": "Trans . Prog . Lang . and Systems"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A Low-level Virtual Instruction Set Architecture. page (to appear)"
            },
            "venue": {
                "fragments": [],
                "text": "A Low-level Virtual Instruction Set Architecture. page (to appear)"
            },
            "year": 2003
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 174,
                                "start": 170
                            }
                        ],
                        "text": "This includes type information, explicit control \n.ow graphs, and an explicit data.ow representation (using an in.nite, typed register set in Static Single \nAssignment form [15])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "A technical overview of the Commmon Language Infrastructure"
            },
            "venue": {
                "fragments": [],
                "text": "A technical overview of the Commmon Language Infrastructure"
            },
            "year": 2002
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Managed extensions for c++ specification. .NET Framework Compiler and Language Reference"
            },
            "venue": {
                "fragments": [],
                "text": "Managed extensions for c++ specification. .NET Framework Compiler and Language Reference"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Eight Ways to Boost Performance"
            },
            "venue": {
                "fragments": [],
                "text": "Eight Ways to Boost Performance"
            },
            "year": 2000
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Implementing Typed Intermediate Languages Achieving high performance via co - designed virtual machines A practical system for intermodule code optimization at link - time"
            },
            "venue": {
                "fragments": [],
                "text": "Trans . Prog . Lang . and Systems"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "LLVM Language Reference Manual"
            },
            "venue": {
                "fragments": [],
                "text": "LLVM Language Reference Manual"
            }
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 20,
            "methodology": 15,
            "result": 1
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 54,
        "totalPages": 6
    },
    "page_url": "https://www.semanticscholar.org/paper/LLVM:-a-compilation-framework-for-lifelong-program-Lattner-Adve/d755f461dddae76068f401409ba59c85a2436305?sort=total-citations"
}