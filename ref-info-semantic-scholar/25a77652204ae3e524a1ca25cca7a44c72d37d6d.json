{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2082718"
                        ],
                        "name": "H. Massalin",
                        "slug": "H.-Massalin",
                        "structuredName": {
                            "firstName": "Henry",
                            "lastName": "Massalin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Massalin"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 47,
                                "start": 43
                            }
                        ],
                        "text": "ASPLOS 06 October 21 25,2006, San Jose, California, USA Copyright c &#38;#169; 2006 ACM \n1-59593-451-0/06/0010. . . $5.00 sequences to their optimized counterparts."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6074260,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b9addc8ce998f6892120c2c8b23ae183312bfa6c",
            "isKey": true,
            "numCitedBy": 230,
            "numCiting": 5,
            "paperAbstract": {
                "fragments": [],
                "text": "Given an instruction set, the superoptimizer finds the shortest program to compute a function. Startling programs have been generated, many of them engaging in convoluted bit-fiddling bearing little resemblance to the source programs which defined the functions. The key idea in the superoptimizer is a probabilistic test that makes exhaustive searches practical for programs of useful size. The search space is defined by the processor's instruction set, which may include the whole set, but it is typically restricted to a subset. By constraining the instructions and observing the effect on the output program, one can gain insight into the design of instruction sets. In addition, superoptimized programs may be used by peephole optimizers to improve the quality of generated code, or by assembly language programmers to improve manually written code."
            },
            "slug": "Superoptimizer:-a-look-at-the-smallest-program-Massalin",
            "title": {
                "fragments": [],
                "text": "Superoptimizer: a look at the smallest program"
            },
            "tldr": {
                "abstractSimilarityScore": 68,
                "text": "Given an instruction set, the superoptimizer finds the shortest program to compute a function, a probabilistic test that makes exhaustive searches practical for programs of useful size."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2748014"
                        ],
                        "name": "Torbj\u00f6rn Granlund",
                        "slug": "Torbj\u00f6rn-Granlund",
                        "structuredName": {
                            "firstName": "Torbj\u00f6rn",
                            "lastName": "Granlund",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Torbj\u00f6rn Granlund"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1905162"
                        ],
                        "name": "R. Kenner",
                        "slug": "R.-Kenner",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Kenner",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Kenner"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "GSO has a large \nmanual component, as auser is required to specify the goal function."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 9,
                                "start": 6
                            }
                        ],
                        "text": "While GSO has been used to learn a few tensof optimizations, our system has learned thousands and there \nis no reason the algorithms should not scale to millions of optimizations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "GSO also only optimizes register-register \noperations where the out\u00adput and inputs of the goal functions are assumed to be in speci.cregisters; \nwe optimize nearly arbitrary sequences."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 27,
                                "start": 24
                            }
                        ],
                        "text": "The GNU Superoptimizer (GSO) [6] learns optimizations in\u00advolving elimination \nof branch instructions for the RS/6000 proces\u00adsor, for later use with the GNU C Compiler (GCC)."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 32,
                                "start": 29
                            }
                        ],
                        "text": "The GNU Superoptimizer (GSO) [6] learns optimizations involving elimination of branch instructions for the RS/6000 processor, for later use with the GNU C Compiler (GCC)."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 8825539,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "47739826e28e98c20a1e2d5b853eb7d92ea73e64",
            "isKey": true,
            "numCitedBy": 97,
            "numCiting": 7,
            "paperAbstract": {
                "fragments": [],
                "text": "In 1987, Henry Massalin, of Columbia University, described a super-optimizer that generates optimal instruction sequences given a function to be performed [1]. The sequences are found by doing an exhaustive search over a subset of the instructions of the machine for which the optinkation is made. Little or no mention of this important technique has occurred since, In the present work, we describe an alternative technique for constructing a superoptimizer, which will call the GNU Superoptimizer or GSO."
            },
            "slug": "Eliminating-branches-using-a-superoptimizer-and-the-Granlund-Kenner",
            "title": {
                "fragments": [],
                "text": "Eliminating branches using a superoptimizer and the GNU C compiler"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "In the present work, an alternative technique for constructing a superoptimizer is described, which will call the GNU Superoptimizer or GSO."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '92"
            },
            "year": 1992
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144058482"
                        ],
                        "name": "R. Joshi",
                        "slug": "R.-Joshi",
                        "structuredName": {
                            "firstName": "Rajeev",
                            "lastName": "Joshi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Joshi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145802352"
                        ],
                        "name": "Greg Nelson",
                        "slug": "Greg-Nelson",
                        "structuredName": {
                            "firstName": "Greg",
                            "lastName": "Nelson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Greg Nelson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3234133"
                        ],
                        "name": "K. H. Randall",
                        "slug": "K.-H.-Randall",
                        "structuredName": {
                            "firstName": "Keith",
                            "lastName": "Randall",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. H. Randall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 40,
                                "start": 37
                            }
                        ],
                        "text": "Optimization of a com\u00adpiler \ns generated code can then be done as ef.ciently as a normalpeephole optimizer, simply using the precomputed \nrules."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 11799896,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5090ed315d3ab9f0135c83f287c5021d61929760",
            "isKey": false,
            "numCitedBy": 145,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper provides a preliminary report on a new research project that aims to construct a code generator that uses an automatic theorem prover to produce very high-quality (in fact, nearly mathematically optimal) machine code for modern architectures. The code generator is not intended for use in an ordinary compiler, but is intended to be used for inner loops and critical subroutines in those cases where peak performance is required, no available compiler generates adequately efficient code, and where current engineering practice is to use hand-coded machine language. The paper describes the design of the superoptimizer, and presents some encouraging preliminary results."
            },
            "slug": "Denali:-a-goal-directed-superoptimizer-Joshi-Nelson",
            "title": {
                "fragments": [],
                "text": "Denali: a goal-directed superoptimizer"
            },
            "tldr": {
                "abstractSimilarityScore": 50,
                "text": "A code generator that uses an automatic theorem prover to produce very high-quality (in fact, nearly mathematically optimal) machine code for modern architectures is constructed."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '02"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "81641862"
                        ],
                        "name": "L. Van Put",
                        "slug": "L.-Van-Put",
                        "structuredName": {
                            "firstName": "Ludo",
                            "lastName": "Van Put",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Van Put"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2063266"
                        ],
                        "name": "D. Chanet",
                        "slug": "D.-Chanet",
                        "structuredName": {
                            "firstName": "Dominique",
                            "lastName": "Chanet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Chanet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "79976722"
                        ],
                        "name": "B. De Bus",
                        "slug": "B.-De-Bus",
                        "structuredName": {
                            "firstName": "Bruno",
                            "lastName": "De Bus",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. De Bus"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "116119215"
                        ],
                        "name": "B. De Sutter",
                        "slug": "B.-De-Sutter",
                        "structuredName": {
                            "firstName": "Bjorn",
                            "lastName": "De Sutter",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. De Sutter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47134346"
                        ],
                        "name": "K. De Bosschere",
                        "slug": "K.-De-Bosschere",
                        "structuredName": {
                            "firstName": "Koen",
                            "lastName": "De Bosschere",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. De Bosschere"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 48
                            }
                        ],
                        "text": "We use the Diablo link-time rewriting framework [3, 12] to compute liveness information for an x86 executable binary."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 14239421,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "37a0004af3252a9c58b77cf289b891495d727241",
            "isKey": false,
            "numCitedBy": 103,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "Modern software engineering techniques introduce an overhead to programs in terms of performance and code size. A traditional development environment, where only the compiler optimizes the code, cannot completely eliminate this overhead. To effectively remove the overhead, tools are needed that have a whole-program overview. Link-time binary rewriting is an effective technique for whole-program optimization and instrumentation. In this paper, we describe a novel framework to reliably perform link-time program transformations. This framework is designed to be retargetable, supporting multiple architectures and development toolchains. Furthermore it is extensible, which we illustrate by describing three different applications that are built on top of the framework."
            },
            "slug": "DIABLO:-a-reliable,-retargetable-and-extensible-Put-Chanet",
            "title": {
                "fragments": [],
                "text": "DIABLO: a reliable, retargetable and extensible link-time rewriting framework"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This paper describes a novel framework to reliably perform link-time program transformations, designed to be retargetable, supporting multiple architectures and development toolchains, and extensible."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the Fifth IEEE International Symposium on Signal Processing and Information Technology, 2005."
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3147344"
                        ],
                        "name": "Manuel E. Benitez",
                        "slug": "Manuel-E.-Benitez",
                        "structuredName": {
                            "firstName": "Manuel",
                            "lastName": "Benitez",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Manuel E. Benitez"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144577708"
                        ],
                        "name": "J. Davidson",
                        "slug": "J.-Davidson",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Davidson",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Davidson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 52
                            }
                        ],
                        "text": "For example, the \u201cvery portable optimizer\u201d (VPO) in [4] uses peephole optimization to reduce the volume of intermediate code by a factor of two to three."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 185,
                                "start": 179
                            }
                        ],
                        "text": "Peephole optimizers, apart from their typical use in the final optimization pass, have also been used to perform code selection at link time to generate highly portable compilers [5, 4]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 15247975,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e2067849f100e49b92785176ba88792fd97dfd8a",
            "isKey": false,
            "numCitedBy": 209,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "To reduce complexity and simplify their implementation, most compilers are organized as a set of passes or phases. Each phase performs a particular piece of the compilation process. In an optimizing compiler, the assignment of function and order of application of the phases is a critical part of the design. A particularly difficult problem is the arrangement of the code generation and optimization phases so as to avoid phase ordering problems caused by the interaction of the phases. In this paper, we discuss the implementation of a compiler/linker that has been designed to avoid these problems. The key aspect of this design is that the synthesis phases of the compiler and the system linker share the same intermediate program representation. This results in two benefits. It permits the synthesis phases of the compiler to be performed in any order and repeatedly, thus eliminating potential phase ordering problems. Second, it permits code selection to be invoked at any point during the synthesis phases as well as at link time. The ability to perform code selection at link time presents many opportunities for additional optimizations. Measurements about the effectiveness of using this approach in a C compiler on two different machines are presented."
            },
            "slug": "A-portable-global-optimizer-and-linker-Benitez-Davidson",
            "title": {
                "fragments": [],
                "text": "A portable global optimizer and linker"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This paper discusses the implementation of a compiler/linker that has been designed to avoid phase ordering problems caused by the interaction of the phases and permits code selection to be invoked at any point during the synthesis phases as well as at link time."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '88"
            },
            "year": 1988
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2340028"
                        ],
                        "name": "Bertrand Anckaert",
                        "slug": "Bertrand-Anckaert",
                        "structuredName": {
                            "firstName": "Bertrand",
                            "lastName": "Anckaert",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bertrand Anckaert"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2992269"
                        ],
                        "name": "Frederik Vandeputte",
                        "slug": "Frederik-Vandeputte",
                        "structuredName": {
                            "firstName": "Frederik",
                            "lastName": "Vandeputte",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Frederik Vandeputte"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2545314"
                        ],
                        "name": "B. D. Bus",
                        "slug": "B.-D.-Bus",
                        "structuredName": {
                            "firstName": "Bruno",
                            "lastName": "Bus",
                            "middleNames": [
                                "De"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. D. Bus"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9366424"
                        ],
                        "name": "B. D. Sutter",
                        "slug": "B.-D.-Sutter",
                        "structuredName": {
                            "firstName": "Bjorn",
                            "lastName": "Sutter",
                            "middleNames": [
                                "De"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. D. Sutter"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "7161646"
                        ],
                        "name": "K. D. Bosschere",
                        "slug": "K.-D.-Bosschere",
                        "structuredName": {
                            "firstName": "Koen",
                            "lastName": "Bosschere",
                            "middleNames": [
                                "De"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. D. Bosschere"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 48
                            }
                        ],
                        "text": "We use the Diablo link-time rewriting framework [3, 12] to compute liveness information for an x86 executable binary."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1220453,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "730f203ee36a5567405225148d6f325d48f1a03c",
            "isKey": false,
            "numCitedBy": 7,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "The features of the IA64 architecture create new opportunities for link-time optimization. At the same time they complicate the design of a link-time optimizer. This paper examines how to exploit some of the opportunities for link-time optimization and how to deal with the complications. The prototype link-time optimizer that implements the discussed techniques is able to reduce the code size of statically linked programs with 19% and achieves a speedup of 5.4% on average."
            },
            "slug": "Link-Time-Optimization-of-IA64-Binaries-Anckaert-Vandeputte",
            "title": {
                "fragments": [],
                "text": "Link-Time Optimization of IA64 Binaries"
            },
            "tldr": {
                "abstractSimilarityScore": 61,
                "text": "This paper examines how to exploit some of the opportunities for link-time optimization and how to deal with the complications of the IA64 architecture."
            },
            "venue": {
                "fragments": [],
                "text": "Euro-Par"
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1978393184"
                        ],
                        "name": "Lintao Zhang",
                        "slug": "Lintao-Zhang",
                        "structuredName": {
                            "firstName": "Lintao",
                            "lastName": "Zhang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lintao Zhang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2081144864"
                        ],
                        "name": "Conor F. Madigan",
                        "slug": "Conor-F.-Madigan",
                        "structuredName": {
                            "firstName": "Conor",
                            "lastName": "Madigan",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Conor F. Madigan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2318023"
                        ],
                        "name": "M. Moskewicz",
                        "slug": "M.-Moskewicz",
                        "structuredName": {
                            "firstName": "Matthew",
                            "lastName": "Moskewicz",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Moskewicz"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144682958"
                        ],
                        "name": "S. Malik",
                        "slug": "S.-Malik",
                        "structuredName": {
                            "firstName": "Sharad",
                            "lastName": "Malik",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Malik"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "We use zChaff [11, 13] as our backend SAT solver because of its performance and incremental SAT solving capabilities."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 179695,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "aedea7a426a42d38ebad02ccbcfbd40fa8dba82a",
            "isKey": false,
            "numCitedBy": 877,
            "numCiting": 120,
            "paperAbstract": {
                "fragments": [],
                "text": "One of the most important features of current state-of-the-art SAT solvers is the use of conflict based backtracking and learning techniques. In this paper, we generalize various conflict driven learning strategies in terms of different partitioning schemes of the implication graph. We re-examine the learning techniques used in various SAT solvers and propose an array of new learning schemes. Extensive experiments with real world examples show that the best performing new learning scheme has at least a 2/spl times/ speedup compared with learning schemes employed in state-of-the-art SAT solvers."
            },
            "slug": "Efficient-conflict-driven-learning-in-a-Boolean-Zhang-Madigan",
            "title": {
                "fragments": [],
                "text": "Efficient conflict driven learning in a Boolean satisfiability solver"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This paper generalizes various conflict driven learning strategies in terms of different partitioning schemes of the implication graph to re-examine the learning techniques used in various SAT solvers and propose an array of new learning schemes."
            },
            "venue": {
                "fragments": [],
                "text": "IEEE/ACM International Conference on Computer Aided Design. ICCAD 2001. IEEE/ACM Digest of Technical Papers (Cat. No.01CH37281)"
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3227471"
                        ],
                        "name": "John L. Henning",
                        "slug": "John-L.-Henning",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Henning",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "John L. Henning"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [],
                        "text": "Next, we applied the superoptimizer to applications from the SPEC CINT2000 benchmarks [ 7 ]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 10289468,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "7030ac77faacc1279535b654bbe6df619802fe73",
            "isKey": false,
            "numCitedBy": 896,
            "numCiting": 1,
            "paperAbstract": {
                "fragments": [],
                "text": "As computers and software have become more powerful, it seems almost human nature to want the biggest and fastest toy you can afford. But how do you know if your toy is tops? Even if your application never does any I/O, it's not just the speed of the CPU that dictates performance. Cache, main memory, and compilers also play a role. Software applications also have differing performance requirements. So whom do you trust to provide this information? The Standard Performance Evaluation Corporation (SPEC) is a nonprofit consortium whose members include hardware vendors, software vendors, universities, customers, and consultants. SPEC's mission is to develop technically credible and objective component- and system-level benchmarks for multiple operating systems and environments, including high-performance numeric computing, Web servers, and graphical subsystems. On 30 June 2000, SPEC retired the CPU95 benchmark suite. Its replacement is CPU2000, a new CPU benchmark suite with 19 applications that have never before been in a SPEC CPU suite. The article discusses how SPEC developed this benchmark suite and what the benchmarks do."
            },
            "slug": "SPEC-CPU2000:-Measuring-CPU-Performance-in-the-New-Henning",
            "title": {
                "fragments": [],
                "text": "SPEC CPU2000: Measuring CPU Performance in the New Millennium"
            },
            "venue": {
                "fragments": [],
                "text": "Computer"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144577708"
                        ],
                        "name": "J. Davidson",
                        "slug": "J.-Davidson",
                        "structuredName": {
                            "firstName": "Jack",
                            "lastName": "Davidson",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Davidson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1697888"
                        ],
                        "name": "C. Fraser",
                        "slug": "C.-Fraser",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "Fraser",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Fraser"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 185,
                                "start": 179
                            }
                        ],
                        "text": "Peephole optimizers, apart from their typical use in the final optimization pass, have also been used to perform code selection at link time to generate highly portable compilers [5, 4]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 10315537,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1a0d75f608d7ac60083a06e0719c26f3e2aa2359",
            "isKey": false,
            "numCitedBy": 139,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": "Cet article montre comment une optimisation de code objet minutieux a simplifiee un compilateur et la rendu facile a recibler. Les compilateurs croises emettent un code comparable aux compilateurs specifiques vides"
            },
            "slug": "Code-selection-through-object-code-optimization-Davidson-Fraser",
            "title": {
                "fragments": [],
                "text": "Code selection through object code optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 95,
                "text": "Cet article montre comment une optimisation de code objet minutieux a simplifiee un compilateur and the rendu facile a recibler."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1984
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2318023"
                        ],
                        "name": "M. Moskewicz",
                        "slug": "M.-Moskewicz",
                        "structuredName": {
                            "firstName": "Matthew",
                            "lastName": "Moskewicz",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Moskewicz"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2081144864"
                        ],
                        "name": "Conor F. Madigan",
                        "slug": "Conor-F.-Madigan",
                        "structuredName": {
                            "firstName": "Conor",
                            "lastName": "Madigan",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Conor F. Madigan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2118976646"
                        ],
                        "name": "Ying Zhao",
                        "slug": "Ying-Zhao",
                        "structuredName": {
                            "firstName": "Ying",
                            "lastName": "Zhao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ying Zhao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1978393184"
                        ],
                        "name": "Lintao Zhang",
                        "slug": "Lintao-Zhang",
                        "structuredName": {
                            "firstName": "Lintao",
                            "lastName": "Zhang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lintao Zhang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144682958"
                        ],
                        "name": "S. Malik",
                        "slug": "S.-Malik",
                        "structuredName": {
                            "firstName": "Sharad",
                            "lastName": "Malik",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Malik"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 22,
                                "start": 14
                            }
                        ],
                        "text": "We use zChaff [11, 13] as our backend SAT solver because of its performance and incremental SAT solving capabilities."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 9292941,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0b456a8c8c9fafcfbcbb3d4a854c88cf2adbf98a",
            "isKey": false,
            "numCitedBy": 3603,
            "numCiting": 116,
            "paperAbstract": {
                "fragments": [],
                "text": "Boolean satisfiability is probably the most studied of the combinatorial optimization/search problems. Significant effort has been devoted to trying to provide practical solutions to this problem for problem instances encountered in a range of applications in electronic design automation (EDA), as well as in artificial intelligence (AI). This study has culminated in the development of several SAT packages, both proprietary and in the public domain (e.g. GRASP, SATO) which find significant use in both research and industry. Most existing complete solvers are variants of the Davis-Putnam (DP) search algorithm. In this paper we describe the development of a new complete solver, Chaff which achieves significant performance gains through careful engineering of all aspects of the search-especially a particularly efficient implementation of Boolean constraint propagation (BCP) and a novel low overhead decision strategy. Chaff has been able to obtain one to two orders of magnitude performance improvement on difficult SAT benchmarks in comparison with other solvers (DP or otherwise), including GRASP and SATO."
            },
            "slug": "Chaff:-engineering-an-efficient-SAT-solver-Moskewicz-Madigan",
            "title": {
                "fragments": [],
                "text": "Chaff: engineering an efficient SAT solver"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "The development of a new complete solver, Chaff, is described which achieves significant performance gains through careful engineering of all aspects of the search-especially a particularly efficient implementation of Boolean constraint propagation (BCP) and a novel low overhead decision strategy."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 38th Design Automation Conference (IEEE Cat. No.01CH37232)"
            },
            "year": 2001
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Objective Caml system. Software and documentation available at http"
            },
            "venue": {
                "fragments": [],
                "text": "The Objective Caml system. Software and documentation available at http"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Intel C++ Compiler 9.0. Software available at http://www.intel.com/software/products/compilers/clin"
            },
            "venue": {
                "fragments": [],
                "text": "Intel C++ Compiler 9.0. Software available at http://www.intel.com/software/products/compilers/clin"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Total: 28,593 optimizations EXPERIMENTAL RESULTS"
            },
            "venue": {
                "fragments": [],
                "text": "Total: 28,593 optimizations EXPERIMENTAL RESULTS"
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Superoptimizer prototype Available on the web at http://cs.stanford.edu/\u223csbansal/superoptimizer"
            },
            "venue": {
                "fragments": [],
                "text": "Superoptimizer prototype Available on the web at http://cs.stanford.edu/\u223csbansal/superoptimizer"
            }
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 1,
            "methodology": 9
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 14,
        "totalPages": 2
    },
    "page_url": "https://www.semanticscholar.org/paper/Automatic-generation-of-peephole-superoptimizers-Bansal-Aiken/25a77652204ae3e524a1ca25cca7a44c72d37d6d?sort=total-citations"
}