{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1712987"
                        ],
                        "name": "Tiark Rompf",
                        "slug": "Tiark-Rompf",
                        "structuredName": {
                            "firstName": "Tiark",
                            "lastName": "Rompf",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tiark Rompf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1795826"
                        ],
                        "name": "Martin Odersky",
                        "slug": "Martin-Odersky",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Odersky",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Martin Odersky"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 38,
                                "start": 34
                            }
                        ],
                        "text": "Lightweight Modular Staging (LMS) [45] is a state of the art framework and runtime code generator, providing a library of core components for generating efficient code and embedding DSLs in Scala."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 11663179,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "74fd59dabab7b156702b148bb64f8e1ee54f6862",
            "isKey": false,
            "numCitedBy": 384,
            "numCiting": 116,
            "paperAbstract": {
                "fragments": [],
                "text": "Software engineering demands generality and abstraction, performance demands specialization and concretization. Generative programming can provide both, but the effort required to develop high-quality program generators likely offsets their benefits, even if a multi-stage programming language is used.\n We present lightweight modular staging, a library-based multi-stage programming approach that breaks with the tradition of syntactic quasi-quotation and instead uses only types to distinguish between binding times. Through extensive use of component technology, lightweight modular staging makes an optimizing compiler framework available at the library level, allowing programmers to tightly integrate domain-specific abstractions and optimizations into the generation process.\n We argue that lightweight modular staging enables a form of language virtualization, i.e. allows to go from a pure-library embedded language to one that is practically equivalent to a stand-alone implementation with only modest effort."
            },
            "slug": "Lightweight-modular-staging:-a-pragmatic-approach-Rompf-Odersky",
            "title": {
                "fragments": [],
                "text": "Lightweight modular staging: a pragmatic approach to runtime code generation and compiled DSLs"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "It is argued that lightweight modular staging enables a form of language virtualization, i.e. allows to go from a pure-library embedded language to one that is practically equivalent to a stand-alone implementation with only modest effort."
            },
            "venue": {
                "fragments": [],
                "text": "GPCE '10"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1790411"
                        ],
                        "name": "G. Necula",
                        "slug": "G.-Necula",
                        "structuredName": {
                            "firstName": "George",
                            "lastName": "Necula",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Necula"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 85
                            }
                        ],
                        "text": "A long term goal would be to reproduce the successes of translation validation [11], [12], [13], [14] and modern approaches to compiler testing [15]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 2448939,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "011f7da0095ac8c0d4477eeda2728e5f80a35767",
            "isKey": false,
            "numCitedBy": 486,
            "numCiting": 36,
            "paperAbstract": {
                "fragments": [],
                "text": "We describe a translation validation infrastructure for the GNU C compiler. During the compilation the infrastructure compares the intermediate form of the program before and after each compiler pass and verifies the preservation of semantics. We discuss a general framework that the optimizer can use to communicate to the validator what transformations were performed. Our implementation however does not rely on help from the optimizer and it is quite successful by using instead a few heuristics to detect the transformations that take place.\nThe main message of this paper is that a practical translation validation infrastructure, able to check the correctness of many of the transformations performed by a realistic compiler, can be implemented with about the effort typically required to implement one compiler pass. We demonstrate this in the context of the GNU C compiler for a number of its optimizations while compiling realistic programs such as the compiler itself or the Linux kernel. We believe that the price of such an infrastructure is small considering the qualitative increase in the ability to isolate compilation errors during compiler testing and maintenance."
            },
            "slug": "Translation-validation-for-an-optimizing-compiler-Necula",
            "title": {
                "fragments": [],
                "text": "Translation validation for an optimizing compiler"
            },
            "tldr": {
                "abstractSimilarityScore": 52,
                "text": "A practical translation validation infrastructure, able to check the correctness of many of the transformations performed by a realistic compiler, can be implemented with about the effort typically required to implement one compiler pass."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '00"
            },
            "year": 2000
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1710459"
                        ],
                        "name": "Dounia Khaldi",
                        "slug": "Dounia-Khaldi",
                        "structuredName": {
                            "firstName": "Dounia",
                            "lastName": "Khaldi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dounia Khaldi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2913872"
                        ],
                        "name": "P. Jouvelot",
                        "slug": "P.-Jouvelot",
                        "structuredName": {
                            "firstName": "Pierre",
                            "lastName": "Jouvelot",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Jouvelot"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2912411"
                        ],
                        "name": "F. Irigoin",
                        "slug": "F.-Irigoin",
                        "structuredName": {
                            "firstName": "Fran\u00e7ois",
                            "lastName": "Irigoin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Irigoin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3050922"
                        ],
                        "name": "Corinne Ancourt",
                        "slug": "Corinne-Ancourt",
                        "structuredName": {
                            "firstName": "Corinne",
                            "lastName": "Ancourt",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Corinne Ancourt"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144291242"
                        ],
                        "name": "B. Chapman",
                        "slug": "B.-Chapman",
                        "structuredName": {
                            "firstName": "Barbara",
                            "lastName": "Chapman",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Chapman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 136,
                                "start": 133
                            }
                        ],
                        "text": "Parallel intermediate representations extending LLVM IR address part of the issue but traditionally focus on the homogeneous setting [7], [8]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 143,
                                "start": 140
                            }
                        ],
                        "text": "The state of the art in modeling parallel computing constructs in a production compiler highlights how difficult the task may be in general [7], [8]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 207232326,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "03f5501e776ca19515df15e11f216265f3afc43d",
            "isKey": false,
            "numCitedBy": 17,
            "numCiting": 23,
            "paperAbstract": {
                "fragments": [],
                "text": "We extend the LLVM intermediate representation (IR) to make it a parallel IR (LLVM PIR), which is a necessary step for introducing simple and generic parallel code optimization into LLVM. LLVM is a modular compiler that can be efficiently and easily used for static analysis, static and dynamic compilation, optimization, and code generation. Being increasingly used to address high-performance computing abstractions and hardware, LLVM will benefit from the ability to handle parallel constructs at the IR level. We use SPIRE, an incremental methodology for designing the intermediate representations of compilers that target parallel programming languages, to design LLVM PIR.\n Languages and libraries based on the Partitioned Global Address Space (PGAS) programming model have emerged in recent years with a focus on addressing the programming challenges for scalable parallel systems. Among these, OpenSHMEM is a library that is the culmination of a standardization effort among many implementers and users of SHMEM; it provides a means to develop light-weight, portable, scalable applications based on the PGAS programming model. As a use case for validating our LLVM PIR proposal, we show how OpenSHMEM one-sided communications can be optimized via our implementation of PIR into the LLVM compiler; we illustrate two important optimizations for such operations using loop tiling and communication vectorization."
            },
            "slug": "LLVM-parallel-intermediate-representation:-design-Khaldi-Jouvelot",
            "title": {
                "fragments": [],
                "text": "LLVM parallel intermediate representation: design and evaluation using OpenSHMEM communications"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "It is shown how OpenSHMEM one-sided communications can be optimized via the implementation of PIR into the LLVM compiler, and two important optimizations for such operations are illustrated using loop tiling and communication vectorization."
            },
            "venue": {
                "fragments": [],
                "text": "LLVM '15"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "81137443"
                        ],
                        "name": "Lorenzo Chelini",
                        "slug": "Lorenzo-Chelini",
                        "structuredName": {
                            "firstName": "Lorenzo",
                            "lastName": "Chelini",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lorenzo Chelini"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2054833547"
                        ],
                        "name": "O. Zinenko",
                        "slug": "O.-Zinenko",
                        "structuredName": {
                            "firstName": "Oleksandr",
                            "lastName": "Zinenko",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Zinenko"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1756389"
                        ],
                        "name": "T. Grosser",
                        "slug": "T.-Grosser",
                        "structuredName": {
                            "firstName": "Tobias",
                            "lastName": "Grosser",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Grosser"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1684335"
                        ],
                        "name": "H. Corporaal",
                        "slug": "H.-Corporaal",
                        "structuredName": {
                            "firstName": "Henk",
                            "lastName": "Corporaal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Corporaal"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 130,
                                "start": 126
                            }
                        ],
                        "text": "However, polyhedral transformations require raising into a representation often drastically different from the original [31], [32]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 209525519,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "108ed568849e876eb418573ba588502a473e4daf",
            "isKey": false,
            "numCitedBy": 15,
            "numCiting": 84,
            "paperAbstract": {
                "fragments": [],
                "text": "Increasingly complex hardware makes the design of effective compilers difficult. To reduce this problem, we introduce Declarative Loop Tactics, which is a novel framework of composable program transformations based on an internal tree-like program representation of a polyhedral compiler. The framework is based on a declarative C++ API built around easy-to-program matchers and builders, which provide the foundation to develop loop optimization strategies. Using our matchers and builders, we express computational patterns and core building blocks, such as loop tiling, fusion, and data-layout transformations, and compose them into algorithm-specific optimizations. Declarative Loop Tactics (Loop Tactics for short) can be applied to many domains. For two of them, stencils and linear algebra, we show how developers can express sophisticated domain-specific optimizations as a set of composable transformations or calls to optimized libraries. By allowing developers to add highly customized optimizations for a given computational pattern, we expect our approach to reduce the need for DSLs and to extend the range of optimizations that can be performed by a current general-purpose compiler."
            },
            "slug": "Declarative-Loop-Tactics-for-Domain-specific-Chelini-Zinenko",
            "title": {
                "fragments": [],
                "text": "Declarative Loop Tactics for Domain-specific Optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 58,
                "text": "Declarative Loop Tactics is a novel framework of composable program transformations based on an internal tree-like program representation of a polyhedral compiler based on a declarative C++ API built around easy-to-program matchers and builders, which provide the foundation to develop loop optimization strategies."
            },
            "venue": {
                "fragments": [],
                "text": "ACM Trans. Archit. Code Optim."
            },
            "year": 2020
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2447693"
                        ],
                        "name": "S. Donadio",
                        "slug": "S.-Donadio",
                        "structuredName": {
                            "firstName": "S\u00e9bastien",
                            "lastName": "Donadio",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Donadio"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3106639"
                        ],
                        "name": "M. Garzar\u00e1n",
                        "slug": "M.-Garzar\u00e1n",
                        "structuredName": {
                            "firstName": "Mar\u00eda",
                            "lastName": "Garzar\u00e1n",
                            "middleNames": [
                                "Jes\u00fas"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Garzar\u00e1n"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39713816"
                        ],
                        "name": "C. Herrmann",
                        "slug": "C.-Herrmann",
                        "structuredName": {
                            "firstName": "Christoph",
                            "lastName": "Herrmann",
                            "middleNames": [
                                "Armin"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Herrmann"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144774224"
                        ],
                        "name": "O. Kiselyov",
                        "slug": "O.-Kiselyov",
                        "structuredName": {
                            "firstName": "Oleg",
                            "lastName": "Kiselyov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Kiselyov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1729097"
                        ],
                        "name": "D. Padua",
                        "slug": "D.-Padua",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Padua",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Padua"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 10,
                                "start": 6
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8084559,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b91ff4becb37f314ec723b01bda3fb1c647afc27",
            "isKey": false,
            "numCitedBy": 53,
            "numCiting": 80,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "In-search-of-a-program-generator-to-implement-for-Cohen-Donadio",
            "title": {
                "fragments": [],
                "text": "In search of a program generator to implement generic transformations for high-performance computing"
            },
            "venue": {
                "fragments": [],
                "text": "Sci. Comput. Program."
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1765246"
                        ],
                        "name": "Chris Lattner",
                        "slug": "Chris-Lattner",
                        "structuredName": {
                            "firstName": "Chris",
                            "lastName": "Lattner",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chris Lattner"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1720525"
                        ],
                        "name": "V. Adve",
                        "slug": "V.-Adve",
                        "structuredName": {
                            "firstName": "Vikram",
                            "lastName": "Adve",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Adve"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 50,
                                "start": 47
                            }
                        ],
                        "text": "MLIR is a compiler infrastructure akin to LLVM [1], but where LLVM has been a great boon to scalar optimizations and homogeneous compilation, MLIR aims to model a rich set of data structures and algorithms as first-class values and operations, including tensor algebra and algorithms, graph representations, as well as heterogeneous compilation."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 90
                            }
                        ],
                        "text": "which have enabled massive reuse, including systems like the LLVM compiler infrastructure [1], the Java Virtual Machine (JVM) [2], and many others."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 978769,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d755f461dddae76068f401409ba59c85a2436305",
            "isKey": false,
            "numCitedBy": 4656,
            "numCiting": 54,
            "paperAbstract": {
                "fragments": [],
                "text": "We describe LLVM (low level virtual machine), a compiler framework designed to support transparent, lifelong program analysis and transformation for arbitrary programs, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. LLVM defines a common, low-level code representation in static single assignment (SSA) form, with several novel features: a simple, language-independent type-system that exposes the primitives commonly used to implement high-level language features; an instruction for typed address arithmetic; and a simple mechanism that can be used to implement the exception handling features of high-level languages (and setjmp/longjmp in C) uniformly and efficiently. The LLVM compiler framework and code representation together provide a combination of key capabilities that are important for practical, lifelong analysis and transformation of programs. To our knowledge, no existing compilation approach provides all these capabilities. We describe the design of the LLVM representation and compiler framework, and evaluate the design in three ways: (a) the size and effectiveness of the representation, including the type information it provides; (b) compiler performance for several interprocedural problems; and (c) illustrative examples of the benefits LLVM provides for several challenging compiler problems."
            },
            "slug": "LLVM:-a-compilation-framework-for-lifelong-program-Lattner-Adve",
            "title": {
                "fragments": [],
                "text": "LLVM: a compilation framework for lifelong program analysis & transformation"
            },
            "tldr": {
                "abstractSimilarityScore": 49,
                "text": "The design of the LLVM representation and compiler framework is evaluated in three ways: the size and effectiveness of the representation, including the type information it provides; compiler performance for several interprocedural problems; and illustrative examples of the benefits LLVM provides for several challenging compiler problems."
            },
            "venue": {
                "fragments": [],
                "text": "International Symposium on Code Generation and Optimization, 2004. CGO 2004."
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2506136"
                        ],
                        "name": "Sylvain Girbal",
                        "slug": "Sylvain-Girbal",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Girbal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Girbal"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1702824"
                        ],
                        "name": "David Parello",
                        "slug": "David-Parello",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Parello",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David Parello"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "18182536"
                        ],
                        "name": "Marc Sigler",
                        "slug": "Marc-Sigler",
                        "structuredName": {
                            "firstName": "Marc",
                            "lastName": "Sigler",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Marc Sigler"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1731764"
                        ],
                        "name": "O. Temam",
                        "slug": "O.-Temam",
                        "structuredName": {
                            "firstName": "Olivier",
                            "lastName": "Temam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Temam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 117,
                                "start": 113
                            }
                        ],
                        "text": "number of loop transformations compose directly and can be reasoned about using simple mathematical abstractions [26]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 230,
                                "start": 226
                            }
                        ],
                        "text": "While a full exploration of the design points here is out of scope for this paper, we illustrate aspects of the affine dialect to show the modeling power of MLIR and contrast the affine dialect with past representations [25], [26], [27], [28], [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 52,
                                "start": 48
                            }
                        ],
                        "text": "and TVM [49], earlier loop nest metaprogramming [26], [51],"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8182159,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cc1c1b1eb6e9672d1b2813ad763f701494d8fcee",
            "isKey": false,
            "numCitedBy": 240,
            "numCiting": 123,
            "paperAbstract": {
                "fragments": [],
                "text": "Modern compilers are responsible for translating the idealistic operational semantics of the source program into a form that makes efficient use of a highly complex heterogeneous machine. Since optimization problems are associated with huge and unstructured search spaces, this combinational task is poorly achieved in general, resulting in weak scalability and disappointing sustained performance. We address this challenge by working on the program representation itself, using a semi-automatic optimization approach to demonstrate that current compilers offen suffer from unnecessary constraints and intricacies that can be avoided in a semantically richer transformation framework. Technically, the purpose of this paper is threefold: (1) to show that syntactic code representations close to the operational semantics lead to rigid phase ordering and cumbersome expression of architecture-aware loop transformations, (2) to illustrate how complex transformation sequences may be needed to achieve significant performance benefits, (3) to facilitate the automatic search for program transformation sequences, improving on classical polyhedral representations to better support operation research strategies in a simpler, structured search space. The proposed framework relies on a unified polyhedral representation of loops and statements, using normalization rules to allow flexible and expressive transformation sequencing. Thisrepresentation allows to extend the scalability of polyhedral dependence analysis, and to delay the (automatic) legality checks until the end of a transformation sequence. Our work leverages on algorithmic advances in polyhedral code generation and has been implemented in a modern research compiler."
            },
            "slug": "Semi-Automatic-Composition-of-Loop-Transformations-Girbal-Vasilache",
            "title": {
                "fragments": [],
                "text": "Semi-Automatic Composition of Loop Transformations for Deep Parallelism and Memory Hierarchies"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This work leverages on algorithmic advances in polyhedral code generation and has been implemented in a modern research compiler, using a semi-automatic optimization approach to demonstrate that current compilers suffer from unnecessary constraints and intricacies that can be avoided in a semantically richer transformation framework."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40335288"
                        ],
                        "name": "Gabe Rudy",
                        "slug": "Gabe-Rudy",
                        "structuredName": {
                            "firstName": "Gabe",
                            "lastName": "Rudy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Gabe Rudy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31568526"
                        ],
                        "name": "M. Khan",
                        "slug": "M.-Khan",
                        "structuredName": {
                            "firstName": "Malik",
                            "lastName": "Khan",
                            "middleNames": [
                                "Murtaza"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Khan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143896454"
                        ],
                        "name": "Mary W. Hall",
                        "slug": "Mary-W.-Hall",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Hall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mary W. Hall"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109525543"
                        ],
                        "name": "Chun Chen",
                        "slug": "Chun-Chen",
                        "structuredName": {
                            "firstName": "Chun",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chun Chen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772362"
                        ],
                        "name": "Jacqueline Chame",
                        "slug": "Jacqueline-Chame",
                        "structuredName": {
                            "firstName": "Jacqueline",
                            "lastName": "Chame",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jacqueline Chame"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 54
                            }
                        ],
                        "text": "and TVM [49], earlier loop nest metaprogramming [26], [51],"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 19501057,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cc2906b3a18ee0e4d0ef4ba324c01d5b60d77315",
            "isKey": false,
            "numCitedBy": 85,
            "numCiting": 38,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents a programming language interface, a complete scripting language, to describe composable compiler transformations. These transformation programs can be written, shared and reused by non-expert application and library developers. From a compiler writer's perspective, a scripting language interface permits rapid prototyping of compiler algorithms that can mix levels and compose different sequences of transformations, producing readable code as output. From a library or application developer's perspective, the use of transformation programs permits expression of clean high-level code, and a separate description of how to map that code to architectural features, easing maintenance and porting to new architectures. \n \nWe illustrate this interface in the context of CUDA-CHiLL, a source-to-source compiler transformation and code generation framework that transforms sequential loop nests to high-performance GPU code. We show how this high-level transformation and code generation language can be used to express: (1) complex transformation sequences, exemplified by a single loop restructuring construct used to generate a series of tiling and permute commands; and, (2) complex code generation sequences to produce CUDA code from a high-level specification. We demonstrate that the automatically-generated code either performs closely or outperforms two hand-tuned GPU library kernels from Nvidia's CUBLAS 2.2 and 3.2 libraries."
            },
            "slug": "A-Programming-Language-Interface-to-Describe-and-Rudy-Khan",
            "title": {
                "fragments": [],
                "text": "A Programming Language Interface to Describe Transformations and Code Generation"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "It is demonstrated that the automatically-generated code either performs closely or outperforms two hand-tuned GPU library kernels from Nvidia's CUBLAS 2.2 and 3.2 libraries."
            },
            "venue": {
                "fragments": [],
                "text": "LCPC"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2792832"
                        ],
                        "name": "T. Schardl",
                        "slug": "T.-Schardl",
                        "structuredName": {
                            "firstName": "Tao",
                            "lastName": "Schardl",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Schardl"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "16521420"
                        ],
                        "name": "William S. Moses",
                        "slug": "William-S.-Moses",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Moses",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "William S. Moses"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145372049"
                        ],
                        "name": "C. Leiserson",
                        "slug": "C.-Leiserson",
                        "structuredName": {
                            "firstName": "Charles",
                            "lastName": "Leiserson",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Leiserson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15919937,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3ac3a74ff17ce863e48a4711e3b474f838ad7093",
            "isKey": false,
            "numCitedBy": 55,
            "numCiting": 93,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper explores how fork-join parallelism, as supported by concurrency platforms such as Cilk and OpenMP, can be embedded into a compiler's intermediate representation (IR). Mainstream compilers typically treat parallel linguistic constructs as syntactic sugar for function calls into a parallel runtime. These calls prevent the compiler from performing optimizations across parallel control constructs. Remedying this situation is generally thought to require an extensive reworking of compiler analyses and code transformations to handle parallel semantics. Tapir is a compiler IR that represents logically parallel tasks asymmetrically in the program's control flow graph. Tapir allows the compiler to optimize across parallel control constructs with only minor changes to its existing analyses and code transformations. To prototype Tapir in the LLVM compiler, for example, we added or modified about 6000 lines of LLVM's 4-million-line codebase. Tapir enables LLVM's existing compiler optimizations for serial code -- including loop-invariant-code motion, common-subexpression elimination, and tail-recursion elimination -- to work with parallel control constructs such as spawning and parallel loops. Tapir also supports parallel optimizations such as loop scheduling."
            },
            "slug": "Tapir:-Embedding-Fork-Join-Parallelism-into-LLVM's-Schardl-Moses",
            "title": {
                "fragments": [],
                "text": "Tapir: Embedding Fork-Join Parallelism into LLVM's Intermediate Representation"
            },
            "tldr": {
                "abstractSimilarityScore": 82,
                "text": "This paper explores how fork-join parallelism, as supported by concurrency platforms such as Cilk and OpenMP, can be embedded into a compiler's intermediate representation (IR) with only minor changes to its existing analyses and code transformations."
            },
            "venue": {
                "fragments": [],
                "text": "PPoPP"
            },
            "year": 2017
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3121592"
                        ],
                        "name": "Nadav Rotem",
                        "slug": "Nadav-Rotem",
                        "structuredName": {
                            "firstName": "Nadav",
                            "lastName": "Rotem",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nadav Rotem"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8855702"
                        ],
                        "name": "Jordan Fix",
                        "slug": "Jordan-Fix",
                        "structuredName": {
                            "firstName": "Jordan",
                            "lastName": "Fix",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jordan Fix"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46247320"
                        ],
                        "name": "Saleem Abdulrasool",
                        "slug": "Saleem-Abdulrasool",
                        "structuredName": {
                            "firstName": "Saleem",
                            "lastName": "Abdulrasool",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saleem Abdulrasool"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46193056"
                        ],
                        "name": "Summer Deng",
                        "slug": "Summer-Deng",
                        "structuredName": {
                            "firstName": "Summer",
                            "lastName": "Deng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Summer Deng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46257780"
                        ],
                        "name": "Roman Dzhabarov",
                        "slug": "Roman-Dzhabarov",
                        "structuredName": {
                            "firstName": "Roman",
                            "lastName": "Dzhabarov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Roman Dzhabarov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "153509089"
                        ],
                        "name": "James Hegeman",
                        "slug": "James-Hegeman",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Hegeman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "James Hegeman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46211183"
                        ],
                        "name": "Roman Levenstein",
                        "slug": "Roman-Levenstein",
                        "structuredName": {
                            "firstName": "Roman",
                            "lastName": "Levenstein",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Roman Levenstein"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2130533"
                        ],
                        "name": "Bertrand A. Maher",
                        "slug": "Bertrand-A.-Maher",
                        "structuredName": {
                            "firstName": "Bertrand",
                            "lastName": "Maher",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bertrand A. Maher"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143758120"
                        ],
                        "name": "N. Satish",
                        "slug": "N.-Satish",
                        "structuredName": {
                            "firstName": "Nadathur",
                            "lastName": "Satish",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Satish"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2925676"
                        ],
                        "name": "Jakob R. Olesen",
                        "slug": "Jakob-R.-Olesen",
                        "structuredName": {
                            "firstName": "Jakob",
                            "lastName": "Olesen",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jakob R. Olesen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1686843"
                        ],
                        "name": "Jongsoo Park",
                        "slug": "Jongsoo-Park",
                        "structuredName": {
                            "firstName": "Jongsoo",
                            "lastName": "Park",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jongsoo Park"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46250117"
                        ],
                        "name": "Artem Rakhov",
                        "slug": "Artem-Rakhov",
                        "structuredName": {
                            "firstName": "Artem",
                            "lastName": "Rakhov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Artem Rakhov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1711231"
                        ],
                        "name": "M. Smelyanskiy",
                        "slug": "M.-Smelyanskiy",
                        "structuredName": {
                            "firstName": "Mikhail",
                            "lastName": "Smelyanskiy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Smelyanskiy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 80,
                                "start": 76
                            }
                        ],
                        "text": "More narrowly construed by their application to machine learning, XLA [24], Glow [48] and TVM [49], address similar heterogeneous compilation objectives."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 85,
                                "start": 81
                            }
                        ],
                        "text": "More narrowly construed by their application to machine learning, XLA [24], Glow [48] and TVM [49], address similar"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 23823854,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0261195ae7e1545caefb0ea7afb92bd66bfbb790",
            "isKey": false,
            "numCitedBy": 164,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents the design of Glow, a machine learning compiler for heterogeneous hardware. It is a pragmatic approach to compilation that enables the generation of highly optimized code for multiple targets. Glow lowers the traditional neural network dataflow graph into a two-phase strongly-typed intermediate representation. The high-level intermediate representation allows the optimizer to perform domain-specific optimizations. The lower-level instruction-based address-only intermediate representation allows the compiler to perform memory-related optimizations, such as instruction scheduling, static memory allocation and copy elimination. At the lowest level, the optimizer performs machine-specific code generation to take advantage of specialized hardware features. Glow features a lowering phase which enables the compiler to support a high number of input operators as well as a large number of hardware targets by eliminating the need to implement all operators on all targets. The lowering phase is designed to reduce the input space and allow new hardware backends to focus on a small number of linear algebra primitives."
            },
            "slug": "Glow:-Graph-Lowering-Compiler-Techniques-for-Neural-Rotem-Fix",
            "title": {
                "fragments": [],
                "text": "Glow: Graph Lowering Compiler Techniques for Neural Networks"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "Glow features a lowering phase which enables the compiler to support a high number of input operators as well as a large number of hardware targets by eliminating the need to implement all operators on all targets."
            },
            "venue": {
                "fragments": [],
                "text": "ArXiv"
            },
            "year": 2018
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1683544"
                        ],
                        "name": "J. Auerbach",
                        "slug": "J.-Auerbach",
                        "structuredName": {
                            "firstName": "Joshua",
                            "lastName": "Auerbach",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Auerbach"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1678228"
                        ],
                        "name": "D. Bacon",
                        "slug": "D.-Bacon",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Bacon",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Bacon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36942521"
                        ],
                        "name": "Ioana Baldini",
                        "slug": "Ioana-Baldini",
                        "structuredName": {
                            "firstName": "Ioana",
                            "lastName": "Baldini",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ioana Baldini"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35977213"
                        ],
                        "name": "P. Cheng",
                        "slug": "P.-Cheng",
                        "structuredName": {
                            "firstName": "Perry",
                            "lastName": "Cheng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Cheng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33802916"
                        ],
                        "name": "Stephen J. Fink",
                        "slug": "Stephen-J.-Fink",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Fink",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stephen J. Fink"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714477"
                        ],
                        "name": "R. Rabbah",
                        "slug": "R.-Rabbah",
                        "structuredName": {
                            "firstName": "Rodric",
                            "lastName": "Rabbah",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Rabbah"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144162226"
                        ],
                        "name": "S. Shukla",
                        "slug": "S.-Shukla",
                        "structuredName": {
                            "firstName": "Sunil",
                            "lastName": "Shukla",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Shukla"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[43], with a co-designed Domain Specific Language (DSL) and compilation flow converting managed object semantics into static, vector or reconfigurable hardware; yet most of the effort in its Lime compiler reside in fitting round objects into square hardware (paraphrasing Kou and Palsberg [44])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 14971668,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0c2d4fc5e07ea623da42f5287af815d935909381",
            "isKey": false,
            "numCitedBy": 62,
            "numCiting": 14,
            "paperAbstract": {
                "fragments": [],
                "text": "Heterogeneous systems show a lot of promise for extracting highperformance by combining the benefits of conventional architectures with specialized accelerators in the form of graphics processors (GPUs) and reconfigurable hardware (FPGAs). Extracting this performance often entails programming in disparate languages and models, making it hard for a programmer to work equally well on all aspects of an application. Further, relatively little attention is paid to co-execution - the problem of orchestrating program execution using multiple distinct computational elements that work seamlessly together. We present Liquid Metal, a comprehensive compiler and runtime system for a new programming language called Lime. Our work enables the use of a single language for programming heterogeneous computing platforms, and the seamless co-execution of the resultant programs on CPUs and accelerators that include GPUs and FPGAs. We have developed a number of Lime applications, and successfully compiled some of these for co-execution on various GPU and FPGA enabled architectures. Our experience so far leads us to believe the Liquid Metal approach is promising and can make the computational power of heterogeneous architectures more easily accessible to mainstream programmers."
            },
            "slug": "A-compiler-and-runtime-for-heterogeneous-computing-Auerbach-Bacon",
            "title": {
                "fragments": [],
                "text": "A compiler and runtime for heterogeneous computing"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "Liquid Metal is presented, a comprehensive compiler and runtime system for a new programming language called Lime that enables the use of a single language for programming heterogeneous computing platforms, and the seamless co-execution of the resultant programs on CPUs and accelerators that include GPUs and FPGAs."
            },
            "venue": {
                "fragments": [],
                "text": "DAC Design Automation Conference 2012"
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1698938"
                        ],
                        "name": "A. Pnueli",
                        "slug": "A.-Pnueli",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Pnueli",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Pnueli"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "119614910"
                        ],
                        "name": "M. Siegel",
                        "slug": "M.-Siegel",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Siegel",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Siegel"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1774977"
                        ],
                        "name": "Eli Singerman",
                        "slug": "Eli-Singerman",
                        "structuredName": {
                            "firstName": "Eli",
                            "lastName": "Singerman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Eli Singerman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 83,
                                "start": 79
                            }
                        ],
                        "text": "A long term goal would be to reproduce the successes of translation validation [11], [12], [13], [14] and modern approaches to compiler testing [15]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14822655,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d8b4164fef65ffc7082a3c95b0a706e5c3aa38f9",
            "isKey": false,
            "numCitedBy": 515,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "We present the notion of translation validation as a new approach to the veriication of translators (compilers, code generators). Rather than proving in advance that the compiler always produces a target code which correctly implements the source code (compiler verii-cation), each individual translation (i.e. a run of the compiler) is followed by a validation phase which veriies that the target code produced on this run correctly implements the submitted source program. Several ingredients are necessary to set up the { fully automatic { translation validation process, among which are: 1. A common semantic framework for the representation of the source code and the generated target code. 2. A formalization of the notion of \"correct implementation\" as a re-nement relation. 3. A syntactic simulation-based proof method which allows to automatically verify that one model of the semantic framework, representing the produced target code, correctly implements another model which represents the source. These, and other ingredients are elaborated in this paper, in which we illustrate the new approach in a most challenging case. We consider a translation (compilation) from the synchronous multi-clock data-ow language Signal to asynchronous (sequential) C-code."
            },
            "slug": "Translation-Validation-Pnueli-Siegel",
            "title": {
                "fragments": [],
                "text": "Translation Validation"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "This paper considers a translation (compilation) from the synchronous multi-clock data-ow language Signal to asynchronous (sequential) C-code and presents the notion of translation validation as a new approach to the veriication of translators (compilers, code generators)."
            },
            "venue": {
                "fragments": [],
                "text": "TACAS"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3004504"
                        ],
                        "name": "C. Click",
                        "slug": "C.-Click",
                        "structuredName": {
                            "firstName": "Cliff",
                            "lastName": "Click",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Click"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145971118"
                        ],
                        "name": "K. Cooper",
                        "slug": "K.-Cooper",
                        "structuredName": {
                            "firstName": "Keith",
                            "lastName": "Cooper",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Cooper"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 142,
                                "start": 138
                            }
                        ],
                        "text": "first illustrations of the benefits of combining passes was to mix constant propagation, value numbering and unreachable code elimination [10]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6849837,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9834a7794acc843e3f3d471275b70c6664a6fd9f",
            "isKey": false,
            "numCitedBy": 179,
            "numCiting": 59,
            "paperAbstract": {
                "fragments": [],
                "text": "Modern optimizing compilers use several passes over a program's intermediate representation to generate good code. Many of these optimizations exhibit a phase-ordering problem. Getting the best code may require iterating optimizations until a fixed point is reached. Combining these phases can lead to the discovery of more facts about the program, exposing more opportunities for optimization. This article presents a framework for describing optimizations. It shows how to combine two such frameworks and how to reason about the properties of the resulting framework. The structure of the frame work provides insight into when a combination yields better results. To make the ideas more concrete, this article presents a framework for combining constant propagation, value numbering, and unreachable-code elimination. It is an open question as to what other frameworks can be combined in this way."
            },
            "slug": "Combining-analyses,-combining-optimizations-Click-Cooper",
            "title": {
                "fragments": [],
                "text": "Combining analyses, combining optimizations"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This article presents a framework for combining constant propagation, value numbering, and unreachable-code elimination, and shows how to combine two such frameworks and how to reason about the properties of the resulting framework."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1924748"
                        ],
                        "name": "L\u00e9na\u00efc Bagn\u00e8res",
                        "slug": "L\u00e9na\u00efc-Bagn\u00e8res",
                        "structuredName": {
                            "firstName": "L\u00e9na\u00efc",
                            "lastName": "Bagn\u00e8res",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L\u00e9na\u00efc Bagn\u00e8res"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2054833547"
                        ],
                        "name": "O. Zinenko",
                        "slug": "O.-Zinenko",
                        "structuredName": {
                            "firstName": "Oleksandr",
                            "lastName": "Zinenko",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "O. Zinenko"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1809689"
                        ],
                        "name": "St\u00e9phane Huot",
                        "slug": "St\u00e9phane-Huot",
                        "structuredName": {
                            "firstName": "St\u00e9phane",
                            "lastName": "Huot",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "St\u00e9phane Huot"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 4,
                                "start": 0
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14747594,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f090a2d883d667242a08d54aa08b9a9e2d783413",
            "isKey": false,
            "numCitedBy": 26,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "While compilers offer a fair trade-off between productivity and executable performance in single-threaded execution, their optimizations remain fragile when addressing compute-intensive code for parallel architectures with deep memory hierarchies. Moreover, these optimizations operate as black boxes, impenetrable for the user, leaving them with no alternative to time-consuming and error-prone manual optimization in cases where an imprecise cost model or a weak analysis resulted in a bad optimization decision. To address this issue, we propose a technique allowing to automatically translate an arbitrary polyhedral optimization, used internally by loop-level optimization frameworks of several modern compilers, into a sequence of comprehensible syntactic transformations as long as this optimization focuses on scheduling loop iterations. This approach opens the black box of the polyhedral frameworks, enabling users to examine, refine, replay and even design complex optimizations semi-automatically in partnership with the compiler."
            },
            "slug": "Opening-polyhedral-compiler's-black-box-Bagn\u00e8res-Zinenko",
            "title": {
                "fragments": [],
                "text": "Opening polyhedral compiler's black box"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This work proposes a technique allowing to automatically translate an arbitrary polyhedral optimization, used internally by loop-level optimization frameworks of several modern compilers, into a sequence of comprehensible syntactic transformations as long as this optimization focuses on scheduling loop iterations."
            },
            "venue": {
                "fragments": [],
                "text": "2016 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)"
            },
            "year": 2016
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2332042"
                        ],
                        "name": "Martin Bravenboer",
                        "slug": "Martin-Bravenboer",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Bravenboer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Martin Bravenboer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3086506"
                        ],
                        "name": "K. T. Kalleberg",
                        "slug": "K.-T.-Kalleberg",
                        "structuredName": {
                            "firstName": "Karl",
                            "lastName": "Kalleberg",
                            "middleNames": [
                                "Trygve"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. T. Kalleberg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2639317"
                        ],
                        "name": "R. Vermaas",
                        "slug": "R.-Vermaas",
                        "structuredName": {
                            "firstName": "Rob",
                            "lastName": "Vermaas",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Vermaas"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "46938648"
                        ],
                        "name": "E. Visser",
                        "slug": "E.-Visser",
                        "structuredName": {
                            "firstName": "Eelco",
                            "lastName": "Visser",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Visser"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 97,
                                "start": 93
                            }
                        ],
                        "text": "formalizing, and verifying the rewriting logic automatically would be an important next step [36], [37]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1415043,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f11e9728f94427819a7e3c5df52e1c5af2f18775",
            "isKey": false,
            "numCitedBy": 359,
            "numCiting": 85,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Stratego/XT-0.17.-A-language-and-toolset-for-Bravenboer-Kalleberg",
            "title": {
                "fragments": [],
                "text": "Stratego/XT 0.17. A language and toolset for program transformation"
            },
            "venue": {
                "fragments": [],
                "text": "Sci. Comput. Program."
            },
            "year": 2008
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "87859524"
                        ],
                        "name": "Tim Zerrell",
                        "slug": "Tim-Zerrell",
                        "structuredName": {
                            "firstName": "Tim",
                            "lastName": "Zerrell",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tim Zerrell"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "6985274"
                        ],
                        "name": "J. Bruestle",
                        "slug": "J.-Bruestle",
                        "structuredName": {
                            "firstName": "Jeremy",
                            "lastName": "Bruestle",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Bruestle"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 94,
                                "start": 90
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 218,
                                "start": 212
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                }
            ],
            "corpusId": 80628274,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a85bf91720f08b6c1c9f343e390864cb36e92851",
            "isKey": false,
            "numCitedBy": 24,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "Hardware architectures and machine learning (ML) libraries evolve rapidly. Traditional compilers often fail to generate high-performance code across the spectrum of new hardware offerings. To mitigate, engineers develop hand-tuned kernels for each ML library update and hardware upgrade. Unfortunately, this approach requires excessive engineering effort to scale or maintain with any degree of state-of-the-art performance. Here we present a Nested Polyhedral Model for representing highly parallelizable computations with limited dependencies between iterations. This model provides an underlying framework for an intermediate representation (IR) called Stripe, amenable to standard compiler techniques while naturally modeling key aspects of modern ML computing. Stripe represents parallelism, efficient memory layout, and multiple compute units at a level of abstraction amenable to automatic optimization. We describe how Stripe enables a compiler for ML in the style of LLVM that allows independent development of algorithms, optimizations, and hardware accelerators. We also discuss the design exploration advantages of Stripe over kernel libraries and schedule-based or schedule-space-based code generation."
            },
            "slug": "Stripe:-Tensor-Compilation-via-the-Nested-Model-Zerrell-Bruestle",
            "title": {
                "fragments": [],
                "text": "Stripe: Tensor Compilation via the Nested Polyhedral Model"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This model provides an underlying framework for an intermediate representation (IR) called Stripe, amenable to standard compiler techniques while naturally modeling key aspects of modern ML computing, which enables a compiler for ML in the style of LLVM that allows independent development of algorithms, optimizations, and hardware accelerators."
            },
            "venue": {
                "fragments": [],
                "text": "ArXiv"
            },
            "year": 2019
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751936"
                        ],
                        "name": "Uday Bondhugula",
                        "slug": "Uday-Bondhugula",
                        "structuredName": {
                            "firstName": "Uday",
                            "lastName": "Bondhugula",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Uday Bondhugula"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1763408"
                        ],
                        "name": "Albert Hartono",
                        "slug": "Albert-Hartono",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Hartono",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Hartono"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145981817"
                        ],
                        "name": "J. Ramanujam",
                        "slug": "J.-Ramanujam",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Ramanujam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ramanujam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293384"
                        ],
                        "name": "P. Sadayappan",
                        "slug": "P.-Sadayappan",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Sadayappan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Sadayappan"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 57,
                                "start": 53
                            }
                        ],
                        "text": "the loop nest metaprogramming techniques from Halide [50]"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 63,
                                "start": 57
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                }
            ],
            "corpusId": 7086982,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f0f4757aa2f923a349e8357e73850a78e9b80fee",
            "isKey": false,
            "numCitedBy": 860,
            "numCiting": 71,
            "paperAbstract": {
                "fragments": [],
                "text": "We present the design and implementation of an automatic polyhedral source-to-source transformation framework that can optimize regular programs (sequences of possibly imperfectly nested loops) for parallelism and locality simultaneously. Through this work, we show the practicality of analytical model-driven automatic transformation in the polyhedral model -- far beyond what is possible by current production compilers. Unlike previous works, our approach is an end-to-end fully automatic one driven by an integer linear optimization framework that takes an explicit view of finding good ways of tiling for parallelism and locality using affine transformations. The framework has been implemented into a tool to automatically generate OpenMP parallel code from C program sections. Experimental results from the tool show very high speedups for local and parallel execution on multi-cores over state-of-the-art compiler frameworks from the research community as well as the best native production compilers. The system also enables the easy use of powerful empirical/iterative optimization for general arbitrarily nested loop sequences."
            },
            "slug": "A-practical-automatic-polyhedral-parallelizer-and-Bondhugula-Hartono",
            "title": {
                "fragments": [],
                "text": "A practical automatic polyhedral parallelizer and locality optimizer"
            },
            "tldr": {
                "abstractSimilarityScore": 60,
                "text": "An automatic polyhedral source-to-source transformation framework that can optimize regular programs for parallelism and locality simultaneously simultaneously and is implemented into a tool to automatically generate OpenMP parallel code from C program sections."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '08"
            },
            "year": 2008
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1508570942"
                        ],
                        "name": "S. Vu",
                        "slug": "S.-Vu",
                        "structuredName": {
                            "firstName": "Son",
                            "lastName": "Vu",
                            "middleNames": [
                                "Tuan"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Vu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2905907"
                        ],
                        "name": "Karine Heydemann",
                        "slug": "Karine-Heydemann",
                        "structuredName": {
                            "firstName": "Karine",
                            "lastName": "Heydemann",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Karine Heydemann"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1518621380"
                        ],
                        "name": "Arnaud de Grandmaison",
                        "slug": "Arnaud-de-Grandmaison",
                        "structuredName": {
                            "firstName": "Arnaud",
                            "lastName": "Grandmaison",
                            "middleNames": [
                                "de"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Arnaud de Grandmaison"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 21,
                                "start": 17
                            }
                        ],
                        "text": "such protections [17]; this lack of transparency is known as WYSINWYX [18] in secure compilation."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 210836647,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1de9c28e1e3c405c03da4cca8b983e6c6eef29fa",
            "isKey": false,
            "numCitedBy": 8,
            "numCiting": 107,
            "paperAbstract": {
                "fragments": [],
                "text": "Annotations and assertions capturing static program properties are ubiquitous, from robust software engineering to safety-critical or secure code. These may be functional or non-functional properties of control and data flow, memory usage, I/O and real time. We propose an approach to encode, translate, and preserve the semantics of both functional and non-functional properties along the optimizing compilation of C to machine code. The approach involves (1) capturing and translating source-level properties through lowering passes and intermediate representations, such that data and control flow optimizations will preserve their consistency with the transformed program, and (2) carrying properties and their translation as debug information down to machine code. Our experiments using LLVM validate the soundness, expressiveness and efficiency of the approach, considering a reference suite of functional properties as well as established security properties and applications hardened against side-channel attacks."
            },
            "slug": "Secure-delivery-of-program-properties-through-Vu-Heydemann",
            "title": {
                "fragments": [],
                "text": "Secure delivery of program properties through optimizing compilation"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "This work proposes an approach to encode, translate, and preserve the semantics of both functional and non-functional properties along the optimizing compilation of C to machine code, considering a reference suite of functional properties as well as established security properties and applications hardened against side-channel attacks."
            },
            "venue": {
                "fragments": [],
                "text": "CC"
            },
            "year": 2020
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144122184"
                        ],
                        "name": "Chandan Reddy",
                        "slug": "Chandan-Reddy",
                        "structuredName": {
                            "firstName": "Chandan",
                            "lastName": "Reddy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chandan Reddy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751936"
                        ],
                        "name": "Uday Bondhugula",
                        "slug": "Uday-Bondhugula",
                        "structuredName": {
                            "firstName": "Uday",
                            "lastName": "Bondhugula",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Uday Bondhugula"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 6293767,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f53ec8bf969d6c7d042e0e93bb64094cea01f29c",
            "isKey": false,
            "numCitedBy": 15,
            "numCiting": 40,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper proposes techniques for data allocation and computation mapping when compiling affine loop nest sequences for distributed-memory clusters.Techniques for transformation and detection of parallelism, and generation of communication sets relying on the polyhedral framework already exist. However, these recent approaches used a simple strategy to map computation to nodes -- typically block or block-cyclic. These mappings may lead to excess communication volume for multiple loop nests. In addition, the data allocation strategy used did not permit efficient weak scaling. We address these complementary problems by proposing automatic techniques to determine computation placements for identified parallelism and allocation of data. Our approach for data allocation is driven by tiling of data spaces along with a scheme to allocate and deallocate tiles on demand and reuse them. We show that our approach for computation mapping yields more effective mappings than those that can be developed using vendor-supplied libraries. Experimental results on some sequences of BLAS calls demonstrate a mean speedup of 1.82x over versions written with ScaLAPACK. Besides enabling weak scaling for distributed memory, data tiling also improves locality for shared-memory parallelization. Experimental results on a 32-core shared-memory SMP system shows a mean speedup of 2.67x over code that is not data tiled."
            },
            "slug": "Effective-automatic-computation-placement-and-data-Reddy-Bondhugula",
            "title": {
                "fragments": [],
                "text": "Effective automatic computation placement and data allocation for parallelization of regular programs"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This paper proposes automatic techniques to determine computation placements for identified parallelism and allocation of data, driven by tiling of data spaces along with a scheme to allocate and deallocate tiles on demand and reuse them and shows that this approach for computation mapping yields more effective mappings."
            },
            "venue": {
                "fragments": [],
                "text": "ICS '14"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2688662"
                        ],
                        "name": "T. Parr",
                        "slug": "T.-Parr",
                        "structuredName": {
                            "firstName": "Terence",
                            "lastName": "Parr",
                            "middleNames": [
                                "John"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Parr"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3284993"
                        ],
                        "name": "R. Quong",
                        "slug": "R.-Quong",
                        "structuredName": {
                            "firstName": "Russell",
                            "lastName": "Quong",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Quong"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 56,
                                "start": 52
                            }
                        ],
                        "text": "One step further up into the language syntax, ANTLR [47] is among a class of parser generators that aim to facilitate the development of compiler frontends."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 42,
                                "start": 37
                            }
                        ],
                        "text": "Combining MLIR with a system such as ANTLR could expand reusability upstream all the way to frontends and development environments."
                    },
                    "intents": []
                }
            ],
            "corpusId": 13453016,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c55bf987abe8ebb81231268f3bda609423f6e532",
            "isKey": false,
            "numCitedBy": 688,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive\u2010descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public\u2010domain parser generator that combines the flexibility of hand\u2010coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand\u2010tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees."
            },
            "slug": "ANTLR:-A-predicated\u2010LL(k)-parser-generator-Parr-Quong",
            "title": {
                "fragments": [],
                "text": "ANTLR: A predicated\u2010LL(k) parser generator"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "ANTLR is introduced, a public\u2010domain parser generator that combines the flexibility of hand\u2010coded parsing with the convenience of a parser generator, which is a component of PCCTS."
            },
            "venue": {
                "fragments": [],
                "text": "Softw. Pract. Exp."
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1804502"
                        ],
                        "name": "A. Appel",
                        "slug": "A.-Appel",
                        "structuredName": {
                            "firstName": "Andrew",
                            "lastName": "Appel",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Appel"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 104,
                                "start": 101
                            }
                        ],
                        "text": "Value Dominance and Visibility: Ops can only use values that are in scope, i.e. visible according to SSA dominance, nesting, and semantic restrictions imposed by enclosing operations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 62
                            }
                        ],
                        "text": "Symbols are most useful for named entities need that not obey SSA: they cannot be redefined within the same table, but they can be used prior to their definition."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 60,
                                "start": 57
                            }
                        ],
                        "text": "The graph of successors defines a CFG, allowing standard SSA-based control flow within a region."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 57,
                                "start": 54
                            }
                        ],
                        "text": "Values are visible within a CFG if they obey standard SSA dominance relationships, where control is guaranteed to pass through a definition before reaching a use."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 101,
                                "start": 98
                            }
                        ],
                        "text": "(2) Mix of abstractions: Bodies of affine loops in MLIR can be expressed with operations on typed SSA values."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 69,
                                "start": 66
                            }
                        ],
                        "text": "MLIR does this by (1) standardizing the Static Single Assignment (SSA)-based IR data structures, (2) providing a declarative system for defining IR dialects, and (3) providing a wide range of common infrastructure including documentation, parsing and printing logic, location tracking, multithreaded compilation support, pass management, etc."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 115,
                                "start": 112
                            }
                        ],
                        "text": "Ops take and produce zero or more values, called operands and results respectively, and these are maintained in SSA form."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 58
                            }
                        ],
                        "text": "As a result, the IR enforces the value-based semantics of SSA, its referential transparency and algorithmic efficiency, all considered essential to a modern compiler infrastructure."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 3,
                                "start": 0
                            }
                        ],
                        "text": "SSA and Regions [Parsimony]: The Static Single Assignment (SSA) form [3] is a widely used representation in compiler IRs."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 105,
                                "start": 102
                            }
                        ],
                        "text": "Each block has a (potentially empty) list of typed block arguments, which are regular values and obey SSA."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 61
                            }
                        ],
                        "text": "Instead of using \u03c6 nodes, MLIR uses a functional form of SSA [20] where terminators pass values into block arguments defined by the successor block."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 37,
                                "start": 34
                            }
                        ],
                        "text": "Indeed this trait guarantees that SSA use-def chain cannot cross the region boundaries and can be processed in isolation."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 223,
                                "start": 220
                            }
                        ],
                        "text": "Finally, this explicit graph design and the extensibility of Ops is reminiscent of the sea-of-nodes representation [21]: this connection is intentional and has been a major influence for the selection of MLIR\u2019s flavor of SSA."
                    },
                    "intents": []
                }
            ],
            "corpusId": 207227209,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ac48938304614b94c1becc17cb9bd162bd490f4b",
            "isKey": true,
            "numCitedBy": 188,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "Static Single-Assignment (SSA) form is an intermediate language designed to make optimization clean and efficient for imperative-language (Fortran, C) compilers. Lambda-calculus is an intermediate language that makes optimization clean and efficient for functionallanguage (Scheme, ML, Haskell) compilers. The SSA community draws pictures of graphs with basic blocks and flow edges, and the functional-language community writes lexically nested functions, but (as Richard Kelsey recently pointed out [9]) they\u2019re both doing exactly the same thing in different notation."
            },
            "slug": "SSA-is-functional-programming-Appel",
            "title": {
                "fragments": [],
                "text": "SSA is functional programming"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "The SSA community draws pictures of graphs with basic blocks and flow edges, and the functional-language community writes lexically nested functions, but (as Richard Kelsey recently pointed out) they\u2019re both doing exactly the same thing in different notation."
            },
            "venue": {
                "fragments": [],
                "text": "SIGP"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3223092"
                        ],
                        "name": "Bernhard Schommer",
                        "slug": "Bernhard-Schommer",
                        "structuredName": {
                            "firstName": "Bernhard",
                            "lastName": "Schommer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bernhard Schommer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2919018"
                        ],
                        "name": "Christoph Cullmann",
                        "slug": "Christoph-Cullmann",
                        "structuredName": {
                            "firstName": "Christoph",
                            "lastName": "Cullmann",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christoph Cullmann"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1787756"
                        ],
                        "name": "Gernot Gebhard",
                        "slug": "Gernot-Gebhard",
                        "structuredName": {
                            "firstName": "Gernot",
                            "lastName": "Gebhard",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Gernot Gebhard"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49392754"
                        ],
                        "name": "X. Leroy",
                        "slug": "X.-Leroy",
                        "structuredName": {
                            "firstName": "Xavier",
                            "lastName": "Leroy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "X. Leroy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109807090"
                        ],
                        "name": "Michael Schmidt",
                        "slug": "Michael-Schmidt",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Schmidt",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael Schmidt"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40325330"
                        ],
                        "name": "Simon Wegener",
                        "slug": "Simon-Wegener",
                        "structuredName": {
                            "firstName": "Simon",
                            "lastName": "Wegener",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Simon Wegener"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 204,
                                "start": 200
                            }
                        ],
                        "text": "This is particularly problematic when compiling safetycritical and sensitive applications, where tracing lowering and optimization steps is an essential component of software certification procedures [16]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 52816519,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "38f1f3aa57bce538e94ee955fcba0c94ca01c62a",
            "isKey": false,
            "numCitedBy": 8,
            "numCiting": 10,
            "paperAbstract": {
                "fragments": [],
                "text": "We present __builtin_ais_annot(), a user-friendly, versatile way to transfer annotations (also known as flow facts) written on the source code level to the machine code level. To do so, we couple two tools often used during the development of safety-critical hard real-time systems, the formally verified C compiler CompCert and the static WCET analyzer aiT. CompCert stores the AIS annotations given via __builtin_ais_annot() in a special section of the ELF binary, which can later be extracted automatically by aiT."
            },
            "slug": "Embedded-Program-Annotations-for-WCET-Analysis-Schommer-Cullmann",
            "title": {
                "fragments": [],
                "text": "Embedded Program Annotations for WCET Analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 94,
                "text": "This work presents __builtin_ais_annot(), a user-friendly, versatile way to transfer annotations (also known as flow facts) written on the source code level to the machine code level."
            },
            "venue": {
                "fragments": [],
                "text": "WCET"
            },
            "year": 2018
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1755724"
                        ],
                        "name": "Jean-Baptiste Tristan",
                        "slug": "Jean-Baptiste-Tristan",
                        "structuredName": {
                            "firstName": "Jean-Baptiste",
                            "lastName": "Tristan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jean-Baptiste Tristan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49392754"
                        ],
                        "name": "X. Leroy",
                        "slug": "X.-Leroy",
                        "structuredName": {
                            "firstName": "Xavier",
                            "lastName": "Leroy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "X. Leroy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 101,
                                "start": 97
                            }
                        ],
                        "text": "A long term goal would be to reproduce the successes of translation validation [11], [12], [13], [14] and modern approaches to compiler testing [15]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 11808129,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "84e5299e430d5c2f34c37c9371bf865f5ab5e180",
            "isKey": false,
            "numCitedBy": 58,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "Translation validation establishes a posteriori the correctness of a run of a compilation pass or other program transformation. In this paper, we develop an efficient translation validation algorithm for the Lazy Code Motion (LCM) optimization. LCM is an interesting challenge for validation because it is a global optimization that moves code across loops. Consequently, care must be taken not to move computations that may fail before loops that may not terminate. Our validator includes a specific check for anticipability to rule out such incorrect moves. We present a mechanically-checked proof of correctness of the validation algorithm, using the Coq proof assistant. Combining our validator with an unverified implementation of LCM, we obtain a LCM pass that is provably semantics-preserving and was integrated in the CompCert formally verified compiler."
            },
            "slug": "Verified-validation-of-lazy-code-motion-Tristan-Leroy",
            "title": {
                "fragments": [],
                "text": "Verified validation of lazy code motion"
            },
            "tldr": {
                "abstractSimilarityScore": 48,
                "text": "An efficient translation validation algorithm for the Lazy Code Motion (LCM) optimization is developed and a LCM pass that is provably semantics-preserving and was integrated in the CompCert formally verified compiler is obtained."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '09"
            },
            "year": 2009
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1756389"
                        ],
                        "name": "T. Grosser",
                        "slug": "T.-Grosser",
                        "structuredName": {
                            "firstName": "Tobias",
                            "lastName": "Grosser",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Grosser"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1708011"
                        ],
                        "name": "Armin Gr\u00f6\u00dflinger",
                        "slug": "Armin-Gr\u00f6\u00dflinger",
                        "structuredName": {
                            "firstName": "Armin",
                            "lastName": "Gr\u00f6\u00dflinger",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Armin Gr\u00f6\u00dflinger"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714483"
                        ],
                        "name": "C. Lengauer",
                        "slug": "C.-Lengauer",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Lengauer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Lengauer"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 124,
                                "start": 120
                            }
                        ],
                        "text": "However, polyhedral transformations require raising into a representation often drastically different from the original [31], [32]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 18533155,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3d64988b882541afa8f03f912229fbba49c82e74",
            "isKey": false,
            "numCitedBy": 290,
            "numCiting": 35,
            "paperAbstract": {
                "fragments": [],
                "text": "The polyhedral model for loop parallelization has proved to be an effective tool for advanced optimization and automatic parallelization of programs in higher-level languages. Yet, to integrate such optimizations seamlessly into production compilers, they must be performed on the compiler's internal, low-level, intermediate representation (IR). With Polly, we present an infrastructure for polyhedral optimizations on such an IR. We describe the detection of program parts amenable to a polyhedral optimization (so-called static control parts), their translation to a Z-polyhedral representation, optimizations on this representation and the generation of optimized IR code. Furthermore, we define an interface for connecting external optimizers and present a novel way of using the parallelism they introduce to generate SIMD and OpenMP code. To evaluate Polly, we compile the PolyBench 2.0 benchmarks fully automatically with PLuTo as external optimizer and parallelizer. We can report on significant speedups."
            },
            "slug": "Polly-Performing-Polyhedral-Optimizations-on-a-Grosser-Gr\u00f6\u00dflinger",
            "title": {
                "fragments": [],
                "text": "Polly - Performing Polyhedral Optimizations on a Low-Level Intermediate Representation"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "Polly is presented, an infrastructure for polyhedral optimizations on the compiler's internal, low-level, intermediate representation (IR) and an interface for connecting external optimizers and a novel way of using the parallelism they introduce to generate SIMD and OpenMP code is presented."
            },
            "venue": {
                "fragments": [],
                "text": "Parallel Process. Lett."
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "69048861"
                        ],
                        "name": "R. Cytron",
                        "slug": "R.-Cytron",
                        "structuredName": {
                            "firstName": "Ronald",
                            "lastName": "Cytron",
                            "middleNames": [
                                "Gary"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Cytron"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144704592"
                        ],
                        "name": "J. Ferrante",
                        "slug": "J.-Ferrante",
                        "structuredName": {
                            "firstName": "Jeanne",
                            "lastName": "Ferrante",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ferrante"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1685689"
                        ],
                        "name": "B. Rosen",
                        "slug": "B.-Rosen",
                        "structuredName": {
                            "firstName": "Barry",
                            "lastName": "Rosen",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "B. Rosen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36114502"
                        ],
                        "name": "M. Wegman",
                        "slug": "M.-Wegman",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Wegman",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Wegman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2386609"
                        ],
                        "name": "F. K. Zadeck",
                        "slug": "F.-K.-Zadeck",
                        "structuredName": {
                            "firstName": "F.",
                            "lastName": "Zadeck",
                            "middleNames": [
                                "Kenneth"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. K. Zadeck"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 72,
                                "start": 69
                            }
                        ],
                        "text": "SSA and Regions [Parsimony]: The Static Single Assignment (SSA) form [3] is a widely used representation in compiler IRs."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 13243943,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cd65db4d7091b8f42333ed755ed7150f14b3be5c",
            "isKey": false,
            "numCitedBy": 2354,
            "numCiting": 84,
            "paperAbstract": {
                "fragments": [],
                "text": "In optimizing compilers, data structure choices directly influence the power and efficiency of practical program optimization. A poor choice of data structure can inhibit optimization or slow compilation to the point that advanced optimization features become undesirable. Recently, static single assignment form and the control dependence graph have been proposed to represent data flow and control flow properties of programs. Each of these previously unrelated techniques lends efficiency and power to a useful class of program optimizations. Although both of these structures are attractive, the difficulty of their construction and their potential size have discouraged their use. We present new algorithms that efficiently compute these data structures for arbitrary control flow graphs. The algorithms use {\\em dominance frontiers}, a new concept that may have other applications. We also give analytical and experimental evidence that all of these data structures are usually linear in the size of the original program. This paper thus presents strong evidence that these structures can be of practical use in optimization."
            },
            "slug": "Efficiently-computing-static-single-assignment-form-Cytron-Ferrante",
            "title": {
                "fragments": [],
                "text": "Efficiently computing static single assignment form and the control dependence graph"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "New algorithms that efficiently compute static single assignment form and control dependence graph data structures for arbitrary control flow graphs are presented and it is given that all of these data structures are usually linear in the size of the original program."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1758245"
                        ],
                        "name": "Riyadh Baghdadi",
                        "slug": "Riyadh-Baghdadi",
                        "structuredName": {
                            "firstName": "Riyadh",
                            "lastName": "Baghdadi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Riyadh Baghdadi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "4875117"
                        ],
                        "name": "Jessica Ray",
                        "slug": "Jessica-Ray",
                        "structuredName": {
                            "firstName": "Jessica",
                            "lastName": "Ray",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jessica Ray"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40899986"
                        ],
                        "name": "Malek Ben Romdhane",
                        "slug": "Malek-Ben-Romdhane",
                        "structuredName": {
                            "firstName": "Malek",
                            "lastName": "Romdhane",
                            "middleNames": [
                                "Ben"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Malek Ben Romdhane"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3436746"
                        ],
                        "name": "Emanuele Del Sozzo",
                        "slug": "Emanuele-Del-Sozzo",
                        "structuredName": {
                            "firstName": "Emanuele",
                            "lastName": "Sozzo",
                            "middleNames": [
                                "Del"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Emanuele Del Sozzo"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2060643"
                        ],
                        "name": "Abdurrahman Akkas",
                        "slug": "Abdurrahman-Akkas",
                        "structuredName": {
                            "firstName": "Abdurrahman",
                            "lastName": "Akkas",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Abdurrahman Akkas"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "11860259"
                        ],
                        "name": "Yunming Zhang",
                        "slug": "Yunming-Zhang",
                        "structuredName": {
                            "firstName": "Yunming",
                            "lastName": "Zhang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yunming Zhang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "8844033"
                        ],
                        "name": "Patricia Suriana",
                        "slug": "Patricia-Suriana",
                        "structuredName": {
                            "firstName": "Patricia",
                            "lastName": "Suriana",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Patricia Suriana"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145683292"
                        ],
                        "name": "S. Kamil",
                        "slug": "S.-Kamil",
                        "structuredName": {
                            "firstName": "Shoaib",
                            "lastName": "Kamil",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Kamil"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 56173920,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "8c7310477fd027193cd040288f0aa9824c80b91f",
            "isKey": false,
            "numCitedBy": 122,
            "numCiting": 55,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper introduces Tiramisu, a polyhedral framework designed to generate high performance code for multiple platforms including multicores, GPUs, and distributed machines. Tiramisu introduces a scheduling language with novel commands to explicitly manage the complexities that arise when targeting these systems. The framework is designed for the areas of image processing, stencils, linear algebra and deep learning. Tiramisu has two main features: it relies on a flexible representation based on the polyhedral model and it has a rich scheduling language allowing fine-grained control of optimizations. Tiramisu uses a four-level intermediate representation that allows full separation between the algorithms, loop transformations, data layouts, and communication. This separation simplifies targeting multiple hardware architectures with the same algorithm. We evaluate Tiramisu by writing a set of image processing, deep learning, and linear algebra benchmarks and compare them with state-of-the-art compilers and hand-tuned libraries. We show that Tiramisu matches or outperforms existing compilers and libraries on different hardware architectures, including multicore CPUs, GPUs, and distributed machines."
            },
            "slug": "Tiramisu:-A-Polyhedral-Compiler-for-Expressing-Fast-Baghdadi-Ray",
            "title": {
                "fragments": [],
                "text": "Tiramisu: A Polyhedral Compiler for Expressing Fast and Portable Code"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "Tiramisu introduces a scheduling language with novel commands to explicitly manage the complexities that arise when targeting these systems, designed for the areas of image processing, stencils, linear algebra and deep learning."
            },
            "venue": {
                "fragments": [],
                "text": "2019 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)"
            },
            "year": 2019
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2560300"
                        ],
                        "name": "G. Balakrishnan",
                        "slug": "G.-Balakrishnan",
                        "structuredName": {
                            "firstName": "Gogul",
                            "lastName": "Balakrishnan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Balakrishnan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1703130"
                        ],
                        "name": "T. Reps",
                        "slug": "T.-Reps",
                        "structuredName": {
                            "firstName": "T.",
                            "lastName": "Reps",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Reps"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 74,
                                "start": 70
                            }
                        ],
                        "text": "such protections [17]; this lack of transparency is known as WYSINWYX [18] in secure compilation."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 110
                            }
                        ],
                        "text": "Optimizations may alter or completely invalidate such protections [17]; this lack of transparency is known as WYSINWYX [18] in secure compilation."
                    },
                    "intents": []
                }
            ],
            "corpusId": 2279802,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f19306e70c7374a6d9e9133bc419a2ef9678e7c2",
            "isKey": false,
            "numCitedBy": 245,
            "numCiting": 221,
            "paperAbstract": {
                "fragments": [],
                "text": "Over the last seven years, we have developed static-analysis methods to recover a good approximation to the variables and dynamically allocated memory objects of a stripped executable, and to track the flow of values through them. The article presents the algorithms that we developed, explains how they are used to recover Intermediate Representations (IRs) from executables that are similar to the IRs that would be available if one started from source code, and describes their application in the context of program understanding and automated bug hunting.\n Unlike algorithms for analyzing executables that existed prior to our work, the ones presented in this article provide useful information about memory accesses, even in the absence of debugging information. The ideas described in the article are incorporated in a tool for analyzing Intel x86 executables, called CodeSurfer/x86. CodeSurfer/x86 builds a system dependence graph for the program, and provides a GUI for exploring the graph by (i) navigating its edges, and (ii) invoking operations, such as forward slicing, backward slicing, and chopping, to discover how parts of the program can impact other parts.\n To assess the usefulness of the IRs recovered by CodeSurfer/x86 in the context of automated bug hunting, we built a tool on top of CodeSurfer/x86, called Device-Driver Analyzer for x86 (DDA/x86), which analyzes device-driver executables for bugs. Without the benefit of either source code or symbol-table/debugging information, DDA/x86 was able to find known bugs (that had been discovered previously by source-code analysis tools), along with useful error traces, while having a low false-positive rate. DDA/x86 is the first known application of program analysis/verification techniques to industrial executables."
            },
            "slug": "WYSINWYX:-What-you-see-is-not-what-you-eXecute-Balakrishnan-Reps",
            "title": {
                "fragments": [],
                "text": "WYSINWYX: What you see is not what you eXecute"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "The article presents the algorithms that were developed, explains how they are used to recover Intermediate Representations from executables that are similar to the IRs that would be available if one started from source code, and describes their application in the context of program understanding and automated bug hunting."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1913774"
                        ],
                        "name": "Tianqi Chen",
                        "slug": "Tianqi-Chen",
                        "structuredName": {
                            "firstName": "Tianqi",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tianqi Chen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47108160"
                        ],
                        "name": "T. Moreau",
                        "slug": "T.-Moreau",
                        "structuredName": {
                            "firstName": "Thierry",
                            "lastName": "Moreau",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Moreau"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1732910"
                        ],
                        "name": "Ziheng Jiang",
                        "slug": "Ziheng-Jiang",
                        "structuredName": {
                            "firstName": "Ziheng",
                            "lastName": "Jiang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ziheng Jiang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2149970173"
                        ],
                        "name": "Lianmin Zheng",
                        "slug": "Lianmin-Zheng",
                        "structuredName": {
                            "firstName": "Lianmin",
                            "lastName": "Zheng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lianmin Zheng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2621619"
                        ],
                        "name": "Eddie Q. Yan",
                        "slug": "Eddie-Q.-Yan",
                        "structuredName": {
                            "firstName": "Eddie",
                            "lastName": "Yan",
                            "middleNames": [
                                "Q."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Eddie Q. Yan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3050154"
                        ],
                        "name": "Haichen Shen",
                        "slug": "Haichen-Shen",
                        "structuredName": {
                            "firstName": "Haichen",
                            "lastName": "Shen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Haichen Shen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37270394"
                        ],
                        "name": "M. Cowan",
                        "slug": "M.-Cowan",
                        "structuredName": {
                            "firstName": "Meghan",
                            "lastName": "Cowan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Cowan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2185540"
                        ],
                        "name": "Leyuan Wang",
                        "slug": "Leyuan-Wang",
                        "structuredName": {
                            "firstName": "Leyuan",
                            "lastName": "Wang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Leyuan Wang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49994783"
                        ],
                        "name": "Yuwei Hu",
                        "slug": "Yuwei-Hu",
                        "structuredName": {
                            "firstName": "Yuwei",
                            "lastName": "Hu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yuwei Hu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717411"
                        ],
                        "name": "L. Ceze",
                        "slug": "L.-Ceze",
                        "structuredName": {
                            "firstName": "Luis",
                            "lastName": "Ceze",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Ceze"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1730156"
                        ],
                        "name": "Carlos Guestrin",
                        "slug": "Carlos-Guestrin",
                        "structuredName": {
                            "firstName": "Carlos",
                            "lastName": "Guestrin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Carlos Guestrin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144695691"
                        ],
                        "name": "A. Krishnamurthy",
                        "slug": "A.-Krishnamurthy",
                        "structuredName": {
                            "firstName": "Arvind",
                            "lastName": "Krishnamurthy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Krishnamurthy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 93,
                                "start": 90
                            }
                        ],
                        "text": "More narrowly construed by their application to machine learning, XLA [24], Glow [48] and TVM [49], address similar heterogeneous compilation objectives."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 76,
                                "start": 73
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 98,
                                "start": 94
                            }
                        ],
                        "text": "More narrowly construed by their application to machine learning, XLA [24], Glow [48] and TVM [49], address similar"
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 12,
                                "start": 8
                            }
                        ],
                        "text": "and TVM [49], earlier loop nest metaprogramming [26], [51],"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 52939079,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "df013a17ab84d5403361da4538a04d574f58be83",
            "isKey": true,
            "numCitedBy": 713,
            "numCiting": 51,
            "paperAbstract": {
                "fragments": [],
                "text": "There is an increasing need to bring machine learning to a wide diversity of hardware devices. Current frameworks rely on vendor-specific operator libraries and optimize for a narrow range of server-class GPUs. Deploying workloads to new platforms -- such as mobile phones, embedded devices, and accelerators (e.g., FPGAs, ASICs) -- requires significant manual effort. We propose TVM, a compiler that exposes graph-level and operator-level optimizations to provide performance portability to deep learning workloads across diverse hardware back-ends. TVM solves optimization challenges specific to deep learning, such as high-level operator fusion, mapping to arbitrary hardware primitives, and memory latency hiding. It also automates optimization of low-level programs to hardware characteristics by employing a novel, learning-based cost modeling method for rapid exploration of code optimizations. Experimental results show that TVM delivers performance across hardware back-ends that are competitive with state-of-the-art, hand-tuned libraries for low-power CPU, mobile GPU, and server-class GPUs. We also demonstrate TVM's ability to target new accelerator back-ends, such as the FPGA-based generic deep learning accelerator. The system is open sourced and in production use inside several major companies."
            },
            "slug": "TVM:-An-Automated-End-to-End-Optimizing-Compiler-Chen-Moreau",
            "title": {
                "fragments": [],
                "text": "TVM: An Automated End-to-End Optimizing Compiler for Deep Learning"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "TVM is a compiler that exposes graph-level and operator-level optimizations to provide performance portability to deep learning workloads across diverse hardware back-ends and automates optimization of low-level programs to hardware characteristics by employing a novel, learning-based cost modeling method for rapid exploration of code optimizations."
            },
            "venue": {
                "fragments": [],
                "text": "OSDI"
            },
            "year": 2018
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1913701"
                        ],
                        "name": "A. Veen",
                        "slug": "A.-Veen",
                        "structuredName": {
                            "firstName": "Arthur",
                            "lastName": "Veen",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Veen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 71,
                                "start": 67
                            }
                        ],
                        "text": "Their internal representations is often based on a data flow graph [22] with a dynamic execution semantics."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5467025,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a9c4ccad68bc37d52f12426e0dcedcb392bc22a7",
            "isKey": false,
            "numCitedBy": 275,
            "numCiting": 127,
            "paperAbstract": {
                "fragments": [],
                "text": "Dataflow machines are programmable computers of which the hardware is optimized for fine-grain data-driven parallel computation. The principles and complications of data-driven execution are explained, as well as the advantages and costs of fine-grain parallelism. A general model for a dataflow machine is presented and the major design options are discussed.\nMost dataflow machines described in the literature are surveyed on the basis of this model and its associated technology. For general-purpose computing the most promising dataflow machines are those that employ packet-switching communication and support general recursion. Such a recursion mechanism requires an extremely fast mechanism to map a sparsely occupied virtual space to a physical space of realistic size. No solution has yet proved fully satisfactory.\nA working prototype of one processing element is described in detail. On the basis of experience with this prototype, some of the objections raised against the dataflow approach are discussed. It appears that the overhead due to fine-grain parallelism can be made acceptable by sophisticated compiling and employing special hardware for the storage of data structures. Many computing-intensive programs show sufficient parallelism. In fact, a major problem is to restrain parallelism when machine resources tend to get overloaded. Another issue that requires further investigation is the distribution of computation and data structures over the processing elements."
            },
            "slug": "Dataflow-machine-architecture-Veen",
            "title": {
                "fragments": [],
                "text": "Dataflow machine architecture"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "It appears that the overhead due to fine-grain parallelism can be made acceptable by sophisticated compiling and employing special hardware for the storage of data structures, and some of the objections raised against the dataflow approach are discussed."
            },
            "venue": {
                "fragments": [],
                "text": "CSUR"
            },
            "year": 1986
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1971891"
                        ],
                        "name": "William A. Havanki",
                        "slug": "William-A.-Havanki",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Havanki",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "William A. Havanki"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2791272"
                        ],
                        "name": "S. Banerjia",
                        "slug": "S.-Banerjia",
                        "structuredName": {
                            "firstName": "Sanjeev",
                            "lastName": "Banerjia",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Banerjia"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1749195"
                        ],
                        "name": "T. Conte",
                        "slug": "T.-Conte",
                        "structuredName": {
                            "firstName": "Thomas",
                            "lastName": "Conte",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Conte"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 106,
                                "start": 103
                            }
                        ],
                        "text": ", loop trees), speeding up the compilation process or extracting instruction, or SIMD parallelism [4], [5], [6]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5465350,
            "fieldsOfStudy": [
                "Computer Science",
                "Business"
            ],
            "id": "c310f036722f9dd36d483b664283f05dd932dfa5",
            "isKey": false,
            "numCitedBy": 89,
            "numCiting": 39,
            "paperAbstract": {
                "fragments": [],
                "text": "Instruction scheduling is one of the most important phases of compilation for high-performance processors. A compiler typically divides a program into multiple regions of code and then schedules each region. Many past efforts have focused on linear regions such as traces and superblocks. The linearity of these regions can limit speculation, leading to under-utilization of processor resources, especially on wide-issue machines. A type of non-linear region called a treegion is presented in this paper. The formation and scheduling of treegions takes into account multiple execution paths, and the larger scope of treegions allows more speculation, leading to higher utilization and better performance. Multiple scheduling heuristics for treegions are compared against scheduling for several types of linear regions. Empirical results illustrate that instruction scheduling using treegions treegion scheduling-holds promise. Treegion scheduling using the global weight heuristic outperforms the next highest performing region-superblocks by up to 20%."
            },
            "slug": "Treegion-scheduling-for-wide-issue-processors-Havanki-Banerjia",
            "title": {
                "fragments": [],
                "text": "Treegion scheduling for wide issue processors"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "Empirical results illustrate that instruction scheduling using treegions treegion scheduling-holds promise, andTreegions scheduling using the global weight heuristic outperforms the next highest performing region-superblocks by up to 20%."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings 1998 Fourth International Symposium on High-Performance Computer Architecture"
            },
            "year": 1998
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772079"
                        ],
                        "name": "Sven Verdoolaege",
                        "slug": "Sven-Verdoolaege",
                        "structuredName": {
                            "firstName": "Sven",
                            "lastName": "Verdoolaege",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sven Verdoolaege"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3281978"
                        ],
                        "name": "J. Juega",
                        "slug": "J.-Juega",
                        "structuredName": {
                            "firstName": "Juan",
                            "lastName": "Juega",
                            "middleNames": [
                                "Carlos"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Juega"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144431297"
                        ],
                        "name": "J. I. G\u00f3mez",
                        "slug": "J.-I.-G\u00f3mez",
                        "structuredName": {
                            "firstName": "Jos\u00e9",
                            "lastName": "G\u00f3mez",
                            "middleNames": [
                                "Ignacio"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. I. G\u00f3mez"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1916522"
                        ],
                        "name": "C. Tenllado",
                        "slug": "C.-Tenllado",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Tenllado",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Tenllado"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145410654"
                        ],
                        "name": "F. Catthoor",
                        "slug": "F.-Catthoor",
                        "structuredName": {
                            "firstName": "Francky",
                            "lastName": "Catthoor",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Catthoor"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 200,
                                "start": 196
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 242,
                                "start": 238
                            }
                        ],
                        "text": "While a full exploration of the design points here is out of scope for this paper, we illustrate aspects of the affine dialect to show the modeling power of MLIR and contrast the affine dialect with past representations [25], [26], [27], [28], [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1212874,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "963a1e639971e7e3a4e6c871cf9c0b410e5532d0",
            "isKey": false,
            "numCitedBy": 323,
            "numCiting": 65,
            "paperAbstract": {
                "fragments": [],
                "text": "This article addresses the compilation of a sequential program for parallel execution on a modern GPU. To this end, we present a novel source-to-source compiler called PPCG. PPCG singles out for its ability to accelerate computations from any static control loop nest, generating multiple CUDA kernels when necessary. We introduce a multilevel tiling strategy and a code generation scheme for the parallelization and locality optimization of imperfectly nested loops, managing memory and exposing concurrency according to the constraints of modern GPUs. We evaluate our algorithms and tool on the entire PolyBench suite."
            },
            "slug": "Polyhedral-parallel-code-generation-for-CUDA-Verdoolaege-Juega",
            "title": {
                "fragments": [],
                "text": "Polyhedral parallel code generation for CUDA"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A novel source-to-source compiler called PPCG is presented, which introduces a multilevel tiling strategy and a code generation scheme for the parallelization and locality optimization of imperfectly nested loops, managing memory and exposing concurrency according to the constraints of modern GPUs."
            },
            "venue": {
                "fragments": [],
                "text": "TACO"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47368718"
                        ],
                        "name": "Ravi Teja Mullapudi",
                        "slug": "Ravi-Teja-Mullapudi",
                        "structuredName": {
                            "firstName": "Ravi",
                            "lastName": "Mullapudi",
                            "middleNames": [
                                "Teja"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ravi Teja Mullapudi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2032633"
                        ],
                        "name": "Vinay Vasista",
                        "slug": "Vinay-Vasista",
                        "structuredName": {
                            "firstName": "Vinay",
                            "lastName": "Vasista",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Vinay Vasista"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751936"
                        ],
                        "name": "Uday Bondhugula",
                        "slug": "Uday-Bondhugula",
                        "structuredName": {
                            "firstName": "Uday",
                            "lastName": "Bondhugula",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Uday Bondhugula"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 53,
                                "start": 49
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 177,
                                "start": 169
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                }
            ],
            "corpusId": 16016961,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0b9aaee517e0cabb274f5d7cfb01d8f58e51d76e",
            "isKey": false,
            "numCitedBy": 175,
            "numCiting": 53,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents the design and implementation of PolyMage, a domain-specific language and compiler for image processing pipelines. An image processing pipeline can be viewed as a graph of interconnected stages which process images successively. Each stage typically performs one of point-wise, stencil, reduction or data-dependent operations on image pixels. Individual stages in a pipeline typically exhibit abundant data parallelism that can be exploited with relative ease. However, the stages also require high memory bandwidth preventing effective utilization of parallelism available on modern architectures. For applications that demand high performance, the traditional options are to use optimized libraries like OpenCV or to optimize manually. While using libraries precludes optimization across library routines, manual optimization accounting for both parallelism and locality is very tedious. The focus of our system, PolyMage, is on automatically generating high-performance implementations of image processing pipelines expressed in a high-level declarative language. Our optimization approach primarily relies on the transformation and code generation capabilities of the polyhedral compiler framework. To the best of our knowledge, this is the first model-driven compiler for image processing pipelines that performs complex fusion, tiling, and storage optimization automatically. Experimental results on a modern multicore system show that the performance achieved by our automatic approach is up to 1.81x better than that achieved through manual tuning in Halide, a state-of-the-art language and compiler for image processing pipelines. For a camera raw image processing pipeline, our performance is comparable to that of a hand-tuned implementation."
            },
            "slug": "PolyMage:-Automatic-Optimization-for-Image-Mullapudi-Vasista",
            "title": {
                "fragments": [],
                "text": "PolyMage: Automatic Optimization for Image Processing Pipelines"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This is the first model-driven compiler for image processing pipelines that performs complex fusion, tiling, and storage optimization automatically and is up to 1.81x better than that achieved through manual tuning in Halide, a state-of-the-art language and compiler forimage processing pipelines."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 7971227,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d2f48fb9fd31390c56609f00510accf5c56f9f9b",
            "isKey": false,
            "numCitedBy": 518,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "Many advances in automatic parallelization and optimization have been achieved through the polyhedral model. It has been extensively shown that this computational model provides convenient abstractions to reason about and apply program transformations. Nevertheless, the complexity of code generation has long been a deterrent for using polyhedral representation in optimizing compilers. First, code generators have a hard time coping with generated code size and control overhead that may spoil theoretical benefits achieved by the transformations. Second, this step is usually time consuming, hampering the integration of the polyhedral framework in production compilers or feedback-directed, iterative optimization schemes. Moreover, current code generation algorithms only cover a restrictive set of possible transformation functions. This paper discusses a general transformation framework able to deal with nonunimodular, noninvertible, nonintegral or even nonuniform functions. It presents several improvements to a state-of-the-art code generation algorithm. Two directions are explored: generated code size and code generator efficiency. Experimental evidence proves the ability of the improved method to handle real-life problems."
            },
            "slug": "Code-generation-in-the-polyhedral-model-is-easier-Bastoul",
            "title": {
                "fragments": [],
                "text": "Code generation in the polyhedral model is easier than you think"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "A general transformation framework able to deal with nonunimodular, noninvertible, nonintegral or even nonuniform functions is discussed and several improvements to a state-of-the-art code generation algorithm are presented."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings. 13th International Conference on Parallel Architecture and Compilation Techniques, 2004. PACT 2004."
            },
            "year": 2004
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35324966"
                        ],
                        "name": "Patrick Thier",
                        "slug": "Patrick-Thier",
                        "structuredName": {
                            "firstName": "Patrick",
                            "lastName": "Thier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Patrick Thier"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145641218"
                        ],
                        "name": "M. Ertl",
                        "slug": "M.-Ertl",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Ertl",
                            "middleNames": [
                                "Anton"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Ertl"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1807101"
                        ],
                        "name": "A. Krall",
                        "slug": "A.-Krall",
                        "structuredName": {
                            "firstName": "Andreas",
                            "lastName": "Krall",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Krall"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 123,
                                "start": 119
                            }
                        ],
                        "text": "selection infrastructure, supporting extensible operations with multi-result patterns and specification as constraints [38]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 3352457,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "2fabaaefa974c4af3a59ee21f068420233a8c565",
            "isKey": false,
            "numCitedBy": 2,
            "numCiting": 27,
            "paperAbstract": {
                "fragments": [],
                "text": "Tree-parsing instruction selection as used in, e.g., lcc, uses dynamic costs to gain flexibility and handle situations (such as read-modify-write instructions) that do not fit into the basic tree-parsing model. The disadvantage of dynamic costs is that we can no longer turn the tree grammar into a tree automaton (as is done by burg) for fast instruction selection for JIT compilers. In this paper we introduce constraints that say whether a tree-grammar rule is applicable or not. While theoretically less powerful than dynamic costs, constraints cover the practical uses of dynamic costs; more importantly, they allow turning the tree grammar with constraints into a tree automaton (with instruction-selection-time checks), resulting in faster instruction selection than with pure instruction-selection-time dynamic programming. We integrate constraints in an instruction selector that matches DAGs with tree rules. We evaluate this concept in lcc and the CACAO JavaVM JIT compiler, and see instruction selector speedups by a factor 1.33--1.89."
            },
            "slug": "Fast-and-flexible-instruction-selection-with-Thier-Ertl",
            "title": {
                "fragments": [],
                "text": "Fast and flexible instruction selection with constraints"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "This paper introduces constraints that say whether a tree-grammar rule is applicable or not, and integrates constraints in an instruction selector that matches DAGs with tree rules, resulting in faster instruction selection than with pure instruction-selection-time dynamic programming."
            },
            "venue": {
                "fragments": [],
                "text": "CC"
            },
            "year": 2018
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1755724"
                        ],
                        "name": "Jean-Baptiste Tristan",
                        "slug": "Jean-Baptiste-Tristan",
                        "structuredName": {
                            "firstName": "Jean-Baptiste",
                            "lastName": "Tristan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jean-Baptiste Tristan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49392754"
                        ],
                        "name": "X. Leroy",
                        "slug": "X.-Leroy",
                        "structuredName": {
                            "firstName": "Xavier",
                            "lastName": "Leroy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "X. Leroy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 95,
                                "start": 91
                            }
                        ],
                        "text": "A long term goal would be to reproduce the successes of translation validation [11], [12], [13], [14] and modern approaches to compiler testing [15]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 787398,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e105ae690d66b8a6ecb51a82da302e03c821b789",
            "isKey": false,
            "numCitedBy": 97,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "Translation validation consists of transforming a program and a posteriori validating it in order to detect a modification of itssemantics. This approach can be used in a verified compiler, provided that validation is formally proved to be correct. We present two such validators and their Coq proofs of correctness. The validators are designed for two instruction scheduling optimizations: list scheduling and trace scheduling."
            },
            "slug": "Formal-verification-of-translation-validators:-a-on-Tristan-Leroy",
            "title": {
                "fragments": [],
                "text": "Formal verification of translation validators: a case study on instruction scheduling optimizations"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "Two validators are presented, designed for two instruction scheduling optimizations: list scheduling and trace scheduling, and their Coq proofs of correctness."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '08"
            },
            "year": 2008
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2144353532"
                        ],
                        "name": "Yang Chen",
                        "slug": "Yang-Chen",
                        "structuredName": {
                            "firstName": "Yang",
                            "lastName": "Chen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yang Chen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1753974"
                        ],
                        "name": "Alex Groce",
                        "slug": "Alex-Groce",
                        "structuredName": {
                            "firstName": "Alex",
                            "lastName": "Groce",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Alex Groce"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3288326"
                        ],
                        "name": "Chaoqiang Zhang",
                        "slug": "Chaoqiang-Zhang",
                        "structuredName": {
                            "firstName": "Chaoqiang",
                            "lastName": "Zhang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chaoqiang Zhang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "37535697"
                        ],
                        "name": "Weng-Keen Wong",
                        "slug": "Weng-Keen-Wong",
                        "structuredName": {
                            "firstName": "Weng-Keen",
                            "lastName": "Wong",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Weng-Keen Wong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1694273"
                        ],
                        "name": "Xiaoli Z. Fern",
                        "slug": "Xiaoli-Z.-Fern",
                        "structuredName": {
                            "firstName": "Xiaoli",
                            "lastName": "Fern",
                            "middleNames": [
                                "Z."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Xiaoli Z. Fern"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39080210"
                        ],
                        "name": "E. Eide",
                        "slug": "E.-Eide",
                        "structuredName": {
                            "firstName": "Eric",
                            "lastName": "Eide",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Eide"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1783210"
                        ],
                        "name": "J. Regehr",
                        "slug": "J.-Regehr",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Regehr",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Regehr"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 148,
                                "start": 144
                            }
                        ],
                        "text": "A long term goal would be to reproduce the successes of translation validation [11], [12], [13], [14] and modern approaches to compiler testing [15]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 54166086,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "66c0a8c12aa7de61d71dd2595099c8ac343d5797",
            "isKey": false,
            "numCitedBy": 93,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Aggressive random testing tools (\"fuzzers\") are impressively effective at finding compiler bugs. For example, a single test-case generator has resulted in more than 1,700 bugs reported for a single JavaScript engine. However, fuzzers can be frustrating to use: they indiscriminately and repeatedly find bugs that may not be severe enough to fix right away. Currently, users filter out undesirable test cases using ad hoc methods such as disallowing problematic features in tests and grepping test results. This paper formulates and addresses the fuzzer taming problem: given a potentially large number of random test cases that trigger failures, order them such that diverse, interesting test cases are highly ranked. Our evaluation shows our ability to solve the fuzzer taming problem for 3,799 test cases triggering 46 bugs in a C compiler and 2,603 test cases triggering 28 bugs in a JavaScript engine."
            },
            "slug": "Taming-compiler-fuzzers-Chen-Groce",
            "title": {
                "fragments": [],
                "text": "Taming compiler fuzzers"
            },
            "venue": {
                "fragments": [],
                "text": "PLDI"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35097712"
                        ],
                        "name": "V. Elango",
                        "slug": "V.-Elango",
                        "structuredName": {
                            "firstName": "Venmugil",
                            "lastName": "Elango",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Elango"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145288598"
                        ],
                        "name": "Norman Rubin",
                        "slug": "Norman-Rubin",
                        "structuredName": {
                            "firstName": "Norman",
                            "lastName": "Rubin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Norman Rubin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "49165315"
                        ],
                        "name": "Mahesh Ravishankar",
                        "slug": "Mahesh-Ravishankar",
                        "structuredName": {
                            "firstName": "Mahesh",
                            "lastName": "Ravishankar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mahesh Ravishankar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1984329"
                        ],
                        "name": "Hariharan Sandanagobalane",
                        "slug": "Hariharan-Sandanagobalane",
                        "structuredName": {
                            "firstName": "Hariharan",
                            "lastName": "Sandanagobalane",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Hariharan Sandanagobalane"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50654241"
                        ],
                        "name": "Vinod Grover",
                        "slug": "Vinod-Grover",
                        "structuredName": {
                            "firstName": "Vinod",
                            "lastName": "Grover",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Vinod Grover"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 107,
                                "start": 103
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 231,
                                "start": 225
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                }
            ],
            "corpusId": 47018174,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "8ad834debde06968c763bfe2fb9c83aa4d843e0e",
            "isKey": false,
            "numCitedBy": 37,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a domain specific language compiler, Diesel, for basic linear algebra and neural network computations, that accepts input expressions in an intuitive form and generates high performing code for GPUs. The current trend is to represent a neural network as a computation DAG, where each node in the DAG corresponds to a single operation such as matrix-matrix multiplication, and map the individual operations to hand tuned library functions provided by standard libraries such as CuBLAS and CuDNN. While this method takes advantage of readily available optimized library codes to achieve good performance for individual operations, it is not possible to optimize across operations. As opposed to this, given a computation composed of several operations, Diesel generates (a set) of efficient device functions, where the code is optimized for the computation as a whole, using polyhedral compilation techniques. In addition, there are cases where the code needs to be specialized for specific problem sizes to achieve optimal performance. While standard libraries are written for parametric problem sizes (where problem sizes are provided at runtime), Diesel can accept problem sizes at compile time and generate specialized codes. Experimental results show that the performance achieved by Diesel generated code for individual operations are comparable to the highly tuned versions provided by standard libraries, while for composite computations, Diesel outperforms manually written versions."
            },
            "slug": "Diesel:-DSL-for-linear-algebra-and-neural-net-on-Elango-Rubin",
            "title": {
                "fragments": [],
                "text": "Diesel: DSL for linear algebra and neural net computations on GPUs"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "Experimental results show that the performance achieved by Diesel generated code for individual operations are comparable to the highly tuned versions provided by standard libraries, while for composite computations, Diesel outperforms manually written versions."
            },
            "venue": {
                "fragments": [],
                "text": "MAPL@PLDI"
            },
            "year": 2018
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143983494"
                        ],
                        "name": "J. Meseguer",
                        "slug": "J.-Meseguer",
                        "structuredName": {
                            "firstName": "Jos\u00e9",
                            "lastName": "Meseguer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Meseguer"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 103,
                                "start": 99
                            }
                        ],
                        "text": "formalizing, and verifying the rewriting logic automatically would be an important next step [36], [37]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6362428,
            "fieldsOfStudy": [
                "Education"
            ],
            "id": "c8b9e5f6596ac7d5ba1675cc5ba49de3663d03ab",
            "isKey": false,
            "numCitedBy": 79,
            "numCiting": 591,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Twenty-years-of-rewriting-logic-Meseguer",
            "title": {
                "fragments": [],
                "text": "Twenty Years of Rewriting Logic"
            },
            "venue": {
                "fragments": [],
                "text": "WRLA"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2102288"
                        ],
                        "name": "Stephen Kou",
                        "slug": "Stephen-Kou",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Kou",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stephen Kou"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1728359"
                        ],
                        "name": "J. Palsberg",
                        "slug": "J.-Palsberg",
                        "structuredName": {
                            "firstName": "Jens",
                            "lastName": "Palsberg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Palsberg"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 293,
                                "start": 289
                            }
                        ],
                        "text": "[43], with a co-designed Domain Specific Language (DSL) and compilation flow converting managed object semantics into static, vector or reconfigurable hardware; yet most of the effort in its Lime compiler reside in fitting round objects into square hardware (paraphrasing Kou and Palsberg [44])."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 342,
                                "start": 326
                            }
                        ],
                        "text": "The most ambitious effort to date may be Liquid Metal [43], with a co-designed Domain Specific Language (DSL) and compilation flow converting managed object semantics into static, vector or reconfigurable hardware; yet most of the effort in its Lime compiler reside in fitting round objects into square hardware (paraphrasing Kou and Palsberg [44])."
                    },
                    "intents": []
                }
            ],
            "corpusId": 1619134,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5a1bb0b1a225cd4631ef15e79e35a10d760f7b97",
            "isKey": false,
            "numCitedBy": 5,
            "numCiting": 22,
            "paperAbstract": {
                "fragments": [],
                "text": "Consumer electronics today such as cell phones often have one or more low-power FPGAs to assist with energyintensive operations in order to reduce overall energy consumption and increase battery life. However, current techniques for programming FPGAs require people to be specially trained to do so. Ideally, software engineers can more readily take advantage of the benefits FPGAs offer by being able to program them using their existing skills, a common one being object-oriented programming. However, traditional techniques for compiling object-oriented languages are at odds with today's FPGA tools, which support neither pointers nor complex data structures. Open until now is the problem of compiling an object-oriented language to an FPGA in a way that harnesses this potential for huge energy savings. In this paper, we present a new compilation technique that feeds into an existing FPGA tool chain and produces FPGAs with up to almost an order of magnitude in energy savings compared to a low-power microprocessor while still retaining comparable performance and area usage."
            },
            "slug": "From-OO-to-FPGA:-fitting-round-objects-into-square-Kou-Palsberg",
            "title": {
                "fragments": [],
                "text": "From OO to FPGA: fitting round objects into square hardware?"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A new compilation technique is presented that feeds into an existing FPGA tool chain and produces FPGAs with up to almost an order of magnitude in energy savings compared to a low-power microprocessor while still retaining comparable performance and area usage."
            },
            "venue": {
                "fragments": [],
                "text": "OOPSLA"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2157207880"
                        ],
                        "name": "Richard Johnson",
                        "slug": "Richard-Johnson",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Johnson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Richard Johnson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2069623729"
                        ],
                        "name": "David Pearson",
                        "slug": "David-Pearson",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Pearson",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David Pearson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1776186"
                        ],
                        "name": "K. Pingali",
                        "slug": "K.-Pingali",
                        "structuredName": {
                            "firstName": "Keshav",
                            "lastName": "Pingali",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Pingali"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 101,
                                "start": 98
                            }
                        ],
                        "text": ", loop trees), speeding up the compilation process or extracting instruction, or SIMD parallelism [4], [5], [6]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5753565,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4ff2d290778d047a94cd621a3a259f542df2f696",
            "isKey": false,
            "numCitedBy": 228,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "In this paper, we describe the program structure tree (PST), a hierarchical representation of program structure based on single entry single exit (SESE) regions of the control flow graph. We give a linear-time algorithm for finding SESE regions and for building the PST of arbitrary control flow graphs (including irreducible ones). Next, we establish a connection between SESE regions and control dependence equivalence classes, and show how to use the algorithm to find control regions in linear time. Finally, we discuss some applications of the PST. Many control flow algorithms, such as construction of Static Single Assignment form, can be speeded up by applying the algorithms in a divide-and-conquer style to each SESE region on its own. The PST is also used to speed up data flow analysis by exploiting \u201csparsity\u201d. Experimental results from the Perfect Club and SPEC89 benchmarks confirm that the PST approach finds and exploits program structure."
            },
            "slug": "The-program-structure-tree:-computing-control-in-Johnson-Pearson",
            "title": {
                "fragments": [],
                "text": "The program structure tree: computing control regions in linear time"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "A linear-time algorithm for finding SESE regions and for building the PST of arbitrary control flow graphs (including irreducible ones) is given and it is shown how to use the algorithm to find control regions in linear time."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '94"
            },
            "year": 1994
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772079"
                        ],
                        "name": "Sven Verdoolaege",
                        "slug": "Sven-Verdoolaege",
                        "structuredName": {
                            "firstName": "Sven",
                            "lastName": "Verdoolaege",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sven Verdoolaege"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 188,
                                "start": 184
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 236,
                                "start": 232
                            }
                        ],
                        "text": "While a full exploration of the design points here is out of scope for this paper, we illustrate aspects of the affine dialect to show the modeling power of MLIR and contrast the affine dialect with past representations [25], [26], [27], [28], [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 9220965,
            "fieldsOfStudy": [
                "Art"
            ],
            "id": "1c5b15587e4034c97610b2017697ad1ea663a8fa",
            "isKey": false,
            "numCitedBy": 351,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "In compiler research, polytopes and related mathematical objects have been successfully used for several decades to represent and manipulate computer programs in an approach that has become known as the polyhedral model. The key insight is that the kernels of many compute-intensive applications are composed of loops with bounds that are affine combinations of symbolic constants and outer loop iterators. The iterations of a loop nest can then be represented as the integer points in a (parametric) polytope and manipulated as a whole, rather than as individual iterations. A similar reasoning holds for the elements of an array and for mappings between loop iterations and array elements."
            },
            "slug": "isl:-An-Integer-Set-Library-for-the-Polyhedral-Verdoolaege",
            "title": {
                "fragments": [],
                "text": "isl: An Integer Set Library for the Polyhedral Model"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "In compiler research, polytopes and related mathematical objects have been successfully used for several decades to represent and manipulate computer programs in an approach that has become known as the polyhedral model."
            },
            "venue": {
                "fragments": [],
                "text": "ICMS"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1838186"
                        ],
                        "name": "P. Feautrier",
                        "slug": "P.-Feautrier",
                        "structuredName": {
                            "firstName": "Paul",
                            "lastName": "Feautrier",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Feautrier"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 182,
                                "start": 178
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 224,
                                "start": 220
                            }
                        ],
                        "text": "While a full exploration of the design points here is out of scope for this paper, we illustrate aspects of the affine dialect to show the modeling power of MLIR and contrast the affine dialect with past representations [25], [26], [27], [28], [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 23417662,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "486986fb365f072146cb9648ab408b0c567ae019",
            "isKey": false,
            "numCitedBy": 384,
            "numCiting": 12,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper extends the algorithms which were developed in Part I to cases in which there is no affine schedule, i.e. to problems whose parallel complexity is polynomial but not linear. The natural generalization is to multidimensional schedules with lexicographic ordering as temporal succession. Multidimensional affine schedules, are, in a sense, equivalent to polynomial schedules, and are much easier to handle automatically. Furthermore, there is a strong connection between multidimensional schedules and loop nests, which allows one to prove that a static control program always has a multidimensional schedule. Roughly, a larger dimension indicates less parallelism. In the algorithm which is presented here, this dimension is computed dynamically, and is just sufficient for scheduling the source program. The algorithm lends itself to a \u201cdivide and conquer\u201d strategy. The paper gives some experimental evidence for the applicability, performances and limitations of the algorithm."
            },
            "slug": "Some-efficient-solutions-to-the-affine-scheduling-Feautrier",
            "title": {
                "fragments": [],
                "text": "Some efficient solutions to the affine scheduling problem. Part II. Multidimensional time"
            },
            "tldr": {
                "abstractSimilarityScore": 76,
                "text": "This paper extends the algorithms which were developed in Part I to cases in which there is no affine schedule, i.e. to problems whose parallel complexity is polynomial but not linear, and gives some experimental evidence for the applicability, performances and limitations of the algorithm."
            },
            "venue": {
                "fragments": [],
                "text": "International Journal of Parallel Programming"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3004504"
                        ],
                        "name": "C. Click",
                        "slug": "C.-Click",
                        "structuredName": {
                            "firstName": "Cliff",
                            "lastName": "Click",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Click"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2440159"
                        ],
                        "name": "M. Paleczny",
                        "slug": "M.-Paleczny",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Paleczny",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Paleczny"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 119,
                                "start": 115
                            }
                        ],
                        "text": "Finally, this explicit graph design and the extensibility of Ops is reminiscent of the sea-of-nodes representation [21]: this connection is intentional and has been a major influence for the selection of MLIR\u2019s flavor of SSA."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 12273131,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "42853a78548043f5bafba93d3c5ffd209c2647f9",
            "isKey": false,
            "numCitedBy": 46,
            "numCiting": 24,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a graph-based intermediate representation (IR) with simple semantics and a low-memory-cost C++ implementation. The IR uses a directed graph with labeled vertices and ordered inputs but unordered outputs. Vertices are labeled with opcodes, edges are unlabeled. We represent the CFG and basic blocks with the same vertex and edge structures. Each opcode is defined by a C++ class that encapsulates opcode-specific data and behavior. We use inheritance to abstract common opcode behavior, allowing new opcodes to be easily defined from old ones. The resulting IR is simple, fast and easy to use."
            },
            "slug": "A-simple-graph-based-intermediate-representation-Click-Paleczny",
            "title": {
                "fragments": [],
                "text": "A simple graph-based intermediate representation"
            },
            "tldr": {
                "abstractSimilarityScore": 67,
                "text": "A graph-based intermediate representation (IR) with simple semantics and a low-memory-cost C++ implementation that uses inheritance to abstract common opcode behavior, allowing new opcodes to be easily defined from old ones."
            },
            "venue": {
                "fragments": [],
                "text": "IR '95"
            },
            "year": 1995
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "153477622"
                        ],
                        "name": "G. Ramalingam",
                        "slug": "G.-Ramalingam",
                        "structuredName": {
                            "firstName": "Gunasundari",
                            "lastName": "Ramalingam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Ramalingam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 111,
                                "start": 108
                            }
                        ],
                        "text": ", loop trees), speeding up the compilation process or extracting instruction, or SIMD parallelism [4], [5], [6]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 528807,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "e57bbcc5edd30c6d323077a18bbecfea40bf3fe1",
            "isKey": false,
            "numCitedBy": 62,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": "This article explores the concept of loops and loop nesting forests of control-flow graphs, using the problem of constructing the dominator tree of a graph and the problem of computing the iterated dominance frontier of a set of vertices in a graph as guiding applications. The contributions of this article include: (1) An axiomatic characterization, as well as a constructive characterization, of a family of loop nesting forests that includes various specific loop nesting forests that have been previously defined. (2) The definition of a new loop nesting forest, as well as an efficient, almost linear-time, algorithm for constructing this forest. (3) An illustration of how loop nesting forests can be used to transform arbitrary (potentially irreducible) problem instances into equivalent acylic graph problem instances in the case of the two problems of (a) constructing the dominator tree of a graph, and (b) computing the iterated dominance frontier of a set of vertices in a graph, leading to new, almost linear-time, algorithms for these problems."
            },
            "slug": "On-loops,-dominators,-and-dominance-frontiers-Ramalingam",
            "title": {
                "fragments": [],
                "text": "On loops, dominators, and dominance frontiers"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "This article explores the concept of loops and loop nesting forests of control-flow graphs, using the problem of constructing the dominator tree of a graph and theproblem of computing the iterated dominance frontier of a set of vertices in a graph as guiding applications."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2111323476"
                        ],
                        "name": "E. K. Garcia",
                        "slug": "E.-K.-Garcia",
                        "structuredName": {
                            "firstName": "Eric",
                            "lastName": "Garcia",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. K. Garcia"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "9595724"
                        ],
                        "name": "M. Gupta",
                        "slug": "M.-Gupta",
                        "structuredName": {
                            "firstName": "Maya",
                            "lastName": "Gupta",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Gupta"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 52,
                                "start": 48
                            }
                        ],
                        "text": "Lattice Regression Compiler: Lattice regression [35] is a machine learning technique renowned for fast evaluation times and interpretability."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 12454922,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0689b94e049c58b6e668d61f20901851bcb3b68f",
            "isKey": false,
            "numCitedBy": 24,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a new empirical risk minimization framework for approximating functions from training samples for low-dimensional regression applications where a lattice (look-up table) is stored and interpolated at run-time for an efficient implementation. Rather than evaluating a fitted function at the lattice nodes without regard to the fact that samples will be interpolated, the proposed lattice regression approach estimates the lattice to minimize the interpolation error on the given training samples. Experiments show that lattice regression can reduce mean test error by as much as 25% compared to Gaussian process regression (GPR) for digital color management of printers, an application for which linearly interpolating a look-up table is standard. Simulations confirm that lattice regression performs consistently better than the naive approach to learning the lattice. Surprisingly, in some cases the proposed method \u2014 although motivated by computational efficiency \u2014 performs better than directly applying GPR with no lattice at all."
            },
            "slug": "Lattice-Regression-Garcia-Gupta",
            "title": {
                "fragments": [],
                "text": "Lattice Regression"
            },
            "tldr": {
                "abstractSimilarityScore": 45,
                "text": "Experiments show that lattice regression can reduce mean test error by as much as 25% compared to Gaussian process regression for digital color management of printers, an application for which linearly interpolating a look-up table is standard."
            },
            "venue": {
                "fragments": [],
                "text": "NIPS"
            },
            "year": 2009
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1401885963"
                        ],
                        "name": "Jonathan Ragan-Kelley",
                        "slug": "Jonathan-Ragan-Kelley",
                        "structuredName": {
                            "firstName": "Jonathan",
                            "lastName": "Ragan-Kelley",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jonathan Ragan-Kelley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144187067"
                        ],
                        "name": "Andrew Adams",
                        "slug": "Andrew-Adams",
                        "structuredName": {
                            "firstName": "Andrew",
                            "lastName": "Adams",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Andrew Adams"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2665634"
                        ],
                        "name": "Dillon Sharlet",
                        "slug": "Dillon-Sharlet",
                        "structuredName": {
                            "firstName": "Dillon",
                            "lastName": "Sharlet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dillon Sharlet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2496412"
                        ],
                        "name": "Connelly Barnes",
                        "slug": "Connelly-Barnes",
                        "structuredName": {
                            "firstName": "Connelly",
                            "lastName": "Barnes",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Connelly Barnes"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145799132"
                        ],
                        "name": "Sylvain Paris",
                        "slug": "Sylvain-Paris",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Paris",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Paris"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1801789"
                        ],
                        "name": "M. Levoy",
                        "slug": "M.-Levoy",
                        "structuredName": {
                            "firstName": "Marc",
                            "lastName": "Levoy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Levoy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145403226"
                        ],
                        "name": "F. Durand",
                        "slug": "F.-Durand",
                        "structuredName": {
                            "firstName": "Fr\u00e9do",
                            "lastName": "Durand",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Durand"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 23647423,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "255f645102919a7c3e451cac9b8f0f07c0a882c1",
            "isKey": false,
            "numCitedBy": 62,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "Writing high-performance code on modern machines requires not just locally optimizing inner loops, but globally reorganizing computations to exploit parallelism and locality---doing things such as tiling and blocking whole pipelines to fit in cache. This is especially true for image processing pipelines, where individual stages do much too little work to amortize the cost of loading and storing results to and from off-chip memory. As a result, the performance difference between a naive implementation of a pipeline and one globally optimized for parallelism and locality is often an order of magnitude. However, using existing programming tools, writing high-performance image processing code requires sacrificing simplicity, portability, and modularity. We argue that this is because traditional programming models conflate the computations defining the algorithm with decisions about intermediate storage and the order of computation, which we call the schedule. We propose a new programming language for image processing pipelines, called Halide, that separates the algorithm from its schedule. Programmers can change the schedule to express many possible organizations of a single algorithm. The Halide compiler then synthesizes a globally combined loop nest for an entire algorithm, given a schedule. Halide models a space of schedules which is expressive enough to describe organizations that match or outperform state-of-the-art hand-written implementations of many computational photography and computer vision algorithms. Its model is simple enough to do so often in only a few lines of code, and small changes generate efficient implementations for x86, ARM, Graphics Processors (GPUs), and specialized image processors, all from a single algorithm. Halide has been public and open source for over four years, during which it has been used by hundreds of programmers to deploy code to tens of thousands of servers and hundreds of millions of phones, processing billions of images every day."
            },
            "slug": "Halide:-decoupling-algorithms-from-schedules-for-Ragan-Kelley-Adams",
            "title": {
                "fragments": [],
                "text": "Halide: decoupling algorithms from schedules for high-performance image processing"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "A new programming language for image processing pipelines, called Halide, that separates the algorithm from its schedule, and is expressive enough to describe organizations that match or outperform state-of-the-art hand-written implementations of many computational photography and computer vision algorithms."
            },
            "venue": {
                "fragments": [],
                "text": "Commun. ACM"
            },
            "year": 2018
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706327"
                        ],
                        "name": "Arvind K. Sujeeth",
                        "slug": "Arvind-K.-Sujeeth",
                        "structuredName": {
                            "firstName": "Arvind",
                            "lastName": "Sujeeth",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Arvind K. Sujeeth"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144806284"
                        ],
                        "name": "Kevin J. Brown",
                        "slug": "Kevin-J.-Brown",
                        "structuredName": {
                            "firstName": "Kevin",
                            "lastName": "Brown",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kevin J. Brown"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34946720"
                        ],
                        "name": "HyoukJoong Lee",
                        "slug": "HyoukJoong-Lee",
                        "structuredName": {
                            "firstName": "HyoukJoong",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "HyoukJoong Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1712987"
                        ],
                        "name": "Tiark Rompf",
                        "slug": "Tiark-Rompf",
                        "structuredName": {
                            "firstName": "Tiark",
                            "lastName": "Rompf",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tiark Rompf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1694512"
                        ],
                        "name": "H. Chafi",
                        "slug": "H.-Chafi",
                        "structuredName": {
                            "firstName": "Hassan",
                            "lastName": "Chafi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Chafi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1795826"
                        ],
                        "name": "Martin Odersky",
                        "slug": "Martin-Odersky",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Odersky",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Martin Odersky"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746638"
                        ],
                        "name": "K. Olukotun",
                        "slug": "K.-Olukotun",
                        "structuredName": {
                            "firstName": "Kunle",
                            "lastName": "Olukotun",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Olukotun"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 11,
                                "start": 7
                            }
                        ],
                        "text": "Delite [46] promises dramatic productivity improvements for DSL developers, while supporting parallel and heterogeneous"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8944267,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "25635a854dc2055a0339235bba7b863c7c6df31a",
            "isKey": false,
            "numCitedBy": 169,
            "numCiting": 49,
            "paperAbstract": {
                "fragments": [],
                "text": "Developing high-performance software is a difficult task that requires the use of low-level, architecture-specific programming models (e.g., OpenMP for CMPs, CUDA for GPUs, MPI for clusters). It is typically not possible to write a single application that can run efficiently in different environments, leading to multiple versions and increased complexity. Domain-Specific Languages (DSLs) are a promising avenue to enable programmers to use high-level abstractions and still achieve good performance on a variety of hardware. This is possible because DSLs have higher-level semantics and restrictions than general-purpose languages, so DSL compilers can perform higher-level optimization and translation. However, the cost of developing performance-oriented DSLs is a substantial roadblock to their development and adoption. In this article, we present an overview of the Delite compiler framework and the DSLs that have been developed with it. Delite simplifies the process of DSL development by providing common components, like parallel patterns, optimizations, and code generators, that can be reused in DSL implementations. Delite DSLs are embedded in Scala, a general-purpose programming language, but use metaprogramming to construct an Intermediate Representation (IR) of user programs and compile to multiple languages (including Cpp, CUDA, and OpenCL). DSL programs are automatically parallelized and different parts of the application can run simultaneously on CPUs and GPUs. We present Delite DSLs for machine learning, data querying, graph analysis, and scientific computing and show that they all achieve performance competitive to or exceeding Cpp code."
            },
            "slug": "Delite:-A-Compiler-Architecture-for-Embedded-Sujeeth-Brown",
            "title": {
                "fragments": [],
                "text": "Delite: A Compiler Architecture for Performance-Oriented Embedded Domain-Specific Languages"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "An overview of the Delite compiler framework and DSLs that have been developed with it is presented and it is shown that they all achieve performance competitive to or exceeding Cpp code."
            },
            "venue": {
                "fragments": [],
                "text": "ACM Trans. Embed. Comput. Syst."
            },
            "year": 2014
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 35,
                                "start": 32
                            }
                        ],
                        "text": "the Open64 WHIRL representation [9] has five levels, as does the Clang compiler which lowers from ASTs to LLVM IR, to SelectionDAG, to MachineInstr, and to MCInst."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Open64 compiler and tools"
            },
            "venue": {
                "fragments": [],
                "text": "2001."
            },
            "year": 2001
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "SyCL: C++ single-source heterogeneous programming for OpenCL"
            },
            "venue": {
                "fragments": [],
                "text": ""
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 59,
                                "start": 52
                            }
                        ],
                        "text": "Similarly, targeting a heterogeneous platform using OpenACC becomes tractable within MLIR through the sharing and reuse of the GPU-oriented dialects and passes."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 187,
                                "start": 183
                            }
                        ],
                        "text": "Originally a homogeneous programming model, OpenMP added support for offloading tasks and parallel regions to accelerators [39], based on earlier proposals such as StarSs and OpenACC [40], [41]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Hierarchical taskbased programming with starss"
            },
            "venue": {
                "fragments": [],
                "text": "IJHPCA, vol. 23, no. 3, pp. 284\u2013299, 2009. [Online]. Available: https://doi.org/10.1177/1094342009106195"
            },
            "year": 2009
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 127,
                                "start": 123
                            }
                        ],
                        "text": "Originally a homogeneous programming model, OpenMP added support for offloading tasks and parallel regions to accelerators [39], based on earlier proposals such as StarSs and OpenACC [40], [41]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The OpenMP API specification for parallel programming"
            },
            "venue": {
                "fragments": [],
                "text": "Online, https://www.openmp.org, accessed Feb 19, 2020."
            },
            "year": 2020
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "OpenACC application programming interface"
            },
            "venue": {
                "fragments": [],
                "text": ""
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "TableGen -LLVM 10 Documentation"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2019
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 15,
                                "start": 11
                            }
                        ],
                        "text": "TensorFlow [23] is an example of such framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "TensorFlow: Large-scale machine learning on heterogeneous systems"
            },
            "venue": {
                "fragments": [],
                "text": "2015, software available from tensorflow.org. [Online]. Available: https://www.tensorflow.org/"
            },
            "year": 2015
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 81,
                                "start": 77
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 205,
                                "start": 184
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 248,
                                "start": 244
                            }
                        ],
                        "text": "While a full exploration of the design points here is out of scope for this paper, we illustrate aspects of the affine dialect to show the modeling power of MLIR and contrast the affine dialect with past representations [25], [26], [27], [28], [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The next 700 accelerated layers: From mathematical expressions of network computation graphs to accelerated GPU kernels, automatically"
            },
            "venue": {
                "fragments": [],
                "text": "ACM Trans. Archit. Code Optim., vol. 16, no. 4, pp. 38:1\u201338:26, Oct. 2019. [Online]. Available: http://doi.acm.org/10.1145/3355606"
            },
            "year": 2019
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 122,
                                "start": 118
                            }
                        ],
                        "text": "[52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 246,
                                "start": 238
                            }
                        ],
                        "text": "Similarly, the loop nest metaprogramming techniques from Halide [50]\nand TVM [49], earlier loop nest metaprogramming [26], [51], [52], [53], and automatic flows such as PolyMage [54], Tensor Comprehensions [29], Stripe [55], Diesel [56], Tiramisu [57] and their underlying polyhedral compilation techniques [25], [27], [58], [28] could co-exist as different code generation paths within an MLIR-based framework."
                    },
                    "intents": []
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "ONNX: Open neural network exchange"
            },
            "venue": {
                "fragments": [],
                "text": "Online, https://github.com/onnx/onnx, accessed Feb 19, 2020. [Online]. Available: https://github.com/onnx/onnx 14"
            },
            "year": 2020
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 219,
                                "start": 215
                            }
                        ],
                        "text": "Similar to Swift, Rust, and others, flang needs a specialized IR in order to support advanced transformations for high-performance Fortran codebase, and is using MLIR to support these Fortran-specific optimizations [34]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "An MLIR dialect for high-level optimization of fortran"
            },
            "venue": {
                "fragments": [],
                "text": "LLVM Developer Meeting, Oct 2019."
            },
            "year": 2019
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 37,
            "methodology": 13
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 57,
        "totalPages": 6
    },
    "page_url": "https://www.semanticscholar.org/paper/MLIR:-Scaling-Compiler-Infrastructure-for-Domain-Lattner-Amini/bc4f195d2f0937dab16bf50a24bf385c10781dd7?sort=total-citations"
}