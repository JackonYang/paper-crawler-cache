{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145738070"
                        ],
                        "name": "Matthew B. Dwyer",
                        "slug": "Matthew-B.-Dwyer",
                        "structuredName": {
                            "firstName": "Matthew",
                            "lastName": "Dwyer",
                            "middleNames": [
                                "B."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Matthew B. Dwyer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1728954"
                        ],
                        "name": "G. Avrunin",
                        "slug": "G.-Avrunin",
                        "structuredName": {
                            "firstName": "George",
                            "lastName": "Avrunin",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Avrunin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143962122"
                        ],
                        "name": "J. Corbett",
                        "slug": "J.-Corbett",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Corbett",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Corbett"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 113,
                                "start": 110
                            }
                        ],
                        "text": "Many other quantitative modelling languages not yet represented in the QVBS exist such as Uppaal\u2019s XML format [7] for timed automata or those supported by M\u00f6bius [19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 121,
                                "start": 110
                            }
                        ],
                        "text": "Runtime verification (RV) is a class of lightweight scalable techniques for the analysis of system executions [5,7,17,18]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 74,
                                "start": 71
                            }
                        ],
                        "text": "SMART uses MEDDLY: Multivalued and Edgevalued Decision Diagram LibrarY [7], an open-source MDD library(8), as its symbolic model checking engine."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 93
                            }
                        ],
                        "text": "The implementation of the MDD data structure is based on the highly-optimized Meddly library [7]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 186,
                                "start": 183
                            }
                        ],
                        "text": "for confluence,(8) standardization, normalization, and relative termination, commutation is the basis of many results in computer science, like correctness of program transformations [7], and bisimulation up-to [8]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 12369575,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "413baeab46e0056849585cac687a86bf9fe00b54",
            "isKey": true,
            "numCitedBy": 1509,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "Model checkers and other finite-state verification tools allow developers to detect certain kinds of errors automatically. Nevertheless, the transition of this technology from research to practice has been slow. While there are a number of potential causes for reluctance to adopt such formal methods, we believe that a primary cause is that practitioners are unfamiliar with specification processes, notations, and strategies. In a recent paper, we proposed a pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification. Since then, we have carried out a survey of available specifications, collecting over 500 examples of property specifications. We found that most are instances of our proposed patterns. Furthermore, we have updated our pattern system to accommodate new patterns and variations of existing patterns encountered in this survey. This paper reports the results of the survey and the current status of our pattern system."
            },
            "slug": "Patterns-in-property-specifications-for-Dwyer-Avrunin",
            "title": {
                "fragments": [],
                "text": "Patterns in property specifications for finite-state verification"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A survey of available specifications found that most are instances of the proposed pattern-based approach to the presentation, codification and reuse of property specifications for finite-state verification."
            },
            "venue": {
                "fragments": [],
                "text": "Proceedings of the 1999 International Conference on Software Engineering (IEEE Cat. No.99CB37002)"
            },
            "year": 1999
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145075731"
                        ],
                        "name": "T. Murata",
                        "slug": "T.-Murata",
                        "structuredName": {
                            "firstName": "Tadao",
                            "lastName": "Murata",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Murata"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 62750145,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "da23de6462bd8c3072a7238df280e6f9d2883c58",
            "isKey": false,
            "numCitedBy": 11058,
            "numCiting": 203,
            "paperAbstract": {
                "fragments": [],
                "text": "Starts with a brief review of the history and the application areas considered in the literature. The author then proceeds with introductory modeling examples, behavioral and structural properties, three methods of analysis, subclasses of Petri nets and their analysis. In particular, one section is devoted to marked graphs, the concurrent system model most amenable to analysis. Introductory discussions on stochastic nets with their application to performance modeling, and on high-level nets with their application to logic programming, are provided. Also included are recent results on reachability criteria. Suggestions are provided for further reading on many subject areas of Petri nets. >"
            },
            "slug": "Petri-nets:-Properties,-analysis-and-applications-Murata",
            "title": {
                "fragments": [],
                "text": "Petri nets: Properties, analysis and applications"
            },
            "tldr": {
                "abstractSimilarityScore": 62,
                "text": "The author proceeds with introductory modeling examples, behavioral and structural properties, three methods of analysis, subclasses of Petri nets and their analysis, and one section is devoted to marked graphs, the concurrent system model most amenable to analysis."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143877541"
                        ],
                        "name": "E. Clarke",
                        "slug": "E.-Clarke",
                        "structuredName": {
                            "firstName": "Edmund",
                            "lastName": "Clarke",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Clarke"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145459273"
                        ],
                        "name": "E. Emerson",
                        "slug": "E.-Emerson",
                        "structuredName": {
                            "firstName": "E.",
                            "lastName": "Emerson",
                            "middleNames": [
                                "Allen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Emerson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 87
                            }
                        ],
                        "text": "The detailed results are available from the competition website and associated reports [4,6, 19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 53,
                                "start": 50
                            }
                        ],
                        "text": "GreatSPN implements a large library of heuristics [6] to generate candidate variable orders, with about 30 base algorithms, plus several transformation heuristics (generate a new order given a starting one)."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 86,
                                "start": 77
                            }
                        ],
                        "text": "Here, certain algorithms can ensure error bounds (such as interval iteration [6,12,33] and sound value iteration [66] for probabilistic reachability, and uniformisation for time-bounded reachability in CTMC)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 234,
                                "start": 231
                            }
                        ],
                        "text": "In an oriented CTRS the conditions in the rules are interpreted as reachability and type 3 is a syntactic restriction on the distribution of variables in rewrite rules which ensure that rewriting does not introduce fresh variables [6]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 178,
                                "start": 164
                            }
                        ],
                        "text": "The Competition on Runtime Verification (CRV) was established as a yearly event in 2014 and has been organized as a satellite event of the RV conference since then [4,6,19,32,33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 33781339,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "93655f83b2d4443fdfad7b8b3d8bd9eab3c5e023",
            "isKey": true,
            "numCitedBy": 1754,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": "We have shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification. We believe that this approach may in the long run turn out to be quite practical. Since synchronization skeletons are, in general, quite small, the potentially exponential behavior of our algorithm need not be an insurmountable obstacle. Much additional research will be needed, however, to make the approach feasible in practice."
            },
            "slug": "Design-and-Synthesis-of-Synchronization-Skeletons-Clarke-Emerson",
            "title": {
                "fragments": [],
                "text": "Design and Synthesis of Synchronization Skeletons Using Branching-Time Temporal Logic"
            },
            "tldr": {
                "abstractSimilarityScore": 94,
                "text": "It is shown that it is possible to automatically synthesize the synchronization skeleton of a concurrent program from a Temporal Logic specification and it is believed that this approach may in the long run turn out to be quite practical."
            },
            "venue": {
                "fragments": [],
                "text": "Logic of Programs"
            },
            "year": 1981
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "38570199"
                        ],
                        "name": "Nicholas G. Hall",
                        "slug": "Nicholas-G.-Hall",
                        "structuredName": {
                            "firstName": "Nicholas",
                            "lastName": "Hall",
                            "middleNames": [
                                "G."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicholas G. Hall"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2876272"
                        ],
                        "name": "C. Sriskandarajah",
                        "slug": "C.-Sriskandarajah",
                        "structuredName": {
                            "firstName": "Chelliah",
                            "lastName": "Sriskandarajah",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Sriskandarajah"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 43044718,
            "fieldsOfStudy": [
                "Business"
            ],
            "id": "0da475efbfaee5774377452c648f8b393a0e68fe",
            "isKey": false,
            "numCitedBy": 831,
            "numCiting": 93,
            "paperAbstract": {
                "fragments": [],
                "text": "An important class of machine scheduling problems is characterized by a no-wait or blocking production environment, where there is no intermediate buffer between machines. In a no-wait environment, a job must be processed from start to completion, without any interruption either on or between machines. Blocking occurs when a job, having completed processing on a machine, remains on the machine until a downstream machine becomes available for processing. A no-wait or blocking production environment typically arises from characteristics of the processing technology itself, or from the absence of storage capacity between operations of a job. In this review paper, we describe several well-documented applications of no-wait and blocking scheduling models and illustrate some ways in which the increasing use of modern manufacturing methods gives rise to other applications. We review the computational complexity of a wide variety of no-wait and blocking scheduling problems and describe several problems which remain open as to complexity. We study several deterministic flowshop, jobshop, and openshop problems and describe efficient and enumerative algorithms, as well as heuristics and results about their performance. The literature on stochastic no-wait and blocking scheduling problems is also reviewed. Finally, we provide some suggestions for future research directions."
            },
            "slug": "A-Survey-of-Machine-Scheduling-Problems-with-and-in-Hall-Sriskandarajah",
            "title": {
                "fragments": [],
                "text": "A Survey of Machine Scheduling Problems with Blocking and No-Wait in Process"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "Several well-documented applications of no-wait and blocking scheduling models are described and some ways in which the increasing use of modern manufacturing methods gives rise to other applications are illustrated."
            },
            "venue": {
                "fragments": [],
                "text": "Oper. Res."
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145898058"
                        ],
                        "name": "Wil M.P. van der Aalst",
                        "slug": "Wil-M.P.-van-der-Aalst",
                        "structuredName": {
                            "firstName": "Wil",
                            "lastName": "van der Aalst",
                            "middleNames": [
                                "M.P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Wil M.P. van der Aalst"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 15970109,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "568f0edee6fc159ba171e0d2f632fd001ec2f7d8",
            "isKey": false,
            "numCitedBy": 919,
            "numCiting": 32,
            "paperAbstract": {
                "fragments": [],
                "text": "Workflow management systems will change the architecture of future information systems dramatically. The explicit representation of business procedures is one of the main issues when introducing a workflow management system. In this paper we focus on a class of Petri nets suitable for the representation, validation and verification of these procedures. We will show that the correctness of a procedure represented by such a Petri net can be verified by using standard Petri-net-based techniques. Based on this result we provide a comprehensive set of transformation rules which can be used to construct and modify correct procedures."
            },
            "slug": "Verification-of-Workflow-Nets-Aalst",
            "title": {
                "fragments": [],
                "text": "Verification of Workflow Nets"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This paper focuses on a class of Petri nets suitable for the representation, validation and verification of business procedures and shows that the correctness of a procedure represented by such a Petri net can be verified by using standard Petri-net-based techniques."
            },
            "venue": {
                "fragments": [],
                "text": "ICATPN"
            },
            "year": 1997
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1742391"
                        ],
                        "name": "J. Ullman",
                        "slug": "J.-Ullman",
                        "structuredName": {
                            "firstName": "Jeffrey",
                            "lastName": "Ullman",
                            "middleNames": [
                                "D."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ullman"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                }
            ],
            "citationContexts": [],
            "corpusId": 40001207,
            "fieldsOfStudy": [
                "Business"
            ],
            "id": "c47372d235312f9f1d99b7c6f03b4fac0234bf3e",
            "isKey": false,
            "numCitedBy": 1300,
            "numCiting": 9,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "NP-Complete-Scheduling-Problems-Ullman",
            "title": {
                "fragments": [],
                "text": "NP-Complete Scheduling Problems"
            },
            "venue": {
                "fragments": [],
                "text": "J. Comput. Syst. Sci."
            },
            "year": 1975
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145567053"
                        ],
                        "name": "J. L. Peterson",
                        "slug": "J.-L.-Peterson",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Peterson",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. L. Peterson"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 41,
                                "start": 37
                            }
                        ],
                        "text": "See the competition report from 2015 [19] for details."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 87
                            }
                        ],
                        "text": "The detailed results are available from the competition website and associated reports [4,6, 19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 135,
                                "start": 128
                            }
                        ],
                        "text": ") If no substitutions exists, there is no edge, which may ease the task of proving termination of the underlying rewrite system [18,19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 166,
                                "start": 162
                            }
                        ],
                        "text": "Many other quantitative modelling languages not yet represented in the QVBS exist such as Uppaal\u2019s XML format [7] for timed automata or those supported by M\u00f6bius [19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 51
                            }
                        ],
                        "text": "Using the benchmarks of the MCC, we demonstrate in [19] speedups of around 3\u00d7 with 4 workers, which is the configuration used in the MCC."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 108,
                                "start": 104
                            }
                        ],
                        "text": "LTSmin is now equipped with a fully multi-core on-the-fly symbolic saturation algorithm as described in [19]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 178,
                                "start": 164
                            }
                        ],
                        "text": "The Competition on Runtime Verification (CRV) was established as a yearly event in 2014 and has been organized as a satellite event of the RV conference since then [4,6,19,32,33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 62161861,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "f44b5c119d233d1cbea60596f450b966abf12db8",
            "isKey": true,
            "numCitedBy": 2857,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Petri-net-theory-and-the-modeling-of-systems-Peterson",
            "title": {
                "fragments": [],
                "text": "Petri net theory and the modeling of systems"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1981
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1679646"
                        ],
                        "name": "K. Larsen",
                        "slug": "K.-Larsen",
                        "structuredName": {
                            "firstName": "Kim",
                            "lastName": "Larsen",
                            "middleNames": [
                                "Guldstrand"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Larsen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 128,
                                "start": 124
                            }
                        ],
                        "text": "The competition was established and first executed in 2011 and the first results were presented and published at TACAS 2012 [17]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 121,
                                "start": 110
                            }
                        ],
                        "text": "Runtime verification (RV) is a class of lightweight scalable techniques for the analysis of system executions [5,7,17,18]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 164,
                                "start": 160
                            }
                        ],
                        "text": "Furthermore the tool employs a state-of-the-art dependency-graph technique for verification of CTL properties, utilizing the socalled certain zero optimization [17]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 112,
                                "start": 108
                            }
                        ],
                        "text": "Another source of infeasibility problems is the dependency graph in termination analysis of rewrite systems [17]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 61,
                                "start": 57
                            }
                        ],
                        "text": "Examples are CSL [5] for CTMC, PTCTL [59] for PTA, rPATL [17] for stochastic games, and STL [61] for hybrid systems."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 9309912,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9fdd4a25cedbfe63d738113088ff40027511f8e7",
            "isKey": true,
            "numCitedBy": 256,
            "numCiting": 13,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Modal-Specifications-Larsen",
            "title": {
                "fragments": [],
                "text": "Modal Specifications"
            },
            "venue": {
                "fragments": [],
                "text": "Automatic Verification Methods for Finite State Systems"
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1708353"
                        ],
                        "name": "F. Kr\u00f6ger",
                        "slug": "F.-Kr\u00f6ger",
                        "structuredName": {
                            "firstName": "Fred",
                            "lastName": "Kr\u00f6ger",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Kr\u00f6ger"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 88,
                                "start": 84
                            }
                        ],
                        "text": "The correct answer of this problem is YES since the addition of the redundant rules [20] f(x) -> f(f(f(x))) and f(x) -> x makes the critical pairs of the SRS development closed [11]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 155,
                                "start": 151
                            }
                        ],
                        "text": "For LTL, ITS-tools rely on Spot [21] to translate the properties to B\u00fcchi variants, then use the LTSmin engine (with POR) or our SLAP hybrid algorithm [20] to perform the emptiness check."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 152,
                                "start": 148
                            }
                        ],
                        "text": "On nondeterministic models, modes provides lower (upper) bounds for maximum (minimum) reachability probabilities via lightweight scheduler sampling [20]."
                    },
                    "intents": []
                }
            ],
            "corpusId": 20483647,
            "fieldsOfStudy": [
                "Philosophy"
            ],
            "id": "53e5d573f977bd59416b0bf870bfd4d917c9b79a",
            "isKey": false,
            "numCitedBy": 4106,
            "numCiting": 3,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Temporal-Logic-of-Programs-Kr\u00f6ger",
            "title": {
                "fragments": [],
                "text": "Temporal Logic of Programs"
            },
            "venue": {
                "fragments": [],
                "text": "EATCS Monographs on Theoretical Computer Science"
            },
            "year": 1987
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 5,
            "methodology": 5
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 9,
        "totalPages": 1
    },
    "page_url": "https://www.semanticscholar.org/paper/Tools-and-Algorithms-for-the-Construction-and-of-Steffen/f9d03ef15547375713c8b57524435656296a3ef5?sort=total-citations"
}