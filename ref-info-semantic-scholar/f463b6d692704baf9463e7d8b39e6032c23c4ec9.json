{
    "links": [
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33910386"
                        ],
                        "name": "M. Chakravarty",
                        "slug": "M.-Chakravarty",
                        "structuredName": {
                            "firstName": "Manuel",
                            "lastName": "Chakravarty",
                            "middleNames": [
                                "M.",
                                "T."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Chakravarty"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144289189"
                        ],
                        "name": "G. Keller",
                        "slug": "G.-Keller",
                        "structuredName": {
                            "firstName": "Gabriele",
                            "lastName": "Keller",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Keller"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2108109511"
                        ],
                        "name": "Sean Lee",
                        "slug": "Sean-Lee",
                        "structuredName": {
                            "firstName": "Sean",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sean Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2508058"
                        ],
                        "name": "T. L. McDonell",
                        "slug": "T.-L.-McDonell",
                        "structuredName": {
                            "firstName": "Trevor",
                            "lastName": "McDonell",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. L. McDonell"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50654241"
                        ],
                        "name": "Vinod Grover",
                        "slug": "Vinod-Grover",
                        "structuredName": {
                            "firstName": "Vinod",
                            "lastName": "Grover",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Vinod Grover"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 110
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0.6\u00d7 (slower) on FinPar\u2019s LocVolCalib benchmark to 16\u00d7 (faster) on Rodinia\u2019s NN benchmark."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 7
                            }
                        ],
                        "text": "We use Accelerate version 0.15.1, with the CUDA backend."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 79
                            }
                        ],
                        "text": "Several of the benchmarks discussed in Section 6, such as FinPar\u2019s LocVolCalib, Accelerate\u2019s Nbody, and Rodinia\u2019s CFD, K-means, Myocyte, and LavaMD, exhibit kernels in which one or several innermost dimensions of the mapped arrays are processed sequentially inside the kernel."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 73,
                                "start": 63
                            }
                        ],
                        "text": "Rodinia benchmarks have been modified to time similarly, while Accelerate and FinPar already did so."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 77,
                                "start": 67
                            }
                        ],
                        "text": "The four benchmarks Crystal, Fluid, Mandelbrot, and Nbody are from Accelerate."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 135,
                                "start": 123
                            }
                        ],
                        "text": "The downside is that some of these languages do not support inplace updates or explicit indexing inside parallel operators [15, 48, 52], and none of them systematically utilizes (imperfectly) nested parallelism."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 100,
                                "start": 90
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark.10 The three former consist of handwritten OpenCL programs, while Accelerate is an established Haskell DSL for GPU computation."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 46,
                                "start": 36
                            }
                        ],
                        "text": "Purely functional languages include Accelerate [39], Obsidian [18], and NOVA [19]."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 105,
                                "start": 101
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 95
                            }
                        ],
                        "text": "On the other side, there are a number of embedded (morally functional) data-parallel languages [2, 15, 35, 48, 51, 52] that express parallelism explicitly by means of bulk operators, which allow the compiler to reason at a higher level about restructuring the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 48
                            }
                        ],
                        "text": "We have selected the four (out of 15 available) Accelerate examples that were best suited as self-contained benchmarks."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 29,
                                "start": 19
                            }
                        ],
                        "text": "The translation of Accelerate programs is straightforward; for Rodinia and FinPar, parallel loops were translated to bulk-parallel operators such as map and reduce, while preserving the original code structure as much as possible."
                    },
                    "intents": []
                }
            ],
            "corpusId": 992519,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4726ec683a7db8e97ebd845b98e294ead537888a",
            "isKey": true,
            "numCitedBy": 253,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": "Current GPUs are massively parallel multicore processors optimised for workloads with a large degree of SIMD parallelism. Good performance requires highly idiomatic programs, whose development is work intensive and requires expert knowledge.\n To raise the level of abstraction, we propose a domain-specific high-level language of array computations that captures appropriate idioms in the form of collective array operations. We embed this purely functional array language in Haskell with an online code generator for NVIDIA's CUDA GPGPU programming environment. We regard the embedded language's collective array operations as algorithmic skeletons; our code generator instantiates CUDA implementations of those skeletons to execute embedded array programs.\n This paper outlines our embedding in Haskell, details the design and implementation of the dynamic code generator, and reports on initial benchmark results. These results suggest that we can compete with moderately optimised native CUDA code, while enabling much simpler source programs."
            },
            "slug": "Accelerating-Haskell-array-codes-with-multicore-Chakravarty-Keller",
            "title": {
                "fragments": [],
                "text": "Accelerating Haskell array codes with multicore GPUs"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "This paper proposes a domain-specific high-level language of array computations that captures appropriate idioms in the form of collective array operations in Haskell and embeds this purely functional array language in Haskell with an online code generator for NVIDIA's CUDA GPGPU programming environment."
            },
            "venue": {
                "fragments": [],
                "text": "DAMP '11"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31275734"
                        ],
                        "name": "Lars Bergstrom",
                        "slug": "Lars-Bergstrom",
                        "structuredName": {
                            "firstName": "Lars",
                            "lastName": "Bergstrom",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lars Bergstrom"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1730262"
                        ],
                        "name": "Matthew Fluet",
                        "slug": "Matthew-Fluet",
                        "structuredName": {
                            "firstName": "Matthew",
                            "lastName": "Fluet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Matthew Fluet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145573622"
                        ],
                        "name": "Mike Rainey",
                        "slug": "Mike-Rainey",
                        "structuredName": {
                            "firstName": "Mike",
                            "lastName": "Rainey",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mike Rainey"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3175026"
                        ],
                        "name": "J. Reppy",
                        "slug": "J.-Reppy",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Reppy",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Reppy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2057787964"
                        ],
                        "name": "Stephen Rosen",
                        "slug": "Stephen-Rosen",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Rosen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stephen Rosen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145657966"
                        ],
                        "name": "Adam Shaw",
                        "slug": "Adam-Shaw",
                        "structuredName": {
                            "firstName": "Adam",
                            "lastName": "Shaw",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Adam Shaw"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 24,
                                "start": 21
                            }
                        ],
                        "text": "Data-only flattening [8] shows how to convert from nested to flat representation of data, without affecting program structure."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1005665,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b9d08b23255d7fc8baeab48e9d933b93dca11d56",
            "isKey": false,
            "numCitedBy": 30,
            "numCiting": 27,
            "paperAbstract": {
                "fragments": [],
                "text": "Data parallelism has proven to be an effective technique for high-level programming of a certain class of parallel applications, but it is not well suited to irregular parallel computations. Blelloch and others proposed nested data parallelism (NDP) as a language mechanism for programming irregular parallel applications in a declarative data-parallel style. The key to this approach is a compiler transformation that flattens the NDP computation and data structures into a form that can be executed efficiently on a wide-vector SIMD architecture. Unfortunately, this technique is ill suited to execution on today's multicore machines. We present a new technique, called data-only flattening, for the compilation of NDP, which is suitable for multicore architectures. Data-only flattening transforms nested data structures in order to expose programs to various optimizations while leaving control structures intact. We present a formal semantics of data-only flattening in a core language with a rewriting system. We demonstrate the effectiveness of this technique in the Parallel ML implementation and we report encouraging experimental results across various benchmark applications."
            },
            "slug": "Data-only-flattening-for-nested-data-parallelism-Bergstrom-Fluet",
            "title": {
                "fragments": [],
                "text": "Data-only flattening for nested data parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "A new technique, called data-only flattening, for the compilation of NDP, which is suitable for multicore architectures and a formal semantics of data- only flattening in a core language with a rewriting system is presented."
            },
            "venue": {
                "fragments": [],
                "text": "PPoPP '13"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144913523"
                        ],
                        "name": "Alexander Collins",
                        "slug": "Alexander-Collins",
                        "structuredName": {
                            "firstName": "Alexander",
                            "lastName": "Collins",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Alexander Collins"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2401609"
                        ],
                        "name": "Dominik Grewe",
                        "slug": "Dominik-Grewe",
                        "structuredName": {
                            "firstName": "Dominik",
                            "lastName": "Grewe",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Dominik Grewe"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50654241"
                        ],
                        "name": "Vinod Grover",
                        "slug": "Vinod-Grover",
                        "structuredName": {
                            "firstName": "Vinod",
                            "lastName": "Grover",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Vinod Grover"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2108109511"
                        ],
                        "name": "Sean Lee",
                        "slug": "Sean-Lee",
                        "structuredName": {
                            "firstName": "Sean",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sean Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2925096"
                        ],
                        "name": "Adriana Susnea",
                        "slug": "Adriana-Susnea",
                        "structuredName": {
                            "firstName": "Adriana",
                            "lastName": "Susnea",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Adriana Susnea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 81,
                                "start": 77
                            }
                        ],
                        "text": "Purely functional languages include Accelerate [39], Obsidian [18], and NOVA [19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 6748967,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "93158db5c7d31159395e59b36e8a7b36816d4923",
            "isKey": false,
            "numCitedBy": 51,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "Functional languages provide a solid foundation on which complex optimization passes can be designed to exploit parallelism available in the underlying system. Their mathematical foundations enable high-level optimizations that would be impossible in traditional imperative languages. This makes them uniquely suited for generation of efficient target code for parallel systems, such as multiple Central Processing Units (CPUs) or highly data-parallel Graphics Processing Units (GPUs). Such systems are becoming the mainstream for scientific and commodity desktop computing. Writing performance portable code for such systems using low-level languages requires significant effort from a human expert. This paper presents NOVA, a functional language and compiler for multi-core CPUs and GPUs. The NOVA language is a polymorphic, statically-typed functional language with a suite of higher-order functions which are used to express parallelism. These include map, reduce and scan. The NOVA compiler is a light-weight, yet powerful, optimizing compiler. It generates code for a variety of target platforms that achieve performance comparable to competing languages and tools, including hand-optimized code. The NOVA compiler is stand-alone and can be easily used as a target for higher-level or domain specific languages or embedded in other applications. We evaluate NOVA against two competing approaches: the Thrust library and hand-written CUDA C. NOVA achieves comparable performance to these approaches across a range of benchmarks. NOVA-generated code also scales linearly with the number of processor cores across all compute-bound benchmarks."
            },
            "slug": "NOVA:-A-Functional-Language-for-Data-Parallelism-Collins-Grewe",
            "title": {
                "fragments": [],
                "text": "NOVA: A Functional Language for Data Parallelism"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "The NOVA language is a polymorphic, statically-typed functional language with a suite of higher-order functions which are used to express parallelism, and the NOVA compiler is a light-weight, yet powerful, optimizing compiler."
            },
            "venue": {
                "fragments": [],
                "text": "ARRAY@PLDI"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2965025"
                        ],
                        "name": "Troels Henriksen",
                        "slug": "Troels-Henriksen",
                        "structuredName": {
                            "firstName": "Troels",
                            "lastName": "Henriksen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Troels Henriksen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1911509"
                        ],
                        "name": "M. Elsman",
                        "slug": "M.-Elsman",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Elsman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Elsman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 116
                            }
                        ],
                        "text": "Precise shape information is computed for each bound variable and for each function by a slicing technique based on [30], which also supports existential types for the values whose shapes cannot be computed in advance."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1478847,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "604c30b7ae5afa90236f28fbd5b657c10fe62a8a",
            "isKey": false,
            "numCitedBy": 29,
            "numCiting": 49,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a shape inference analysis for a purely-functional language, named Futhark, that supports nested parallelism via array combinators such as map, reduce, filter}, and scan}. Our approach is to infer code for computing precise shape information at run-time, which in the most common cases can be effectively optimized by standard compiler optimizations. Instead of restricting the language or sacrificing ease of use, the language allows the occasional shape-dynamic, and even shape-misbehaving, constructs. Inherently shape-dynamic code is treated with a fall-back technique that preserves, asymptotically, the number of operations of the program and that computes and returns the array's shape alongside with its value. This approach leads to a shape-dependent system with existentially-quantified types, where static shape inference corresponds to eliminating existential quantifications from the types of program expressions.\n We optimize the common case to negligible overhead via size slicing: a technique that separates the computation of the array's shape from its values. This allows the shape to be calculated in advance and to be used to instantiate the previously existentially-quantified shapes of the value slice. We report negligible overhead, on several mini-benchmarks and three real-world applications."
            },
            "slug": "Size-slicing:-a-hybrid-approach-to-size-inference-Henriksen-Elsman",
            "title": {
                "fragments": [],
                "text": "Size slicing: a hybrid approach to size inference in futhark"
            },
            "tldr": {
                "abstractSimilarityScore": 93,
                "text": "A shape inference analysis for a purely-functional language, named Futhark, that supports nested parallelism via array combinators such as map, reduce, filter}, and scan is presented."
            },
            "venue": {
                "fragments": [],
                "text": "FHPC '14"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1795890"
                        ],
                        "name": "Michel Steuwer",
                        "slug": "Michel-Steuwer",
                        "structuredName": {
                            "firstName": "Michel",
                            "lastName": "Steuwer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michel Steuwer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2539451"
                        ],
                        "name": "Toomas Remmelg",
                        "slug": "Toomas-Remmelg",
                        "structuredName": {
                            "firstName": "Toomas",
                            "lastName": "Remmelg",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Toomas Remmelg"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3224333"
                        ],
                        "name": "Christophe Dubach",
                        "slug": "Christophe-Dubach",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Dubach",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christophe Dubach"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 85
                            }
                        ],
                        "text": "Work has been done on designing purely functional representations for OpenCL kernels [49], which could in principle be targeted by our flattening algorithm."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 7490888,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "aa3553beb4bfa0793a4bed05704e35412342800e",
            "isKey": false,
            "numCitedBy": 132,
            "numCiting": 21,
            "paperAbstract": {
                "fragments": [],
                "text": "Parallel patterns (e.g., map, reduce) have gained traction as an abstraction for targeting parallel accelerators and are a promising answer to the performance portability problem. However, compiling high-level programs into efficient low-level parallel code is challenging. Current approaches start from a high-level parallel IR and proceed to emit GPU code directly in one big step. Fixed strategies are used to optimize and map parallelism exploiting properties of a particular GPU generation leading to performance portability issues. We introduce the LIFT IR, a new data-parallel IR which encodes OpenCL-specific constructs as functional patterns. Our prior work has shown that this functional nature simplifies the exploration of optimizations and mapping of parallelism from portable high-level programs using rewrite-rules. This paper describes how LIFT IR programs are compiled into efficient OpenCL code. This is non-trivial as many performance sensitive details such as memory allocation, array accesses or synchronization are not explicitly represented in the LIFT IR. We present techniques which overcome this challenge by exploiting the pattern's high-level semantics. Our evaluation shows that the LIFT IR is flexible enough to express GPU programs with complex optimizations achieving performance on par with manually optimized code."
            },
            "slug": "LIFT:-A-functional-data-parallel-IR-for-GPU-code-Steuwer-Remmelg",
            "title": {
                "fragments": [],
                "text": "LIFT: A functional data-parallel IR for high-performance GPU code generation"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This paper describes how LIFT IR programs are compiled into efficient OpenCL code, a new data-parallel IR which encodes OpenCL-specific constructs as functional patterns which is flexible enough to express GPU programs with complex optimizations achieving performance on par with manually optimized code."
            },
            "venue": {
                "fragments": [],
                "text": "2017 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)"
            },
            "year": 2017
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2143686020"
                        ],
                        "name": "Yi Yang",
                        "slug": "Yi-Yang",
                        "structuredName": {
                            "firstName": "Yi",
                            "lastName": "Yang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yi Yang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2066321728"
                        ],
                        "name": "Ping Xiang",
                        "slug": "Ping-Xiang",
                        "structuredName": {
                            "firstName": "Ping",
                            "lastName": "Xiang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ping Xiang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1799386"
                        ],
                        "name": "J. Kong",
                        "slug": "J.-Kong",
                        "structuredName": {
                            "firstName": "Jingfei",
                            "lastName": "Kong",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Kong"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "38067595"
                        ],
                        "name": "Huiyang Zhou",
                        "slug": "Huiyang-Zhou",
                        "structuredName": {
                            "firstName": "Huiyang",
                            "lastName": "Zhou",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Huiyang Zhou"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 54,
                                "start": 46
                            }
                        ],
                        "text": "In comparison to Futhark, imperative analyses [55, 56] are superior at performing all kinds of tiling, for example hexagonal time tilling [26] and achieving memory coalescing by semantically transposing arrays on the fly (via tiling)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 112
                            }
                        ],
                        "text": "Imperative GPU compilation techniques rely on low-level index analysis ranging from pattern-matching heuristics [22, 56] to general modeling of affine transformations by polyhedral analysis [44, 55]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 44
                            }
                        ],
                        "text": "On one side, we find sophisticated analyses [16, 27, 41, 42, 55, 56], centered on dependency analysis of affine loop nests in low-level imperative languages such as C and Fortran."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 15479032,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "547074e26ddcbeaf4d9ae4c184a995aec1366dc4",
            "isKey": false,
            "numCitedBy": 311,
            "numCiting": 25,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents a novel optimizing compiler for general purpose computation on graphics processing units (GPGPU). It addresses two major challenges of developing high performance GPGPU programs: effective utilization of GPU memory hierarchy and judicious management of parallelism.\n The input to our compiler is a na\u00efve GPU kernel function, which is functionally correct but without any consideration for performance optimization. The compiler analyzes the code, identifies its memory access patterns, and generates both the optimized kernel and the kernel invocation parameters. Our optimization process includes vectorization and memory coalescing for memory bandwidth enhancement, tiling and unrolling for data reuse and parallelism management, and thread block remapping or address-offset insertion for partition-camping elimination. The experiments on a set of scientific and media processing algorithms show that our optimized code achieves very high performance, either superior or very close to the highly fine-tuned library, NVIDIA CUBLAS 2.2, and up to 128 times speedups over the naive versions. Another distinguishing feature of our compiler is the understandability of the optimized code, which is useful for performance analysis and algorithm refinement."
            },
            "slug": "A-GPGPU-compiler-for-memory-optimization-and-Yang-Xiang",
            "title": {
                "fragments": [],
                "text": "A GPGPU compiler for memory optimization and parallelism management"
            },
            "tldr": {
                "abstractSimilarityScore": 98,
                "text": "This paper presents a novel optimizing compiler for general purpose computation on graphics processing units (GPGPU), which addresses two major challenges of developing high performance GPGPU programs: effective utilization of GPU memory hierarchy and judicious management of parallelism."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '10"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1758245"
                        ],
                        "name": "Riyadh Baghdadi",
                        "slug": "Riyadh-Baghdadi",
                        "structuredName": {
                            "firstName": "Riyadh",
                            "lastName": "Baghdadi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Riyadh Baghdadi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2978162"
                        ],
                        "name": "Ulysse Beaugnon",
                        "slug": "Ulysse-Beaugnon",
                        "structuredName": {
                            "firstName": "Ulysse",
                            "lastName": "Beaugnon",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ulysse Beaugnon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1756389"
                        ],
                        "name": "T. Grosser",
                        "slug": "T.-Grosser",
                        "structuredName": {
                            "firstName": "Tobias",
                            "lastName": "Grosser",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Grosser"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "152835390"
                        ],
                        "name": "Michael Kruse",
                        "slug": "Michael-Kruse",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Kruse",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael Kruse"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144122184"
                        ],
                        "name": "Chandan Reddy",
                        "slug": "Chandan-Reddy",
                        "structuredName": {
                            "firstName": "Chandan",
                            "lastName": "Reddy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chandan Reddy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772079"
                        ],
                        "name": "Sven Verdoolaege",
                        "slug": "Sven-Verdoolaege",
                        "structuredName": {
                            "firstName": "Sven",
                            "lastName": "Verdoolaege",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sven Verdoolaege"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34781062"
                        ],
                        "name": "A. Betts",
                        "slug": "A.-Betts",
                        "structuredName": {
                            "firstName": "Adam",
                            "lastName": "Betts",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Betts"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1734519"
                        ],
                        "name": "A. Donaldson",
                        "slug": "A.-Donaldson",
                        "structuredName": {
                            "firstName": "Alastair",
                            "lastName": "Donaldson",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "A. Donaldson"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2303821"
                        ],
                        "name": "J. Ketema",
                        "slug": "J.-Ketema",
                        "structuredName": {
                            "firstName": "Jeroen",
                            "lastName": "Ketema",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ketema"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1796386"
                        ],
                        "name": "J. Absar",
                        "slug": "J.-Absar",
                        "structuredName": {
                            "firstName": "Javed",
                            "lastName": "Absar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Absar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1807282"
                        ],
                        "name": "S. V. Haastregt",
                        "slug": "S.-V.-Haastregt",
                        "structuredName": {
                            "firstName": "Sven",
                            "lastName": "Haastregt",
                            "middleNames": [
                                "van"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. V. Haastregt"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145510407"
                        ],
                        "name": "Alexey Kravets",
                        "slug": "Alexey-Kravets",
                        "structuredName": {
                            "firstName": "Alexey",
                            "lastName": "Kravets",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Alexey Kravets"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1777324"
                        ],
                        "name": "Anton Lokhmotov",
                        "slug": "Anton-Lokhmotov",
                        "structuredName": {
                            "firstName": "Anton",
                            "lastName": "Lokhmotov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Anton Lokhmotov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2061545111"
                        ],
                        "name": "R. David",
                        "slug": "R.-David",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "David",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. David"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1988507"
                        ],
                        "name": "Elnar Hajiyev",
                        "slug": "Elnar-Hajiyev",
                        "structuredName": {
                            "firstName": "Elnar",
                            "lastName": "Hajiyev",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Elnar Hajiyev"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 127,
                                "start": 124
                            }
                        ],
                        "text": "For example, OpenMP annotations can be used to enable transformations of otherwise unanalyzable patterns [16], while PENCIL [3] provides a restricted C99-like low-level language that allows the (expert) user to express the parallelism of loops and provide additional information about memory access patterns and dependencies."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 16354348,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "e61e896ee96c8d6ae13c34c9d66e8ee879489f75",
            "isKey": false,
            "numCitedBy": 90,
            "numCiting": 39,
            "paperAbstract": {
                "fragments": [],
                "text": "Programming accelerators such as GPUs with low-level APIs and languages such as OpenCL and CUDA is difficult, error-prone, and not performance-portable. Automatic parallelization and domain specific languages (DSLs) have been proposed to hide complexity and regain performance portability. We present PENCIL, a rigorously-defined subset of GNU C99-enriched with additional language constructs-that enables compilers to exploit parallelism and produce highly optimized code when targeting accelerators. PENCIL aims to serve both as a portable implementation language for libraries, and as a target language for DSL compilers. We implemented a PENCIL-to-OpenCL backend using a state-of-the-art polyhedral compiler. The polyhedral compiler, extended to handle data-dependent control flow and non-affine array accesses, generates optimized OpenCL code. To demonstrate the potential and performance portability of PENCIL and the PENCIL-to-OpenCL compiler, we consider a number of image processing kernels, a set of benchmarks from the Rodinia and SHOC suites, and DSL embedding scenarios for linear algebra (BLAS) and signal processing radar applications (SpearDE), and present experimental results for four GPU platforms: AMD Radeon HD 5670 and R9 285, NVIDIA GTX 470, and ARM Mali-T604."
            },
            "slug": "PENCIL:-A-Platform-Neutral-Compute-Intermediate-for-Baghdadi-Beaugnon",
            "title": {
                "fragments": [],
                "text": "PENCIL: A Platform-Neutral Compute Intermediate Language for Accelerator Programming"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "PENCIL, a rigorously-defined subset of GNU C99-enriched with additional language constructs-that enables compilers to exploit parallelism and produce highly optimized code when targeting accelerators, is presented."
            },
            "venue": {
                "fragments": [],
                "text": "2015 International Conference on Parallel Architecture and Compilation (PACT)"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3224333"
                        ],
                        "name": "Christophe Dubach",
                        "slug": "Christophe-Dubach",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Dubach",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christophe Dubach"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35977213"
                        ],
                        "name": "P. Cheng",
                        "slug": "P.-Cheng",
                        "structuredName": {
                            "firstName": "Perry",
                            "lastName": "Cheng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Cheng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714477"
                        ],
                        "name": "R. Rabbah",
                        "slug": "R.-Rabbah",
                        "structuredName": {
                            "firstName": "Rodric",
                            "lastName": "Rabbah",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Rabbah"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1678228"
                        ],
                        "name": "D. Bacon",
                        "slug": "D.-Bacon",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Bacon",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Bacon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33802916"
                        ],
                        "name": "Stephen J. Fink",
                        "slug": "Stephen-J.-Fink",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Fink",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stephen J. Fink"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 112
                            }
                        ],
                        "text": "Imperative GPU compilation techniques rely on low-level index analysis ranging from pattern-matching heuristics [22, 56] to general modeling of affine transformations by polyhedral analysis [44, 55]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 207195360,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "ff5e781484f16ca947ca347ce2633eadbe68e934",
            "isKey": false,
            "numCitedBy": 120,
            "numCiting": 32,
            "paperAbstract": {
                "fragments": [],
                "text": "Languages such as OpenCL and CUDA offer a standard interface for general-purpose programming of GPUs. However, with these languages, programmers must explicitly manage numerous low-level details involving communication and synchronization. This burden makes programming GPUs difficult and error-prone, rendering these powerful devices inaccessible to most programmers. We desire a higher-level programming model that makes GPUs more accessible while also effectively exploiting their computational power. This paper presents features of Lime, a new Java-compatible language targeting heterogeneous systems, that allow an optimizing compiler to generate high quality GPU code. The key insight is that the language type system enforces isolation and immutability invariants that allow the compiler to optimize for a GPU without heroic compiler analysis. Our compiler attains GPU speedups between 75% and 140% of the performance of native OpenCL code."
            },
            "slug": "Compiling-a-high-level-language-for-GPUs:-(via-for-Dubach-Cheng",
            "title": {
                "fragments": [],
                "text": "Compiling a high-level language for GPUs: (via language support for architectures and compilers)"
            },
            "venue": {
                "fragments": [],
                "text": "PLDI"
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145030858"
                        ],
                        "name": "D. Cunningham",
                        "slug": "D.-Cunningham",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Cunningham",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Cunningham"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1766516"
                        ],
                        "name": "R. Bordawekar",
                        "slug": "R.-Bordawekar",
                        "structuredName": {
                            "firstName": "Rajesh",
                            "lastName": "Bordawekar",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Bordawekar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714061"
                        ],
                        "name": "V. Saraswat",
                        "slug": "V.-Saraswat",
                        "structuredName": {
                            "firstName": "Vijay",
                            "lastName": "Saraswat",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. Saraswat"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 73,
                                "start": 69
                            }
                        ],
                        "text": "X10 demonstrates an elegant integration of GPUs into a PGAS language [21], but does not by itself provide an abstraction over hardware-specific limitations and performance characteristics."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14146740,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "c0f1c45ef7c9fb9751fdcc268daac62b70a7bd78",
            "isKey": false,
            "numCitedBy": 58,
            "numCiting": 19,
            "paperAbstract": {
                "fragments": [],
                "text": "GPU architectures have emerged as a viable way of considerably improving performance for appropriate applications. Program fragments (kernels) appropriate for GPU execution can be implemented in CUDA or OpenCL and glued into an application via an API.\n While there is plenty of evidence of performance improvements using this approach, there are many issues with productivity. Programmers must understand an additional programming model and API to program the accelerator; concurrency and synchronization in this programming model is typically expressed differently from the programming model for the host. On top of this, the languages used to write kernels are very low level and thus prone to the kinds of errors that one does not encounter in higher level languages. Programmers must explicitly deal with moving data back-and-forth between the host and the accelerator. These problems are compounded when the user code must be run across a cluster of accelerated nodes. Now the host programming model must further be extended with constructs to deal with scale-out and remote accelerators. We believe there is a critical need for a single source programming model that can be used to write clean, efficient code for heterogeneous, multi-core and scale-out architectures.\n The APGAS programming model has been developed for such architectures over the past six years. APGAS is based on four fundamental (and architecture-independent) notions: locality, asynchrony, conditional atomicity and order. X10 is an instantiation of the APGAS programming model on top of a base sequential language with Java-style productivity. Earlier work has shown that X10 can be used to write clean and efficient code for homogeneous multi-cores, SMPs, Cell-accelerated nodes, and clusters of such nodes. In this paper we show how X10 programmers can write code that can be compiled and run on GPUs. GPU programming idioms such as threads, blocks, barriers, constant memory, local registers, shared memory variables, etc. can be directly expressed in X10, and do not require new language extensions. We present the design of an extension of the X10-to-C++ compiler which recognizes such idioms and produces CUDA kernel code. We show several benchmarks written in this style. The performance of these kernels is within 80% of hand-written CUDA kernels.\n We believe these results establish X10 as a single-source programming language in which clean, efficient programs can be written for GPU-accelerated clusters."
            },
            "slug": "GPU-programming-in-a-high-level-language:-compiling-Cunningham-Bordawekar",
            "title": {
                "fragments": [],
                "text": "GPU programming in a high level language: compiling X10 to CUDA"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "X10 is established as a single-source programming language in which clean, efficient programs can be written for GPU-accelerated clusters and an extension of the X10-to-C++ compiler which recognizes such idioms and produces CUDA kernel code is presented."
            },
            "venue": {
                "fragments": [],
                "text": "X10 '11"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1401885963"
                        ],
                        "name": "Jonathan Ragan-Kelley",
                        "slug": "Jonathan-Ragan-Kelley",
                        "structuredName": {
                            "firstName": "Jonathan",
                            "lastName": "Ragan-Kelley",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jonathan Ragan-Kelley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2496412"
                        ],
                        "name": "Connelly Barnes",
                        "slug": "Connelly-Barnes",
                        "structuredName": {
                            "firstName": "Connelly",
                            "lastName": "Barnes",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Connelly Barnes"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144187067"
                        ],
                        "name": "Andrew Adams",
                        "slug": "Andrew-Adams",
                        "structuredName": {
                            "firstName": "Andrew",
                            "lastName": "Adams",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Andrew Adams"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145799132"
                        ],
                        "name": "Sylvain Paris",
                        "slug": "Sylvain-Paris",
                        "structuredName": {
                            "firstName": "Sylvain",
                            "lastName": "Paris",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sylvain Paris"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145403226"
                        ],
                        "name": "F. Durand",
                        "slug": "F.-Durand",
                        "structuredName": {
                            "firstName": "Fr\u00e9do",
                            "lastName": "Durand",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Durand"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 11,
                                "start": 7
                            }
                        ],
                        "text": "Halide [46] uses a stochastic approach for finding optimal schedules for fusing stencils by a combination of tiling, sliding window and work replication."
                    },
                    "intents": []
                }
            ],
            "corpusId": 5885207,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4d23db55e6671a82c95dacec33b2967a4b8b677d",
            "isKey": false,
            "numCitedBy": 878,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "Image processing pipelines combine the challenges of stencil computations and stream programs. They are composed of large graphs of different stencil stages, as well as complex reductions, and stages with global or data-dependent access patterns. Because of their complex structure, the performance difference between a naive implementation of a pipeline and an optimized one is often an order of magnitude. Efficient implementations require optimization of both parallelism and locality, but due to the nature of stencils, there is a fundamental tension between parallelism, locality, and introducing redundant recomputation of shared values. We present a systematic model of the tradeoff space fundamental to stencil pipelines, a schedule representation which describes concrete points in this space for each stage in an image processing pipeline, and an optimizing compiler for the Halide image processing language that synthesizes high performance implementations from a Halide algorithm and a schedule. Combining this compiler with stochastic search over the space of schedules enables terse, composable programs to achieve state-of-the-art performance on a wide range of real image processing pipelines, and across different hardware architectures, including multicores with SIMD, and heterogeneous CPU+GPU execution. From simple Halide programs written in a few hours, we demonstrate performance up to 5x faster than hand-tuned C, intrinsics, and CUDA implementations optimized by experts over weeks or months, for image processing applications beyond the reach of past automatic compilers."
            },
            "slug": "Halide:-a-language-and-compiler-for-optimizing-and-Ragan-Kelley-Barnes",
            "title": {
                "fragments": [],
                "text": "Halide: a language and compiler for optimizing parallelism, locality, and recomputation in image processing pipelines"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "A systematic model of the tradeoff space fundamental to stencil pipelines is presented, a schedule representation which describes concrete points in this space for each stage in an image processing pipeline, and an optimizing compiler for the Halide image processing language that synthesizes high performance implementations from a Halide algorithm and a schedule are presented."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1712841"
                        ],
                        "name": "K. Claessen",
                        "slug": "K.-Claessen",
                        "structuredName": {
                            "firstName": "Koen",
                            "lastName": "Claessen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Claessen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145135029"
                        ],
                        "name": "M. Sheeran",
                        "slug": "M.-Sheeran",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Sheeran",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Sheeran"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1897982"
                        ],
                        "name": "Bo Joel Svensson",
                        "slug": "Bo-Joel-Svensson",
                        "structuredName": {
                            "firstName": "Bo",
                            "lastName": "Svensson",
                            "middleNames": [
                                "Joel"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bo Joel Svensson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 66,
                                "start": 62
                            }
                        ],
                        "text": "Purely functional languages include Accelerate [39], Obsidian [18], and NOVA [19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14061197,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5eb8c3b3f6ec1a8126d87cff4918be2df025c984",
            "isKey": false,
            "numCitedBy": 76,
            "numCiting": 15,
            "paperAbstract": {
                "fragments": [],
                "text": "Graphics Processing Units (GPUs) are powerful computing devices that with the advent of CUDA/OpenCL are becomming useful for general purpose computations. Obsidian is an embedded domain specific language that generates CUDA kernels from functional descriptions. A symbolic array construction allows us to guarantee that intermediate arrays are fused away. However, the current array construction has some drawbacks; in particular, arrays cannot be combined efficiently. We add a new type of push arrays to the existing Obsidian system in order to solve this problem. The two array types complement each other, and enable the definition of combinators that both take apart and combine arrays, and that result in efficient generated code. This extension to Obsidian is demonstrated on a sequence of sorting kernels, with good results. The case study also illustrates the use of combinators for expressing the structure of parallel algorithms. The work presented is preliminary, and the combinators presented must be generalised. However, the raw speed of the generated kernels bodes well."
            },
            "slug": "Expressive-array-constructs-in-an-embedded-GPU-Claessen-Sheeran",
            "title": {
                "fragments": [],
                "text": "Expressive array constructs in an embedded GPU kernel programming language"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "This work adds a new type of push arrays to the existing Obsidian system, and enables the definition of combinators that both take apart and combine arrays, and that result in efficient generated code."
            },
            "venue": {
                "fragments": [],
                "text": "DAMP '12"
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "31275734"
                        ],
                        "name": "Lars Bergstrom",
                        "slug": "Lars-Bergstrom",
                        "structuredName": {
                            "firstName": "Lars",
                            "lastName": "Bergstrom",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Lars Bergstrom"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3175026"
                        ],
                        "name": "J. Reppy",
                        "slug": "J.-Reppy",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Reppy",
                            "middleNames": [
                                "H."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Reppy"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 62,
                                "start": 59
                            }
                        ],
                        "text": "The approach is however arguably inefficient in some cases [7], for example because it does not account for locality of reference."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 49,
                                "start": 42
                            }
                        ],
                        "text": "A notable exception to the latter is NESL [7, 11], which flattens all nested parallelism under asymptotic work-depth guarantees."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 21,
                                "start": 17
                            }
                        ],
                        "text": "In comparison to NESL [11], we support in-place updates, more operators, and an algorithm that can flatten only some of the top-level parallelism, i.e., it stops before introducing irregular arrays and before destroying the program structure needed for spatial and temporal locality optimizations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 208,
                                "start": 201
                            }
                        ],
                        "text": "We use transposition to handle coalescing, and, to our knowledge, no other compiler matches our AST-structural approach to kernel extraction, except for those that employ full flattening, such as NESL [7, 12], which often introduces inefficiencies and does not support in-place updates."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 16827721,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0972414bfe90cb2fa460c27f5694375b74325aaa",
            "isKey": true,
            "numCitedBy": 73,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "Graphics processing units (GPUs) provide both memory bandwidth and arithmetic performance far greater than that available on CPUs but, because of their Single-Instruction-Multiple-Data (SIMD) architecture, they are hard to program. Most of the programs ported to GPUs thus far use traditional data-level parallelism, performing only operations that operate uniformly over vectors. NESL is a first-order functional language that was designed to allow programmers to write irregular-parallel programs - such as parallel divide-and-conquer algorithms - for wide-vector parallel computers. This paper presents our port of the NESL implementation to work on GPUs and provides empirical evidence that nested data-parallelism (NDP) on GPUs significantly outperforms CPU-based implementations and matches or beats newer GPU languages that support only flat parallelism. While our performance does not match that of hand-tuned CUDA programs, we argue that the notational conciseness of NESL is worth the loss in performance. This work provides the first language implementation that directly supports NDP on a GPU."
            },
            "slug": "Nested-data-parallelism-on-the-gpu-Bergstrom-Reppy",
            "title": {
                "fragments": [],
                "text": "Nested data-parallelism on the gpu"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This paper presents the port of the NESL implementation to work on GPUs and provides empirical evidence that nested data-parallelism (NDP) on GPUs significantly outperforms CPU-based implementations and matches or beats newer GPU languages that support only flat parallelism."
            },
            "venue": {
                "fragments": [],
                "text": "ICFP"
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "50686076"
                        ],
                        "name": "Christian Andreetta",
                        "slug": "Christian-Andreetta",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Andreetta",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christian Andreetta"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "87827918"
                        ],
                        "name": "V. B\u00e9got",
                        "slug": "V.-B\u00e9got",
                        "structuredName": {
                            "firstName": "Vivien",
                            "lastName": "B\u00e9got",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "V. B\u00e9got"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35194104"
                        ],
                        "name": "J. Berthold",
                        "slug": "J.-Berthold",
                        "structuredName": {
                            "firstName": "Jost",
                            "lastName": "Berthold",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Berthold"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1911509"
                        ],
                        "name": "M. Elsman",
                        "slug": "M.-Elsman",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Elsman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Elsman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1749372"
                        ],
                        "name": "F. Henglein",
                        "slug": "F.-Henglein",
                        "structuredName": {
                            "firstName": "Fritz",
                            "lastName": "Henglein",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Henglein"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2965025"
                        ],
                        "name": "Troels Henriksen",
                        "slug": "Troels-Henriksen",
                        "structuredName": {
                            "firstName": "Troels",
                            "lastName": "Henriksen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Troels Henriksen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3430473"
                        ],
                        "name": "Maj-Britt Nordfang",
                        "slug": "Maj-Britt-Nordfang",
                        "structuredName": {
                            "firstName": "Maj-Britt",
                            "lastName": "Nordfang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Maj-Britt Nordfang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 151,
                                "start": 145
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0.6\u00d7 (slower) on FinPar\u2019s LocVolCalib benchmark to 16\u00d7 (faster) on Rodinia\u2019s NN benchmark."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 155,
                                "start": 152
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 168,
                                "start": 165
                            }
                        ],
                        "text": "For example, Sobol pseudo-random numbers can be computed by a slower but map-parallel formula, or by a cheaper (recurrence) one, but which requires scan parallelism [1]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 64,
                                "start": 58
                            }
                        ],
                        "text": "Several of the benchmarks discussed in Section 6, such as FinPar\u2019s LocVolCalib, Accelerate\u2019s Nbody, and Rodinia\u2019s CFD, K-means, Myocyte, and LavaMD, exhibit kernels in which one or several innermost dimensions of the mapped arrays are processed sequentially inside the kernel."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 63,
                                "start": 57
                            }
                        ],
                        "text": "We have focused on the shorter Rodinia benchmarks, while FinPar contains more challenging programs."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 84,
                                "start": 78
                            }
                        ],
                        "text": "Rodinia benchmarks have been modified to time similarly, while Accelerate and FinPar already did so."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 40,
                                "start": 34
                            }
                        ],
                        "text": "We have selected two out of three FinPar benchmarks, because the third one contains limited (irregular) parallelism."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 90,
                                "start": 87
                            }
                        ],
                        "text": "A simplified version of the streaming SOACs was introduced as a functional notation in [1], and non-overlapping aspects of the fusion engine were presented in [28, 32]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 66,
                                "start": 60
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark.10 The three former consist of handwritten OpenCL programs, while Accelerate is an established Haskell DSL for GPU computation."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 70,
                                "start": 67
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 74,
                                "start": 71
                            }
                        ],
                        "text": "Figure 10a shows a simplified example from the OptionPricing benchmark [1]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 23,
                                "start": 17
                            }
                        ],
                        "text": "LocVolCalib from FinPar is an outer map containing a sequential for-loop, which itself contains several more maps."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 25,
                                "start": 19
                            }
                        ],
                        "text": "OptionPricing from FinPar is essentially a map-reducecomposition."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 81,
                                "start": 75
                            }
                        ],
                        "text": "The translation of Accelerate programs is straightforward; for Rodinia and FinPar, parallel loops were translated to bulk-parallel operators such as map and reduce, while preserving the original code structure as much as possible."
                    },
                    "intents": []
                }
            ],
            "corpusId": 9794641,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "a564c755165250c8a0c3055adf81d9d824ae9598",
            "isKey": false,
            "numCitedBy": 21,
            "numCiting": 82,
            "paperAbstract": {
                "fragments": [],
                "text": "Commodity many-core hardware is now mainstream, but parallel programming models are still lagging behind in efficiently utilizing the application parallelism. There are (at least) two principal reasons for this. First, real-world programs often take the form of a deeply nested composition of parallel operators, but mapping the available parallelism to the hardware requires a set of transformations that are tedious to do by hand and beyond the capability of the common user. Second, the best optimization strategy, such as what to parallelize and what to efficiently sequentialize, is often sensitive to the input dataset and therefore requires multiple code versions that are optimized differently, which also raises maintainability problems. This article presents three array-based applications from the financial domain that are suitable for gpgpu execution. Common benchmark-design practice has been to provide the same code for the sequential and parallel versions that are optimized for only one class of datasets. In comparison, we document (1) all available parallelism via nested map-reduce functional combinators, in a simple Haskell implementation that closely resembles the original code structure, (2) the invariants and code transformations that govern the main trade-offs of a data-sensitive optimization space, and (3) report target cpu and multiversion gpgpu code together with an evaluation that demonstrates optimization trade-offs and other difficulties. We believe that this work provides useful insight into the language constructs and compiler infrastructure capable of expressing and optimizing such applications, and we report in-progress work in this direction."
            },
            "slug": "FinPar:-A-Parallel-Financial-Benchmark-Andreetta-B\u00e9got",
            "title": {
                "fragments": [],
                "text": "FinPar: A Parallel Financial Benchmark"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "This article presents three array-based applications from the financial domain that are suitable for gpgpu execution and provides useful insight into the language constructs and compiler infrastructure capable of expressing and optimizing such applications."
            },
            "venue": {
                "fragments": [],
                "text": "ACM Trans. Archit. Code Optim."
            },
            "year": 2016
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34946720"
                        ],
                        "name": "HyoukJoong Lee",
                        "slug": "HyoukJoong-Lee",
                        "structuredName": {
                            "firstName": "HyoukJoong",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "HyoukJoong Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144806284"
                        ],
                        "name": "Kevin J. Brown",
                        "slug": "Kevin-J.-Brown",
                        "structuredName": {
                            "firstName": "Kevin",
                            "lastName": "Brown",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kevin J. Brown"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706327"
                        ],
                        "name": "Arvind K. Sujeeth",
                        "slug": "Arvind-K.-Sujeeth",
                        "structuredName": {
                            "firstName": "Arvind",
                            "lastName": "Sujeeth",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Arvind K. Sujeeth"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1712987"
                        ],
                        "name": "Tiark Rompf",
                        "slug": "Tiark-Rompf",
                        "structuredName": {
                            "firstName": "Tiark",
                            "lastName": "Rompf",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tiark Rompf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746638"
                        ],
                        "name": "K. Olukotun",
                        "slug": "K.-Olukotun",
                        "structuredName": {
                            "firstName": "Kunle",
                            "lastName": "Olukotun",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Olukotun"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 97,
                                "start": 93
                            }
                        ],
                        "text": "Delite uses rewrite rules to optimize locality in NUMA settings [13] and proposes techniques [38] for handling simple cases of nested parallelism on GPUs by mapping inner parallelism to CUDA block and warp level."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 10491232,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5f99c0d653040778f64c0850f9e413be124ace60",
            "isKey": false,
            "numCitedBy": 48,
            "numCiting": 35,
            "paperAbstract": {
                "fragments": [],
                "text": "Recent work has explored using higher level languages to improve programmer productivity on GPUs. These languages often utilize high level computation patterns (e.g., Map and Reduce) that encode parallel semantics to enable automatic compilation to GPU kernels. However, the problem of efficiently mapping patterns to GPU hardware becomes significantly more difficult when the patterns are nested, which is common in non-trivial applications. To address this issue, we present a general analysis framework for automatically and efficiently mapping nested patterns onto GPUs. The analysis maps nested patterns onto a logical multidimensional domain and parameterizes the block size and degree of parallelism in each dimension. We then add GPU-specific hard and soft constraints to prune the space of possible mappings and select the best mapping. We also perform multiple compiler optimizations that are guided by the mapping to avoid dynamic memory allocations and automatically utilize shared memory within GPU kernels. We compare the performance of our automatically selected mappings to hand-optimized implementations on multiple benchmarks and show that the average performance gap on 7 out of 8 benchmarks is 24%. Furthermore, our mapping strategy outperforms simple 1D mappings and existing 2D mappings by up to 28.6x and 9.6x respectively."
            },
            "slug": "Locality-Aware-Mapping-of-Nested-Parallel-Patterns-Lee-Brown",
            "title": {
                "fragments": [],
                "text": "Locality-Aware Mapping of Nested Parallel Patterns on GPUs"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This work presents a general analysis framework for automatically and efficiently mapping nested patterns onto GPUs and compares the performance of the automatically selected mappings to hand-optimized implementations on multiple benchmarks and shows that the average performance gap on 7 out of 8 benchmarks is 24%."
            },
            "venue": {
                "fragments": [],
                "text": "2014 47th Annual IEEE/ACM International Symposium on Microarchitecture"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2301680"
                        ],
                        "name": "Bryan Catanzaro",
                        "slug": "Bryan-Catanzaro",
                        "structuredName": {
                            "firstName": "Bryan",
                            "lastName": "Catanzaro",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bryan Catanzaro"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144764367"
                        ],
                        "name": "M. Garland",
                        "slug": "M.-Garland",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Garland",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Garland"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1732330"
                        ],
                        "name": "K. Keutzer",
                        "slug": "K.-Keutzer",
                        "structuredName": {
                            "firstName": "Kurt",
                            "lastName": "Keutzer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Keutzer"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 44,
                                "start": 40
                            }
                        ],
                        "text": "Imperative solutions include Copperhead [14], Accelerator [53], and deeplearning DSLs, such as Theano [6] and Torch [20]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1867309,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "92028dd1d95d7447708899ae3b9506a356e4434d",
            "isKey": false,
            "numCitedBy": 216,
            "numCiting": 37,
            "paperAbstract": {
                "fragments": [],
                "text": "Modern parallel microprocessors deliver high performance on applications that expose substantial fine-grained data parallelism. Although data parallelism is widely available in many computations, implementing data parallel algorithms in low-level languages is often an unnecessarily difficult task. The characteristics of parallel microprocessors and the limitations of current programming methodologies motivate our design of Copperhead, a high-level data parallel language embedded in Python. The Copperhead programmer describes parallel computations via composition of familiar data parallel primitives supporting both flat and nested data parallel computation on arrays of data. Copperhead programs are expressed in a subset of the widely used Python programming language and interoperate with standard Python modules, including libraries for numeric computation, data visualization, and analysis. In this paper, we discuss the language, compiler, and runtime features that enable Copperhead to efficiently execute data parallel code. We define the restricted subset of Python which Copperhead supports and introduce the program analysis techniques necessary for compiling Copperhead code into efficient low-level implementations. We also outline the runtime support by which Copperhead programs interoperate with standard Python modules. We demonstrate the effectiveness of our techniques with several examples targeting the CUDA platform for parallel programming on GPUs. Copperhead code is concise, on average requiring 3.6 times fewer lines of code than CUDA, and the compiler generates efficient code, yielding 45-100% of the performance of hand-crafted, well optimized CUDA code."
            },
            "slug": "Copperhead:-compiling-an-embedded-data-parallel-Catanzaro-Garland",
            "title": {
                "fragments": [],
                "text": "Copperhead: compiling an embedded data parallel language"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "The language, compiler, and runtime features that enable Copperhead to efficiently execute data parallel code are discussed and the program analysis techniques necessary for compiling Copperhead code into efficient low-level implementations are introduced."
            },
            "venue": {
                "fragments": [],
                "text": "PPoPP '11"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34806932"
                        ],
                        "name": "Kazuaki Ishizaki",
                        "slug": "Kazuaki-Ishizaki",
                        "structuredName": {
                            "firstName": "Kazuaki",
                            "lastName": "Ishizaki",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kazuaki Ishizaki"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2054447578"
                        ],
                        "name": "Akihiro Hayashi",
                        "slug": "Akihiro-Hayashi",
                        "structuredName": {
                            "firstName": "Akihiro",
                            "lastName": "Hayashi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Akihiro Hayashi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2569451"
                        ],
                        "name": "Gita Koblents",
                        "slug": "Gita-Koblents",
                        "structuredName": {
                            "firstName": "Gita",
                            "lastName": "Koblents",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Gita Koblents"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1728219"
                        ],
                        "name": "Vivek Sarkar",
                        "slug": "Vivek-Sarkar",
                        "structuredName": {
                            "firstName": "Vivek",
                            "lastName": "Sarkar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Vivek Sarkar"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 95
                            }
                        ],
                        "text": "On the other side, there are a number of embedded (morally functional) data-parallel languages [2, 15, 35, 48, 51, 52] that express parallelism explicitly by means of bulk operators, which allow the compiler to reason at a higher level about restructuring the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5815586,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "1f7ad334ee1b933fcd2917f97a1b2eb97c8e44c2",
            "isKey": false,
            "numCitedBy": 47,
            "numCiting": 40,
            "paperAbstract": {
                "fragments": [],
                "text": "GPUs can enable significant performance improvements for certain classes of data parallel applications and are widely used in recent computer systems. However, GPU execution currently requires explicit low-level operations such as 1) managing memory allocations and transfers between the host system and the GPU, 2) writing GPU kernels in a low-level programming model such as CUDA or OpenCL, and 3) optimizing the kernels by utilizing appropriate memory types on the GPU. Because of this complexity, in many cases, only expert programmers can exploit the computational capabilities of GPUs through the CUDA/OpenCL languages. This is unfortunate since a large number of programmers use high-level languages, such as Java, due to their advantages of productivity, safety, and platform portability, but would still like to exploit the performance benefits of GPUs. Thus, one challenging problem is how to utilize GPUs while allowing programmers to continue to benefit from the productivity advantages of languages like Java. This paper presents a just-in-time (JIT) compiler that can generate and optimize GPU code from a pure Java program written using lambda expressions with the new parallel streams APIs in Java 8. These APIs allow Java programmers to express data parallelism at a higher level than threads and tasks. Our approach translates lambda expressions with parallel streams APIs in Java 8 into GPU code and automatically generates runtime calls that handle the low-level operations mentioned above. Additionally, our optimization techniques 1) allocate and align the starting address of the Java array body in the GPUs with the memory transaction boundary to increase memory bandwidth, 2) utilize read-only cache for array accesses to increase memory efficiency in GPUs, and 3) eliminate redundant data transfer between the host and the GPU. The compiler also performs loop versioning for eliminating redundant exception checks and for supporting virtual method invocations within GPU kernels. These features and optimizations are supported and automatically performed by a JIT compiler that is built on top of a production version of the IBM Java 8 runtime environment. Our experimental results on an NVIDIA Tesla GPU show significant performance improvements over sequential execution (127.9 \u00d7 geometric mean) and parallel execution (3.3 \u00d7 geometric mean) for eight Java 8 benchmark programs running on a 160-thread POWER8 machine. This paper also includes an in-depth analysis of GPU execution to show the impact of our optimization techniques by selectively disabling each optimization. Our experimental results show a geometric-mean speed-up of 1.15 \u00d7 in the GPU kernel over state-of-the-art approaches. Overall, our JIT compiler can improve the performance of Java 8 programs by automatically leveraging the computational capability of GPUs."
            },
            "slug": "Compiling-and-Optimizing-Java-8-Programs-for-GPU-Ishizaki-Hayashi",
            "title": {
                "fragments": [],
                "text": "Compiling and Optimizing Java 8 Programs for GPU Execution"
            },
            "tldr": {
                "abstractSimilarityScore": 38,
                "text": "A just-in-time (JIT) compiler that can generate and optimize GPU code from a pure Java program written using lambda expressions with the new parallel streams APIs in Java 8 by automatically leveraging the computational capability of GPUs is presented."
            },
            "venue": {
                "fragments": [],
                "text": "2015 International Conference on Parallel Architecture and Compilation (PACT)"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2508058"
                        ],
                        "name": "T. L. McDonell",
                        "slug": "T.-L.-McDonell",
                        "structuredName": {
                            "firstName": "Trevor",
                            "lastName": "McDonell",
                            "middleNames": [
                                "L."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. L. McDonell"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 110
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0.6\u00d7 (slower) on FinPar\u2019s LocVolCalib benchmark to 16\u00d7 (faster) on Rodinia\u2019s NN benchmark."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 125,
                                "start": 121
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 17,
                                "start": 7
                            }
                        ],
                        "text": "We use Accelerate version 0.15.1, with the CUDA backend."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 79
                            }
                        ],
                        "text": "Several of the benchmarks discussed in Section 6, such as FinPar\u2019s LocVolCalib, Accelerate\u2019s Nbody, and Rodinia\u2019s CFD, K-means, Myocyte, and LavaMD, exhibit kernels in which one or several innermost dimensions of the mapped arrays are processed sequentially inside the kernel."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 73,
                                "start": 63
                            }
                        ],
                        "text": "Rodinia benchmarks have been modified to time similarly, while Accelerate and FinPar already did so."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 77,
                                "start": 67
                            }
                        ],
                        "text": "The four benchmarks Crystal, Fluid, Mandelbrot, and Nbody are from Accelerate."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 100,
                                "start": 90
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark.10 The three former consist of handwritten OpenCL programs, while Accelerate is an established Haskell DSL for GPU computation."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 51,
                                "start": 47
                            }
                        ],
                        "text": "Purely functional languages include Accelerate [39], Obsidian [18], and NOVA [19]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 48
                            }
                        ],
                        "text": "We have selected the four (out of 15 available) Accelerate examples that were best suited as self-contained benchmarks."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 29,
                                "start": 19
                            }
                        ],
                        "text": "The translation of Accelerate programs is straightforward; for Rodinia and FinPar, parallel loops were translated to bulk-parallel operators such as map and reduce, while preserving the original code structure as much as possible."
                    },
                    "intents": []
                }
            ],
            "corpusId": 5843848,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "75a6257773d941488019b6c4ef5f210bbd652958",
            "isKey": true,
            "numCitedBy": 87,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "Purely functional, embedded array programs are a good match for SIMD hardware, such as GPUs. However, the naive compilation of such programs quickly leads to both code explosion and an excessive use of intermediate data structures. The resulting slow-down is not acceptable on target hardware that is usually chosen to achieve high performance. In this paper, we discuss two optimisation techniques, sharing recovery and array fusion, that tackle code explosion and eliminate superfluous intermediate structures. Both techniques are well known from other contexts, but they present unique challenges for an embedded language compiled for execution on a GPU. We present novel methods for implementing sharing recovery and array fusion, and demonstrate their effectiveness on a set of benchmarks."
            },
            "slug": "Optimising-purely-functional-GPU-programs-McDonell",
            "title": {
                "fragments": [],
                "text": "Optimising purely functional GPU programs"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "Two optimisation techniques are discussed, sharing recovery and array fusion, that tackle code explosion and eliminate superfluous intermediate structures for embedded language compiled for execution on a GPU."
            },
            "venue": {
                "fragments": [],
                "text": "ICFP"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717462"
                        ],
                        "name": "G. Blelloch",
                        "slug": "G.-Blelloch",
                        "structuredName": {
                            "firstName": "Guy",
                            "lastName": "Blelloch",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Blelloch"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40149094"
                        ],
                        "name": "J. Hardwick",
                        "slug": "J.-Hardwick",
                        "structuredName": {
                            "firstName": "Jonathan",
                            "lastName": "Hardwick",
                            "middleNames": [
                                "C."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Hardwick"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2071018"
                        ],
                        "name": "J. Sipelstein",
                        "slug": "J.-Sipelstein",
                        "structuredName": {
                            "firstName": "Jay",
                            "lastName": "Sipelstein",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Sipelstein"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2809530"
                        ],
                        "name": "M. Zagha",
                        "slug": "M.-Zagha",
                        "structuredName": {
                            "firstName": "Marco",
                            "lastName": "Zagha",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Zagha"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144280995"
                        ],
                        "name": "S. Chatterjee",
                        "slug": "S.-Chatterjee",
                        "structuredName": {
                            "firstName": "Siddhartha",
                            "lastName": "Chatterjee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Chatterjee"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 41,
                                "start": 37
                            }
                        ],
                        "text": "A notable exception to the latter is NESL [7, 11], which flattens all nested parallelism under asymptotic work-depth guarantees."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 67,
                                "start": 63
                            }
                        ],
                        "text": "2 The compiler transforms arrays-of-tuples to tuples-of-arrays [12] at an early compilation stage."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 21,
                                "start": 17
                            }
                        ],
                        "text": "In comparison to NESL [11], we support in-place updates, more operators, and an algorithm that can flatten only some of the top-level parallelism, i.e., it stops before introducing irregular arrays and before destroying the program structure needed for spatial and temporal locality optimizations."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 208,
                                "start": 201
                            }
                        ],
                        "text": "We use transposition to handle coalescing, and, to our knowledge, no other compiler matches our AST-structural approach to kernel extraction, except for those that employ full flattening, such as NESL [7, 12], which often introduces inefficiencies and does not support in-place updates."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1700132,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "aaf6b1f2a673cb375a3be33f709002c0bac20981",
            "isKey": true,
            "numCitedBy": 342,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper gives an overview of the implementation of NESL, a portable nested data-parallel language. This language and its implementation are the first to fully support nested data structures as well as nested data-parallel function calls. These features allow the concise description of parallel algorithms on irregular data, such as sparse matrices and graphs. In addition, they maintain the advantages of data-parallel languages: a simple programming model and portability. The current NESL implementation is based on an intermediate language called VCODE and a library of vector routines called CVL. It runs on the Connection Machine CM-2, the Cray Y-MP C90, and serial machines. We compare initial benchmark results of NESL with those of machine-specific code on these machines for three algorithms: least-squares line-fitting, median finding, and a sparse-matrix vector product. These results show that NESL's performance is competitive with that of machine-specific codes for regular dense data, and is often superior for irregular data."
            },
            "slug": "Implementation-of-a-portable-nested-data-parallel-Blelloch-Hardwick",
            "title": {
                "fragments": [],
                "text": "Implementation of a portable nested data-parallel language"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "Initial benchmark results of NESL show that NESL's performance is competitive with that of machine-specific codes for regular dense data, and is often superior for irregular data."
            },
            "venue": {
                "fragments": [],
                "text": "PPOPP '93"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144122184"
                        ],
                        "name": "Chandan Reddy",
                        "slug": "Chandan-Reddy",
                        "structuredName": {
                            "firstName": "Chandan",
                            "lastName": "Reddy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Chandan Reddy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "152835390"
                        ],
                        "name": "Michael Kruse",
                        "slug": "Michael-Kruse",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Kruse",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael Kruse"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 16130504,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "0ca62e174724db95de711c4c28c53fe573806762",
            "isKey": false,
            "numCitedBy": 16,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": "Reductions are common in scientific and data-crunching codes, and a typical source of bottlenecks on massively parallel architectures such as GPUs. Reductions are memory-bound, and achieving peak performance involves sophisticated optimizations. There exist libraries such as CUB and Thrust providing highly tuned implementations of reductions on GPUs. However, library APIs are not flexible enough to express user-defined reductions on arbitrary data types and array indexing schemes. Languages such as OpenACC provide declarative syntax to express reductions. Such approaches support a limited range of reduction operators and do not facilitate the application of complex program transformations in presence of reductions. We present language constructs that let a programmer express arbitrary reductions on user-defined data types matching the performance of tuned library implementations. We also extend a polyhedral compilation flow to process these user-defined reductions, enabling optimizations such as the fusion of multiple reductions, combining reductions with other loop transformations, and optimizing data transfers and storage in the presence of reductions. We implemented these language constructs and compilation methods in the PPCG framework and conducted experiments on multiple GPU targets. For single reductions the generated code performs on par with highly tuned libraries, and for multiple reductions it significantly outperforms both libraries and OpenACC on all platforms."
            },
            "slug": "Reduction-drawing:-Language-constructs-and-for-on-Reddy-Kruse",
            "title": {
                "fragments": [],
                "text": "Reduction drawing: Language constructs and polyhedral compilation for reductions on GPUs"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This work presents language constructs that let a programmer express arbitrary reductions on user-defined data types matching the performance of tuned library implementations, and extends a polyhedral compilation flow to process these user- defined reductions."
            },
            "venue": {
                "fragments": [],
                "text": "2016 International Conference on Parallel Architecture and Compilation Techniques (PACT)"
            },
            "year": 2016
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144616193"
                        ],
                        "name": "R. Allen",
                        "slug": "R.-Allen",
                        "structuredName": {
                            "firstName": "Randy",
                            "lastName": "Allen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Allen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "70455556"
                        ],
                        "name": "K. Kennedy",
                        "slug": "K.-Kennedy",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Kennedy",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kennedy"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 80,
                                "start": 76
                            }
                        ],
                        "text": "6 It is always safe to interchange inwards or to distribute a parallel loop [36]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 95,
                                "start": 91
                            }
                        ],
                        "text": "In comparison to imperative approaches, we also build on loop distribution and interchange [36], but we lift the reasoning to rely on the higherorder operator semantics rather than on low-level index analysis."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 43779902,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9dc9f86fb3116acf723f4404dcdf279fe322f01f",
            "isKey": false,
            "numCitedBy": 1104,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": "Modern computer architectures designed with high-performance microprocessors offer tremendous potential gains in performance over previous designs. Yet their very complexity makes it increasingly difficult to produce efficient code and to realize their full potential. This landmark text from two leaders in the field focuses on the pivotal role that compilers can play in addressing this critical issue. The basis for all the methods presented in this book is data dependence, a fundamental compiler analysis tool for optimizing programs on high-performance microprocessors and parallel architectures. It enables compiler designers to write compilers that automatically transform simple, sequential programs into forms that can exploit special features of these modern architectures. The text provides a broad introduction to data dependence, to the many transformation strategies it supports, and to its applications to important optimization problems such as parallelization, compiler memory hierarchy management, and instruction scheduling. The authors demonstrate the importance and wide applicability of dependence-based compiler optimizations and give the compiler writer the basics needed to understand and implement them. They also offer cookbook explanations for transforming applications by hand to computational scientists and engineers who are driven to obtain the best possible performance of their complex applications."
            },
            "slug": "Optimizing-Compilers-for-Modern-Architectures:-A-Allen-Kennedy",
            "title": {
                "fragments": [],
                "text": "Optimizing Compilers for Modern Architectures: A Dependence-based Approach"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A broad introduction to data dependence, to the many transformation strategies it supports, and to its applications to important optimization problems such as parallelization, compiler memory hierarchy management, and instruction scheduling are provided."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2001
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2965025"
                        ],
                        "name": "Troels Henriksen",
                        "slug": "Troels-Henriksen",
                        "structuredName": {
                            "firstName": "Troels",
                            "lastName": "Henriksen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Troels Henriksen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1944739"
                        ],
                        "name": "K. Larsen",
                        "slug": "K.-Larsen",
                        "structuredName": {
                            "firstName": "Ken",
                            "lastName": "Larsen",
                            "middleNames": [
                                "Friis"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Larsen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 57
                            }
                        ],
                        "text": "Futhark\u2019s fusion engine builds previously published work [28, 32]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 167,
                                "start": 159
                            }
                        ],
                        "text": "A simplified version of the streaming SOACs was introduced as a functional notation in [1], and non-overlapping aspects of the fusion engine were presented in [28, 32]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 9860626,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "de7df9ef0736e9b7798e37030c522f17ecb5681e",
            "isKey": false,
            "numCitedBy": 18,
            "numCiting": 31,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents and evaluates a novel second-order operator, named 'redomap', that stems from 'map'-'reduce' compositions in the context of the purely-functional array language Futhark, which is aimed at efficient GPGPU execution. Main contributions are: First, we demonstrate an aggressive fusion technique that is centered on the 'redomap' operator. Second, we present a compilation technique for 'redomap' that efficiently sequentializes the excess parallelism and ensures coalesced access to global memory, even for non-commutative 'reduce' operators. Third, a detailed performance evaluation shows that Futhark's automatically generated code matches or exceeds performance of hand-tuned Thrust code. Our evaluation infrastructure is publicly available and we encourage replication and verification of our results."
            },
            "slug": "Design-and-GPGPU-performance-of-Futhark's-redomap-Henriksen-Larsen",
            "title": {
                "fragments": [],
                "text": "Design and GPGPU performance of Futhark's redomap construct"
            },
            "tldr": {
                "abstractSimilarityScore": 82,
                "text": "A novel second-order operator, named 'redomap', that stems from 'map'-'reduce' compositions in the context of the purely-functional array language Futhark, which is aimed at efficient GPGPU execution."
            },
            "venue": {
                "fragments": [],
                "text": "ARRAY@PLDI"
            },
            "year": 2016
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143896454"
                        ],
                        "name": "Mary W. Hall",
                        "slug": "Mary-W.-Hall",
                        "structuredName": {
                            "firstName": "Mary",
                            "lastName": "Hall",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Mary W. Hall"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "119749490"
                        ],
                        "name": "Brian R. Murphy",
                        "slug": "Brian-R.-Murphy",
                        "structuredName": {
                            "firstName": "Brian",
                            "lastName": "Murphy",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Brian R. Murphy"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40063567"
                        ],
                        "name": "Shih-Wei Liao",
                        "slug": "Shih-Wei-Liao",
                        "structuredName": {
                            "firstName": "Shih-Wei",
                            "lastName": "Liao",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Shih-Wei Liao"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "39682108"
                        ],
                        "name": "M. Lam",
                        "slug": "M.-Lam",
                        "structuredName": {
                            "firstName": "Monica",
                            "lastName": "Lam",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Lam"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 44
                            }
                        ],
                        "text": "On one side, we find sophisticated analyses [16, 27, 41, 42, 55, 56], centered on dependency analysis of affine loop nests in low-level imperative languages such as C and Fortran."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14070128,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "27941ab73166da5986c98da4c38e7ae21e9871f7",
            "isKey": false,
            "numCitedBy": 69,
            "numCiting": 93,
            "paperAbstract": {
                "fragments": [],
                "text": "As shared-memory multiprocessor systems become widely available, there is an increasing need for tools to simplify the task of developing parallel programs. This paper describes one such tool, the automatic parallelization system in the Stanford SUIF compiler. This article represents a culmination of a several-year research effort aimed at making parallelizing compilers significantly more effective. We have developed a system that performs full interprocedural parallelization analyses, including array privatization analysis, array reduction recognition, and a suite of scalar data-flow analyses including symbolic analysis. These analyses collaborate in an integrated fashion to exploit coarse-grain parallel loops, computationally intensive loops that can execute on multiple processors independently with no cross-processor synchronization or communication. The system has successfully parallelized large interprocedural loops over a thousand lines of code completely automatically from sequential applications.This article provides a comprehensive description of the analyses in the SUIF system. We also present extensive empirical results on four benchmark suites, showing the contribution of individual analysis techniques both in executing more of the computation in parallel, and in increasing the granularity of the parallel computations. These results demonstrate the importance of interprocedural array data-flow analysis, array privatization and array reduction recognition; a third of the programs spend more than 50&percent; of their execution time in computations that are parallelized with these techniques. Overall, these results indicate that automatic parallelization can be effective on sequential scientific computations, but only if the compiler incorporates all of these analyses."
            },
            "slug": "Interprocedural-parallelization-analysis-in-SUIF-Hall-Amarasinghe",
            "title": {
                "fragments": [],
                "text": "Interprocedural parallelization analysis in SUIF"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "Results indicate that automatic parallelization can be effective on sequential scientific computations, but only if the compiler incorporates all of these analyses, including array privatization analysis, array reduction recognition, and a suite of scalar data-flow analyses."
            },
            "venue": {
                "fragments": [],
                "text": "TOPL"
            },
            "year": 2005
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2965025"
                        ],
                        "name": "Troels Henriksen",
                        "slug": "Troels-Henriksen",
                        "structuredName": {
                            "firstName": "Troels",
                            "lastName": "Henriksen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Troels Henriksen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 65,
                                "start": 57
                            }
                        ],
                        "text": "Futhark\u2019s fusion engine builds previously published work [28, 32]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 167,
                                "start": 159
                            }
                        ],
                        "text": "A simplified version of the streaming SOACs was introduced as a functional notation in [1], and non-overlapping aspects of the fusion engine were presented in [28, 32]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 62,
                                "start": 58
                            }
                        ],
                        "text": "An intuitive demonstration on a code example was given in [28] but the typing rules were not presented there."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 15987743,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "74baf0ef53be9374dc1e3b4854310f7a0e3a4f6a",
            "isKey": false,
            "numCitedBy": 23,
            "numCiting": 33,
            "paperAbstract": {
                "fragments": [],
                "text": "Fusion is one of the most important code transformations as it has the potential to substantially optimize both the memory hierarchy time overhead and, sometimes asymptotically, the space requirement.\n In functional languages, fusion is naturally and relatively easily derived as a producer-consumer relation between program constructs that expose a richer, higher-order algebra of program invariants, such as the map-reduce list homomorphisms.\n In imperative languages, fusing producer-consumer loops requires dependency analysis on arrays applied at loop-nest level. Such analysis, however, has often been labeled as \"heroic effort\" and, if at all, is supported only in its simplest and most conservative form in industrial compilers.\n Related implementations in the functional context typically apply fusion only when the to-be-fused producer is used exactly once, i.e., in the consumer. This guarantees that the transformation is conservative: the resulting program does not duplicate computation.\n We show that the above restriction is more conservative than needed, and present a structural-analysis technique, inspired from the T1--T2 transformation for reducible data flow, that enables fusion even in some cases when the producer is used in different consumers and without duplicating computation.\n We report an implementation of the fusion algorithm for a functional-core language, named L0, which is intended to support nested parallelism across regular multi-dimensional arrays. We succinctly describe L0's semantics and the compiler infrastructure on which the fusion transformation relies, and present compiler-generated statistics related to fusion on a set of six benchmarks."
            },
            "slug": "A-T2-graph-reduction-approach-to-fusion-Henriksen-Oancea",
            "title": {
                "fragments": [],
                "text": "A T2 graph-reduction approach to fusion"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "An implementation of the fusion algorithm for a functional-core language, named L0, which is intended to support nested parallelism across regular multi-dimensional arrays, and succinctly describes L0's semantics and the compiler infrastructure on which the fusion transformation relies, and presents compiler-generated statistics related to fusion on a set of six benchmarks."
            },
            "venue": {
                "fragments": [],
                "text": "FHPC '13"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144806284"
                        ],
                        "name": "Kevin J. Brown",
                        "slug": "Kevin-J.-Brown",
                        "structuredName": {
                            "firstName": "Kevin",
                            "lastName": "Brown",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kevin J. Brown"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34946720"
                        ],
                        "name": "HyoukJoong Lee",
                        "slug": "HyoukJoong-Lee",
                        "structuredName": {
                            "firstName": "HyoukJoong",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "HyoukJoong Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1712987"
                        ],
                        "name": "Tiark Rompf",
                        "slug": "Tiark-Rompf",
                        "structuredName": {
                            "firstName": "Tiark",
                            "lastName": "Rompf",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tiark Rompf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706327"
                        ],
                        "name": "Arvind K. Sujeeth",
                        "slug": "Arvind-K.-Sujeeth",
                        "structuredName": {
                            "firstName": "Arvind",
                            "lastName": "Sujeeth",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Arvind K. Sujeeth"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1801197"
                        ],
                        "name": "Christopher De Sa",
                        "slug": "Christopher-De-Sa",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "Sa",
                            "middleNames": [
                                "De"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christopher De Sa"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145284500"
                        ],
                        "name": "Christopher R. Aberger",
                        "slug": "Christopher-R.-Aberger",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "Aberger",
                            "middleNames": [
                                "R."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christopher R. Aberger"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746638"
                        ],
                        "name": "K. Olukotun",
                        "slug": "K.-Olukotun",
                        "structuredName": {
                            "firstName": "Kunle",
                            "lastName": "Olukotun",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Olukotun"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 64
                            }
                        ],
                        "text": "Delite uses rewrite rules to optimize locality in NUMA settings [13] and proposes techniques [38] for handling simple cases of nested parallelism on GPUs by mapping inner parallelism to CUDA block and warp level."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 15209294,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b0159354873d31c8772b83ac6dce1c583fcd16b1",
            "isKey": false,
            "numCitedBy": 50,
            "numCiting": 44,
            "paperAbstract": {
                "fragments": [],
                "text": "High performance in modern computing platforms requires programs to be parallel, distributed, and run on heterogeneous hardware. However programming such architectures is extremely difficult due to the need to implement the application using multiple programming models and combine them together in ad-hoc ways. To optimize distributed applications both for modern hardware and for modern programmers we need a programming model that is sufficiently expressive to support a variety of parallel applications, sufficiently performant to surpass hand-optimized sequential implementations, and sufficiently portable to support a variety of heterogeneous hardware. Unfortunately existing systems tend to fall short of these requirements. In this paper we introduce the Distributed Multiloop Language (DMLL), a new intermediate language based on common parallel patterns that captures the necessary semantic knowledge to efficiently target distributed heterogeneous architectures. We show straightforward analyses that determine what data to distribute based on its usage as well as powerful transformations of nested patterns that restructure computation to enable distribution and optimize for heterogeneous devices. We present experimental results for a range of applications spanning multiple domains and demonstrate highly efficient execution compared to manually-optimized counterparts in multiple distributed programming models."
            },
            "slug": "Have-abstraction-and-eat-performance,-too:-with-Brown-Lee",
            "title": {
                "fragments": [],
                "text": "Have abstraction and eat performance, too: Optimized heterogeneous computing with parallel patterns"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This paper introduces the Distributed Multiloop Language (DMLL), a new intermediate language based on common parallel patterns that captures the necessary semantic knowledge to efficiently target distributed heterogeneous architectures and shows straightforward analyses that determine what data to distribute based on its usage."
            },
            "venue": {
                "fragments": [],
                "text": "2016 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)"
            },
            "year": 2016
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772079"
                        ],
                        "name": "Sven Verdoolaege",
                        "slug": "Sven-Verdoolaege",
                        "structuredName": {
                            "firstName": "Sven",
                            "lastName": "Verdoolaege",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sven Verdoolaege"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3281978"
                        ],
                        "name": "J. Juega",
                        "slug": "J.-Juega",
                        "structuredName": {
                            "firstName": "Juan",
                            "lastName": "Juega",
                            "middleNames": [
                                "Carlos"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Juega"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144431297"
                        ],
                        "name": "J. I. G\u00f3mez",
                        "slug": "J.-I.-G\u00f3mez",
                        "structuredName": {
                            "firstName": "Jos\u00e9",
                            "lastName": "G\u00f3mez",
                            "middleNames": [
                                "Ignacio"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. I. G\u00f3mez"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1916522"
                        ],
                        "name": "C. Tenllado",
                        "slug": "C.-Tenllado",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Tenllado",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Tenllado"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145410654"
                        ],
                        "name": "F. Catthoor",
                        "slug": "F.-Catthoor",
                        "structuredName": {
                            "firstName": "Francky",
                            "lastName": "Catthoor",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "F. Catthoor"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "UNPAYWALL"
                },
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 54,
                                "start": 46
                            }
                        ],
                        "text": "In comparison to Futhark, imperative analyses [55, 56] are superior at performing all kinds of tiling, for example hexagonal time tilling [26] and achieving memory coalescing by semantically transposing arrays on the fly (via tiling)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 198,
                                "start": 190
                            }
                        ],
                        "text": "Imperative GPU compilation techniques rely on low-level index analysis ranging from pattern-matching heuristics [22, 56] to general modeling of affine transformations by polyhedral analysis [44, 55]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 44
                            }
                        ],
                        "text": "On one side, we find sophisticated analyses [16, 27, 41, 42, 55, 56], centered on dependency analysis of affine loop nests in low-level imperative languages such as C and Fortran."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 75,
                                "start": 71
                            }
                        ],
                        "text": "Our flattening transformation resembles the tree-of-bands construction [55] in that it semantically builds on interchange and distribution, but we use higher-order rules."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1212874,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "963a1e639971e7e3a4e6c871cf9c0b410e5532d0",
            "isKey": true,
            "numCitedBy": 323,
            "numCiting": 65,
            "paperAbstract": {
                "fragments": [],
                "text": "This article addresses the compilation of a sequential program for parallel execution on a modern GPU. To this end, we present a novel source-to-source compiler called PPCG. PPCG singles out for its ability to accelerate computations from any static control loop nest, generating multiple CUDA kernels when necessary. We introduce a multilevel tiling strategy and a code generation scheme for the parallelization and locality optimization of imperfectly nested loops, managing memory and exposing concurrency according to the constraints of modern GPUs. We evaluate our algorithms and tool on the entire PolyBench suite."
            },
            "slug": "Polyhedral-parallel-code-generation-for-CUDA-Verdoolaege-Juega",
            "title": {
                "fragments": [],
                "text": "Polyhedral parallel code generation for CUDA"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A novel source-to-source compiler called PPCG is presented, which introduces a multilevel tiling strategy and a code generation scheme for the parallelization and locality optimization of imperfectly nested loops, managing memory and exposing concurrency according to the constraints of modern GPUs."
            },
            "venue": {
                "fragments": [],
                "text": "TACO"
            },
            "year": 2013
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1795890"
                        ],
                        "name": "Michel Steuwer",
                        "slug": "Michel-Steuwer",
                        "structuredName": {
                            "firstName": "Michel",
                            "lastName": "Steuwer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michel Steuwer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1704372"
                        ],
                        "name": "Christian Fensch",
                        "slug": "Christian-Fensch",
                        "structuredName": {
                            "firstName": "Christian",
                            "lastName": "Fensch",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christian Fensch"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3731467"
                        ],
                        "name": "S. Lindley",
                        "slug": "S.-Lindley",
                        "structuredName": {
                            "firstName": "Sam",
                            "lastName": "Lindley",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Lindley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3224333"
                        ],
                        "name": "Christophe Dubach",
                        "slug": "Christophe-Dubach",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Dubach",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christophe Dubach"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 21,
                                "start": 17
                            }
                        ],
                        "text": "More recent work [48] shows that stochastic combinations of rewrite rules opens the door to autotuning."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 135,
                                "start": 123
                            }
                        ],
                        "text": "The downside is that some of these languages do not support inplace updates or explicit indexing inside parallel operators [15, 48, 52], and none of them systematically utilizes (imperfectly) nested parallelism."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 95
                            }
                        ],
                        "text": "On the other side, there are a number of embedded (morally functional) data-parallel languages [2, 15, 35, 48, 51, 52] that express parallelism explicitly by means of bulk operators, which allow the compiler to reason at a higher level about restructuring the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8030067,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "8095a0dc01a3f75f85b0baa7890e2fa3463170c4",
            "isKey": false,
            "numCitedBy": 116,
            "numCiting": 53,
            "paperAbstract": {
                "fragments": [],
                "text": "Computers have become increasingly complex with the emergence of heterogeneous hardware combining multicore CPUs and GPUs. These parallel systems exhibit tremendous computational power at the cost of increased programming effort resulting in a tension between performance and code portability. Typically, code is either tuned in a low-level imperative language using hardware-specific optimizations to achieve maximum performance or is written in a high-level, possibly functional, language to achieve portability at the expense of performance. We propose a novel approach aiming to combine high-level programming, code portability, and high-performance. Starting from a high-level functional expression we apply a simple set of rewrite rules to transform it into a low-level functional representation, close to the OpenCL programming model, from which OpenCL code is generated. Our rewrite rules define a space of possible implementations which we automatically explore to generate hardware-specific OpenCL implementations. We formalize our system with a core dependently-typed lambda-calculus along with a denotational semantics which we use to prove the correctness of the rewrite rules. We test our design in practice by implementing a compiler which generates high performance imperative OpenCL code. Our experiments show that we can automatically derive hardware-specific implementations from simple functional high-level algorithmic expressions offering performance on a par with highly tuned code for multicore CPUs and GPUs written by experts."
            },
            "slug": "Generating-performance-portable-code-using-rewrite-Steuwer-Fensch",
            "title": {
                "fragments": [],
                "text": "Generating performance portable code using rewrite rules: from high-level functional expressions to high-performance OpenCL code"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "This work proposes a novel approach aiming to combine high-level programming, code portability, and high-performance by applying a simple set of rewrite rules to transform it into a low-level functional representation close to the OpenCL programming model, from which OpenCL code is generated."
            },
            "venue": {
                "fragments": [],
                "text": "ICFP"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1689939"
                        ],
                        "name": "L. Rauchwerger",
                        "slug": "L.-Rauchwerger",
                        "structuredName": {
                            "firstName": "Lawrence",
                            "lastName": "Rauchwerger",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Rauchwerger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 44
                            }
                        ],
                        "text": "On one side, we find sophisticated analyses [16, 27, 41, 42, 55, 56], centered on dependency analysis of affine loop nests in low-level imperative languages such as C and Fortran."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 16357761,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "70b7b89b118107e7a8b294eab32de4a7f5e31b71",
            "isKey": false,
            "numCitedBy": 37,
            "numCiting": 41,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents a fully automatic approach to loop parallelization that integrates the use of static and run-time analysis and thus overcomes many known difficulties such as nonlinear and indirect array indexing and complex control flow. Our hybrid analysis framework validates the parallelization transformation by verifying the independence of the loop's memory references. To this end it represents array references using the USR (uniform set representation) language and expresses the independence condition as an equation, S=0, where S is a set expression representing array indexes. Using a language instead of an array-abstraction representation for S results in a smaller number of conservative approximations but exhibits a potentially-high runtime cost. To alleviate this cost we introduce a language translation F from the USR set-expression language to an equally rich language of predicates (F(S) ==> S = 0). Loop parallelization is then validated using a novel logic inference algorithm that factorizes the obtained complex predicates (F(S)) into a sequence of sufficient independence conditions that are evaluated first statically and, when needed, dynamically, in increasing order of their estimated complexities. We evaluate our automated solution on 26 benchmarks from PERFECT-Club and SPEC suites and show that our approach is effective in parallelizing large, complex loops and obtains much better full program speedups than the Intel and IBM Fortran compilers."
            },
            "slug": "Logical-inference-techniques-for-loop-Oancea-Rauchwerger",
            "title": {
                "fragments": [],
                "text": "Logical inference techniques for loop parallelization"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "This paper presents a fully automatic approach to loop parallelization that integrates the use of static and run-time analysis and thus overcomes many known difficulties such as nonlinear and indirect array indexing and complex control flow."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI"
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1973206"
                        ],
                        "name": "D. Tarditi",
                        "slug": "D.-Tarditi",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Tarditi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Tarditi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2568084"
                        ],
                        "name": "Sidd Puri",
                        "slug": "Sidd-Puri",
                        "structuredName": {
                            "firstName": "Sidd",
                            "lastName": "Puri",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sidd Puri"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "47768166"
                        ],
                        "name": "Jose Oglesby",
                        "slug": "Jose-Oglesby",
                        "structuredName": {
                            "firstName": "Jose",
                            "lastName": "Oglesby",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jose Oglesby"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 62,
                                "start": 58
                            }
                        ],
                        "text": "Imperative solutions include Copperhead [14], Accelerator [53], and deeplearning DSLs, such as Theano [6] and Torch [20]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 5321197,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "abefa9dca1fe0c8999d45ccdbed44f28c66a737b",
            "isKey": false,
            "numCitedBy": 347,
            "numCiting": 28,
            "paperAbstract": {
                "fragments": [],
                "text": "GPUs are difficult to program for general-purpose uses. Programmers can either learn graphics APIs and convert their applications to use graphics pipeline operations or they can use stream programming abstractions of GPUs. We describe Accelerator, a system that uses data parallelism to program GPUs for general-purpose uses instead. Programmers use a conventional imperative programming language and a library that provides only high-level data-parallel operations. No aspects of GPUs are exposed to programmers. The library implementation compiles the data-parallel operations on the fly to optimized GPU pixel shader code and API calls.We describe the compilation techniques used to do this. We evaluate the effectiveness of using data parallelism to program GPUs by providing results for a set of compute-intensive benchmarks. We compare the performance of Accelerator versions of the benchmarks against hand-written pixel shaders. The speeds of the Accelerator versions are typically within 50% of the speeds of hand-written pixel shader code. Some benchmarks significantly outperform C versions on a CPU: they are up to 18 times faster than C code running on a CPU."
            },
            "slug": "Accelerator:-using-data-parallelism-to-program-GPUs-Tarditi-Puri",
            "title": {
                "fragments": [],
                "text": "Accelerator: using data parallelism to program GPUs for general-purpose uses"
            },
            "tldr": {
                "abstractSimilarityScore": 46,
                "text": "This work describes Accelerator, a system that uses data parallelism to program GPUs for general-purpose uses instead of C, and compares the performance of Accelerator versions of the benchmarks against hand-written pixel shaders."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS XII"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2341914"
                        ],
                        "name": "Michael I. Gordon",
                        "slug": "Michael-I.-Gordon",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Gordon",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael I. Gordon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1718457"
                        ],
                        "name": "William Thies",
                        "slug": "William-Thies",
                        "structuredName": {
                            "firstName": "William",
                            "lastName": "Thies",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "William Thies"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1709150"
                        ],
                        "name": "Saman P. Amarasinghe",
                        "slug": "Saman-P.-Amarasinghe",
                        "structuredName": {
                            "firstName": "Saman",
                            "lastName": "Amarasinghe",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Saman P. Amarasinghe"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 376,
                                "start": 372
                            }
                        ],
                        "text": "StreamIt supports a number of static optimizations on various hardware, for example, GPU optimizations [34] include memory-layout selection (shared/global memory), resolving shared-memory bank conflicts, increasing the granularity of parallelism by vertical fusion, and untilizing unused registers by software prefetching and loop unrolling, while multicore optimizations [25] are aimed at finding the right mix of task, data and pipeline parallelism."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8333054,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9b23d37b72ee7fe4f8bb3230e1640cbeb9c6c599",
            "isKey": false,
            "numCitedBy": 592,
            "numCiting": 47,
            "paperAbstract": {
                "fragments": [],
                "text": "As multicore architectures enter the mainstream, there is a pressing demand for high-level programming models that can effectively map to them. Stream programming offers an attractive way to expose coarse-grained parallelism, as streaming applications (image, video, DSP, etc.) are naturally represented by independent filters that communicate over explicit data channels.In this paper, we demonstrate an end-to-end stream compiler that attains robust multicore performance in the face of varying application characteristics. As benchmarks exhibit different amounts of task, data, and pipeline parallelism, we exploit all types of parallelism in a unified manner in order to achieve this generality. Our compiler, which maps from the StreamIt language to the 16-core Raw architecture, attains a 11.2x mean speedup over a single-core baseline, and a 1.84x speedup over our previous work."
            },
            "slug": "Exploiting-coarse-grained-task,-data,-and-pipeline-Gordon-Thies",
            "title": {
                "fragments": [],
                "text": "Exploiting coarse-grained task, data, and pipeline parallelism in stream programs"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "This paper demonstrates an end-to-end stream compiler that attains robust multicore performance in the face of varying application characteristics and exploits all types of parallelism in a unified manner in order to achieve this generality."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS XII"
            },
            "year": 2006
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3390646"
                        ],
                        "name": "Prasanth Chatarasi",
                        "slug": "Prasanth-Chatarasi",
                        "structuredName": {
                            "firstName": "Prasanth",
                            "lastName": "Chatarasi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Prasanth Chatarasi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3132400"
                        ],
                        "name": "J. Shirako",
                        "slug": "J.-Shirako",
                        "structuredName": {
                            "firstName": "Jun",
                            "lastName": "Shirako",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Shirako"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1728219"
                        ],
                        "name": "Vivek Sarkar",
                        "slug": "Vivek-Sarkar",
                        "structuredName": {
                            "firstName": "Vivek",
                            "lastName": "Sarkar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Vivek Sarkar"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 44
                            }
                        ],
                        "text": "On one side, we find sophisticated analyses [16, 27, 41, 42, 55, 56], centered on dependency analysis of affine loop nests in low-level imperative languages such as C and Fortran."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 105
                            }
                        ],
                        "text": "For example, OpenMP annotations can be used to enable transformations of otherwise unanalyzable patterns [16], while PENCIL [3] provides a restricted C99-like low-level language that allows the (expert) user to express the parallelism of loops and provide additional information about memory access patterns and dependencies."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 9147195,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b6a9c85cbf2d2d966cc9187d22bbfbad5f19ef44",
            "isKey": false,
            "numCitedBy": 23,
            "numCiting": 43,
            "paperAbstract": {
                "fragments": [],
                "text": "The polyhedral model is a powerful algebraic framework that has enabled significant advances to analysis and transformation of sequential affine (sub)programs, relative to traditional AST-based approaches. However, given the rapid growth of parallel software, there is a need for increased attention to using polyhedral frameworks to optimize explicitly parallel programs. An interesting side effect of supporting explicitly parallel programs is that doing so can also enable optimization of programs with unanalyzable data accesses within a polyhedral framework. In this paper, we address the problem of extending polyhedral frameworks to enable analysis and transformation of programs that contain both explicit parallelism and unanalyzable data accesses. As a first step, we focus on OpenMP loop parallelism and task parallelism, including task dependences from OpenMP 4.0. Our approach first enables conservative dependence analysis of a given region of code. Next, we identify happens-before relations from the explicitly parallel constructs, such as tasks and parallel loops, and intersect them with the conservative dependences. Finally, the resulting set of dependences is passed on to a polyhedral optimizer, such as PLuTo and PolyAST, to enable transformation of explicitly parallel programs with unanalyzable data accesses. We evaluate our approach using eleven OpenMP benchmark programs from the KASTORS and Rodinia benchmark suites. We show that 1) these benchmarks contain unanalyzable data accesses that prevent polyhedral frameworks from performing exact dependence analysis, 2) explicit parallelism can help mitigate the imprecision, and 3) polyhedral transformations with the resulting dependences can further improve the performance of the manually-parallelized OpenMP benchmarks. Our experimental results show geometric mean performance improvements of 1.62x and 2.75x on the Intel Westmere and IBM Power8 platforms respectively (relative to the original OpenMP versions)."
            },
            "slug": "Polyhedral-Optimizations-of-Explicitly-Parallel-Chatarasi-Shirako",
            "title": {
                "fragments": [],
                "text": "Polyhedral Optimizations of Explicitly Parallel Programs"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "This paper addresses the problem of extending polyhedral frameworks to enable analysis and transformation of programs that contain both explicit parallelism and unanalyzable data accesses and demonstrates how polyhedral transformations with the resulting dependences can further improve the performance of the manually-parallelized OpenMP benchmarks."
            },
            "venue": {
                "fragments": [],
                "text": "2015 International Conference on Parallel Architecture and Compilation (PACT)"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1691763"
                        ],
                        "name": "Amir Hormati",
                        "slug": "Amir-Hormati",
                        "structuredName": {
                            "firstName": "Amir",
                            "lastName": "Hormati",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Amir Hormati"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35638147"
                        ],
                        "name": "M. Samadi",
                        "slug": "M.-Samadi",
                        "structuredName": {
                            "firstName": "Mehrzad",
                            "lastName": "Samadi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Samadi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2364269"
                        ],
                        "name": "M. Woh",
                        "slug": "M.-Woh",
                        "structuredName": {
                            "firstName": "Mark",
                            "lastName": "Woh",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Woh"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751516"
                        ],
                        "name": "T. Mudge",
                        "slug": "T.-Mudge",
                        "structuredName": {
                            "firstName": "Trevor",
                            "lastName": "Mudge",
                            "middleNames": [
                                "N."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Mudge"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1721289"
                        ],
                        "name": "S. Mahlke",
                        "slug": "S.-Mahlke",
                        "structuredName": {
                            "firstName": "Scott",
                            "lastName": "Mahlke",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Mahlke"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 107,
                                "start": 103
                            }
                        ],
                        "text": "StreamIt supports a number of static optimizations on various hardware, for example, GPU optimizations [34] include memory-layout selection (shared/global memory), resolving shared-memory bank conflicts, increasing the granularity of parallelism by vertical fusion, and untilizing unused registers by software prefetching and loop unrolling, while multicore optimizations [25] are aimed at finding the right mix of task, data and pipeline parallelism."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 10566768,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "4cc2718ec7101f2fee29015ebadcbcdafab9781b",
            "isKey": false,
            "numCitedBy": 89,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "Graphics processing units (GPUs) provide a low cost platform for accelerating high performance computations. The introduction of new programming languages, such as CUDA and OpenCL, makes GPU programming attractive to a wide variety of programmers. However, programming GPUs is still a cumbersome task for two primary reasons: tedious performance optimizations and lack of portability. First, optimizing an algorithm for a specific GPU is a time-consuming task that requires a thorough understanding of both the algorithm and the underlying hardware. Unoptimized CUDA programs typically only achieve a small fraction of the peak GPU performance. Second, GPU code lacks efficient portability as code written for one GPU can be inefficient when executed on another. Moving code from one GPU to another while maintaining the desired performance is a non-trivial task often requiring significant modifications to account for the hardware differences. In this work, we propose Sponge, a compilation framework for GPUs using synchronous data flow streaming languages. Sponge is capable of performing a wide variety of optimizations to generate efficient code for graphics engines. Sponge alleviates the problems associated with current GPU programming methods by providing portability across different generations of GPUs and CPUs, and a better abstraction of the hardware details, such as the memory hierarchy and threading model. Using streaming, we provide a write-once software paradigm and rely on the compiler to automatically create optimized CUDA code for a wide variety of GPU targets. Sponge's compiler optimizations improve the performance of the baseline CUDA implementations by an average of 3.2x."
            },
            "slug": "Sponge:-portable-stream-programming-on-graphics-Hormati-Samadi",
            "title": {
                "fragments": [],
                "text": "Sponge: portable stream programming on graphics engines"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "Sponge alleviates the problems associated with current GPU programming methods by providing portability across different generations of GPUs and CPUs, and a better abstraction of the hardware details, such as the memory hierarchy and threading model."
            },
            "venue": {
                "fragments": [],
                "text": "ASPLOS XVI"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2107761326"
                        ],
                        "name": "S. P. Jones",
                        "slug": "S.-P.-Jones",
                        "structuredName": {
                            "firstName": "Simon",
                            "lastName": "Jones",
                            "middleNames": [
                                "L.",
                                "Peyton"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. P. Jones"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1798897"
                        ],
                        "name": "Will Partain",
                        "slug": "Will-Partain",
                        "structuredName": {
                            "firstName": "Will",
                            "lastName": "Partain",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Will Partain"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144772155"
                        ],
                        "name": "Andr\u00e9 L. M. Santos",
                        "slug": "Andr\u00e9-L.-M.-Santos",
                        "structuredName": {
                            "firstName": "Andr\u00e9",
                            "lastName": "Santos",
                            "middleNames": [
                                "L.",
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Andr\u00e9 L. M. Santos"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 96,
                                "start": 92
                            }
                        ],
                        "text": "scalar computations, the let-expressions are rearranged using a combination of let-floating [43] and tupling for grouping together scalar code in a single let-construct."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 1618422,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "cd0f71fbac4a7921a673bde9083ac0a5c597e119",
            "isKey": false,
            "numCitedBy": 98,
            "numCiting": 42,
            "paperAbstract": {
                "fragments": [],
                "text": "Virtually every compiler performs transformations on the program it is compiling in an attempt to improve efficiency. Despite their importance, however, there have been few systematic attempts to categorise such transformations and measure their impact.In this paper we describe a particular group of transformations --- the \"let-floating\" transformations --- and give detailed measurements of their effect in an optimizing compiler for the non-strict functional language Haskell. Let-floating has not received much explicit attention in the past, but our measurements show that it is an important group of transformations (at least for lazy languages), offering a reduction of more than 30% in heap allocation and 15% in execution time."
            },
            "slug": "Let-floating:-moving-bindings-to-give-faster-Jones-Partain",
            "title": {
                "fragments": [],
                "text": "Let-floating: moving bindings to give faster programs"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "Let-floating has not received much explicit attention in the past, but measurements show that it is an important group of transformations (at least for lazy languages), offering a reduction of more than 30% in heap allocation and 15% in execution time."
            },
            "venue": {
                "fragments": [],
                "text": "ICFP '96"
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2965025"
                        ],
                        "name": "Troels Henriksen",
                        "slug": "Troels-Henriksen",
                        "structuredName": {
                            "firstName": "Troels",
                            "lastName": "Henriksen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Troels Henriksen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 365,
                                "start": 361
                            }
                        ],
                        "text": "For example, the array [[4],[1,0]] is illegal; when static verification fails\u2014for example because we cannot determine in general whether all iterations of a map produce a value of the same shape\u2014dynamic checks (much like bounds checks) are automatically inserted inside the map, but they can often be sliced/hoisted out of the map itself and checked in advance [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 1589917,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "b4d77a72ea8c482f30b3d36cba5915c1f8d1e936",
            "isKey": false,
            "numCitedBy": 18,
            "numCiting": 26,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents an analysis for bounds checking of array subscripts that lifts checking assertions to program level under the form of an arbitrarily-complex predicate (inspector), whose runtime evaluation guards the execution of the code of interest. Separating the predicate from the computation makes it more amenable to optimization, and allows it to be split into a cascade of sufficient conditions of increasing complexity that optimizes the common-inspection path. While synthesizing the bounds checking invariant resembles type checking techniques, we rely on compiler simplification and runtime evaluation rather than employing complex inference and annotation systems that might discourage the non-specialist user. We integrate the analysis in the compiler's repertoire of Futhark: a purely-functional core language supporting map-reduce nested parallelism on regular arrays, and show how the high-level language invariants enable a relatively straightforward analysis. Finally, we report a qualitative evaluation of our technique on three real-world applications from the financial domain that indicates that the runtime overhead of predicates is negligible."
            },
            "slug": "Bounds-Checking:-An-Instance-of-Hybrid-Analysis-Henriksen-Oancea",
            "title": {
                "fragments": [],
                "text": "Bounds Checking: An Instance of Hybrid Analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 91,
                "text": "An analysis for bounds checking of array subscripts that lifts checking assertions to program level under the form of an arbitrarily-complex predicate (inspector), whose runtime evaluation guards the execution of the code of interest."
            },
            "venue": {
                "fragments": [],
                "text": "ARRAY@PLDI"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1683544"
                        ],
                        "name": "J. Auerbach",
                        "slug": "J.-Auerbach",
                        "structuredName": {
                            "firstName": "Joshua",
                            "lastName": "Auerbach",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Auerbach"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1678228"
                        ],
                        "name": "D. Bacon",
                        "slug": "D.-Bacon",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Bacon",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Bacon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35977213"
                        ],
                        "name": "P. Cheng",
                        "slug": "P.-Cheng",
                        "structuredName": {
                            "firstName": "Perry",
                            "lastName": "Cheng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Cheng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714477"
                        ],
                        "name": "R. Rabbah",
                        "slug": "R.-Rabbah",
                        "structuredName": {
                            "firstName": "Rodric",
                            "lastName": "Rabbah",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Rabbah"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 24,
                                "start": 21
                            }
                        ],
                        "text": "Delite [51] and Lime [2] are impure languages that use effect systems to ensure that side effects cannot inhibit safe parallelisation, although Delite does permit a potentially unsafe parallel foreach."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 95
                            }
                        ],
                        "text": "On the other side, there are a number of embedded (morally functional) data-parallel languages [2, 15, 35, 48, 51, 52] that express parallelism explicitly by means of bulk operators, which allow the compiler to reason at a higher level about restructuring the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 11417090,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "907d2c011942a78bf6acff8e048f4185d53ff8f2",
            "isKey": false,
            "numCitedBy": 166,
            "numCiting": 39,
            "paperAbstract": {
                "fragments": [],
                "text": "The halt in clock frequency scaling has forced architects and language designers to look elsewhere for continued improvements in performance. We believe that extracting maximum performance will require compilation to highly heterogeneous architectures that include reconfigurable hardware. We present a new language, Lime, which is designed to be executable across a broad range of architectures, from FPGAs to conventional CPUs. We present the language as a whole, focusing on its novel features for limiting side-effects and integration of the streaming paradigm into an object- oriented language. We conclude with some initial results demonstrating applications running either on a CPU or co- executing on a CPU and an FPGA."
            },
            "slug": "Lime:-a-Java-compatible-and-synthesizable-language-Auerbach-Bacon",
            "title": {
                "fragments": [],
                "text": "Lime: a Java-compatible and synthesizable language for heterogeneous architectures"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A new language, Lime, is presented, which is designed to be executable across a broad range of architectures, from FPGAs to conventional CPUs, and focuses on its novel features for limiting side-effects and integration of the streaming paradigm into an object- oriented language."
            },
            "venue": {
                "fragments": [],
                "text": "OOPSLA"
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1689939"
                        ],
                        "name": "L. Rauchwerger",
                        "slug": "L.-Rauchwerger",
                        "structuredName": {
                            "firstName": "Lawrence",
                            "lastName": "Rauchwerger",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Rauchwerger"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 109,
                                "start": 105
                            }
                        ],
                        "text": "For example, in an imperative setting, it is difficult to recognize scan and filter implemented as loops [42], or to encode strengthreduction invariants and achieve the fusion result of Figure 10c."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 68,
                                "start": 44
                            }
                        ],
                        "text": "On one side, we find sophisticated analyses [16, 27, 41, 42, 55, 56], centered on dependency analysis of affine loop nests in low-level imperative languages such as C and Fortran."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 448700,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "905643448927cce1b60daad3cc68307137426386",
            "isKey": false,
            "numCitedBy": 7,
            "numCiting": 26,
            "paperAbstract": {
                "fragments": [],
                "text": "Subscripts using induction variables that cannot be expressed as a formula in terms of the enclosing-loop indices appear in the low-level implementation of common programming abstractions such as Alter, or stack operations and pose significant challenges to automatic parallelization. Because the complexity of such induction variables is often due to their conditional evaluation across the iteration space of loops we name them Conditional Induction Variables (CIV). This paper presents a flow-sensitive technique that summarizes both such CIV-based and affine subscripts to program level, using the same representation. Our technique requires no modifications of our dependence tests, which is agnostic to the original shape of the subscripts, and is more powerful than previously reported dependence tests that rely on the pairwise disambiguation of read-write references. We have implemented the CIV analysis in our parallelizing compiler and evaluated its impact on five Fortran benchmarks. We have found that that there are many important loops using CIV subscripts and that our analysis can lead to their scalable parallelization. This in turn has led to the parallelization of the benchmark programs they appear in."
            },
            "slug": "Scalable-conditional-induction-variables-(CIV)-Oancea-Rauchwerger",
            "title": {
                "fragments": [],
                "text": "Scalable conditional induction variables (CIV) analysis"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "A flow-sensitive technique that summarizes both CIV-based and affine subscripts to program level, using the same representation, and is more powerful than previously reported dependence tests that rely on the pairwise disambiguation of read-write references."
            },
            "venue": {
                "fragments": [],
                "text": "2015 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "32423266"
                        ],
                        "name": "Ananya Kumar",
                        "slug": "Ananya-Kumar",
                        "structuredName": {
                            "firstName": "Ananya",
                            "lastName": "Kumar",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ananya Kumar"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717462"
                        ],
                        "name": "G. Blelloch",
                        "slug": "G.-Blelloch",
                        "structuredName": {
                            "firstName": "Guy",
                            "lastName": "Blelloch",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Blelloch"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144141297"
                        ],
                        "name": "R. Harper",
                        "slug": "R.-Harper",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "Harper",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Harper"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 18,
                                "start": 14
                            }
                        ],
                        "text": "Previous work [37] presents a data structure for functional arrays with asymptotically-efficient in-place updates and parallel semantics, but without requiring a type system extension."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 15949041,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "225877e8adee6d39ae252a5af7461143fa58fe6c",
            "isKey": false,
            "numCitedBy": 3,
            "numCiting": 29,
            "paperAbstract": {
                "fragments": [],
                "text": "The goal of this paper is to develop a form of functional arrays (sequences) that are as efficient as imperative arrays, can be used in parallel, and have well defined cost-semantics. The key idea is to consider sequences with functional value semantics but non-functional cost semantics. Because the value semantics is functional, \"updating\" a sequence returns a new sequence. We allow operations on \"older\" sequences (called interior sequences) to be more expensive than operations on the \"most recent\" sequences (called leaf sequences). We embed sequences in a language supporting fork-join parallelism. Due to the parallelism, operations can be interleaved non-deterministically, and, in conjunction with the different cost for interior and leaf sequences, this can lead to non-deterministic costs for a program. Consequently the costs of programs can be difficult to analyze. The main result is the derivation of a deterministic cost dynamics which makes analyzing the costs easier. The theorems are not specific to sequences and can be applied to other data types with different costs for operating on interior and leaf versions. We present a wait-free concurrent implementation of sequences that requires constant work for accessing and updating leaf sequences, and logarithmic work for accessing and linear work for updating interior sequences. We sketch a proof of correctness for the sequence implementation. The key advantages of the present approach compared to current approaches is that our implementation requires no changes to existing programming languages, supports nested parallelism, and has well defined cost semantics. At the same time, it allows for functional implementations of algorithms such as depth-first search with the same asymptotic complexity as imperative implementations."
            },
            "slug": "Parallel-functional-arrays-Kumar-Blelloch",
            "title": {
                "fragments": [],
                "text": "Parallel functional arrays"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "The goal of this paper is to develop a form of functional arrays (sequences) that are as efficient as imperative arrays, can be used in parallel, and have well defined cost-semantics."
            },
            "venue": {
                "fragments": [],
                "text": "POPL"
            },
            "year": 2017
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2674930"
                        ],
                        "name": "Jesse A. Tov",
                        "slug": "Jesse-A.-Tov",
                        "structuredName": {
                            "firstName": "Jesse",
                            "lastName": "Tov",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jesse A. Tov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1716161"
                        ],
                        "name": "Riccardo Pucella",
                        "slug": "Riccardo-Pucella",
                        "structuredName": {
                            "firstName": "Riccardo",
                            "lastName": "Pucella",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Riccardo Pucella"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 77,
                                "start": 69
                            }
                        ],
                        "text": "The contribution is not in linear-type theory (more powerful systems [24, 54] exist), but rather in designing a simple system that does not overcomplicate analysis."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 74,
                                "start": 70
                            }
                        ],
                        "text": "More elaborate and powerful uniqueness [4, 5], linear [24] and affine [54] type systems than Futhark\u2019s exist."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14321915,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "9de322bac5c6223486230e07ada50ddf2aa7a6b9",
            "isKey": false,
            "numCitedBy": 80,
            "numCiting": 34,
            "paperAbstract": {
                "fragments": [],
                "text": "Alms is a general-purpose programming language that supports practical affine types. To offer the expressiveness of Girard's linear logic while keeping the type system light and convenient, Alms uses expressive kinds that minimize notation while maximizing polymorphism between affine and unlimited types.\n A key feature of Alms is the ability to introduce abstract affine types via ML-style signature ascription. In Alms, an interface can impose stiffer resource usage restrictions than the principal usage restrictions of its implementation. This form of sealing allows the type system to naturally and directly express a variety of resource management protocols from special-purpose type systems.\n We present two pieces of evidence to demonstrate the validity of our design goals. First, we introduce a prototype implementation of Alms and discuss our experience programming in the language. Second, we establish the soundness of the core language. We also use the core model to prove a principal kinding theorem."
            },
            "slug": "Practical-affine-types-Tov-Pucella",
            "title": {
                "fragments": [],
                "text": "Practical affine types"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This work introduces a prototype implementation of Alms, and establishes the soundness of the core language, and uses the core model to prove a principal kinding theorem."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '11"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "32837403"
                        ],
                        "name": "J. Bergstra",
                        "slug": "J.-Bergstra",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Bergstra",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Bergstra"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1967465"
                        ],
                        "name": "Olivier Breuleux",
                        "slug": "Olivier-Breuleux",
                        "structuredName": {
                            "firstName": "Olivier",
                            "lastName": "Breuleux",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Olivier Breuleux"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3227028"
                        ],
                        "name": "Fr\u00e9d\u00e9ric Bastien",
                        "slug": "Fr\u00e9d\u00e9ric-Bastien",
                        "structuredName": {
                            "firstName": "Fr\u00e9d\u00e9ric",
                            "lastName": "Bastien",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Fr\u00e9d\u00e9ric Bastien"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3087941"
                        ],
                        "name": "Pascal Lamblin",
                        "slug": "Pascal-Lamblin",
                        "structuredName": {
                            "firstName": "Pascal",
                            "lastName": "Lamblin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Pascal Lamblin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1996134"
                        ],
                        "name": "Razvan Pascanu",
                        "slug": "Razvan-Pascanu",
                        "structuredName": {
                            "firstName": "Razvan",
                            "lastName": "Pascanu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Razvan Pascanu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2755582"
                        ],
                        "name": "Guillaume Desjardins",
                        "slug": "Guillaume-Desjardins",
                        "structuredName": {
                            "firstName": "Guillaume",
                            "lastName": "Desjardins",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Guillaume Desjardins"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "153160559"
                        ],
                        "name": "Joseph P. Turian",
                        "slug": "Joseph-P.-Turian",
                        "structuredName": {
                            "firstName": "Joseph",
                            "lastName": "Turian",
                            "middleNames": [
                                "P."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Joseph P. Turian"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1393680089"
                        ],
                        "name": "David Warde-Farley",
                        "slug": "David-Warde-Farley",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Warde-Farley",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "David Warde-Farley"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751762"
                        ],
                        "name": "Yoshua Bengio",
                        "slug": "Yoshua-Bengio",
                        "structuredName": {
                            "firstName": "Yoshua",
                            "lastName": "Bengio",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Yoshua Bengio"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 105,
                                "start": 102
                            }
                        ],
                        "text": "Imperative solutions include Copperhead [14], Accelerator [53], and deeplearning DSLs, such as Theano [6] and Torch [20]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 3183121,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "63936fa32f9e75ab2a864daae6791ce02112183d",
            "isKey": false,
            "numCitedBy": 826,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "Theano is a compiler for mathematical expressions in Python that combines the convenience of NumPy's syntax with the speed of optimized native machine language. The user composes mathematical expressions in a high-level description that mimics NumPy's syntax and semantics, while being statically typed and functional (as opposed to imperative). These expressions allow Theano to provide symbolic differentiation. Before performing computation, Theano optimizes the choice of expressions, translates them into C++ (or CUDA for GPU), compiles them into dynamically loaded Python modules, all automatically. Common machine learn- ing algorithms implemented with Theano are from 1:6 to 7:5 faster than competitive alternatives (including those implemented with C/C++, NumPy/SciPy and MATLAB) when compiled for the CPU and between 6:5 and 44 faster when compiled for the GPU. This paper illustrates how to use Theano, outlines the scope of the compiler, provides benchmarks on both CPU and GPU processors, and explains its overall design."
            },
            "slug": "Theano:-A-CPU-and-GPU-Math-Compiler-in-Python-Bergstra-Breuleux",
            "title": {
                "fragments": [],
                "text": "Theano: A CPU and GPU Math Compiler in Python"
            },
            "tldr": {
                "abstractSimilarityScore": 40,
                "text": "This paper illustrates how to use Theano, outlines the scope of the compiler, provides benchmarks on both CPU and GPU processors, and explains its overall design."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2010
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1741655"
                        ],
                        "name": "Manuel F\u00e4hndrich",
                        "slug": "Manuel-F\u00e4hndrich",
                        "structuredName": {
                            "firstName": "Manuel",
                            "lastName": "F\u00e4hndrich",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Manuel F\u00e4hndrich"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1710751"
                        ],
                        "name": "R. DeLine",
                        "slug": "R.-DeLine",
                        "structuredName": {
                            "firstName": "Robert",
                            "lastName": "DeLine",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. DeLine"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 77,
                                "start": 69
                            }
                        ],
                        "text": "The contribution is not in linear-type theory (more powerful systems [24, 54] exist), but rather in designing a simple system that does not overcomplicate analysis."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 54
                            }
                        ],
                        "text": "More elaborate and powerful uniqueness [4, 5], linear [24] and affine [54] type systems than Futhark\u2019s exist."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 796767,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "d2091d8550cf11d09b71ebdca9852d905563bee6",
            "isKey": false,
            "numCitedBy": 305,
            "numCiting": 20,
            "paperAbstract": {
                "fragments": [],
                "text": "A type system with linearity is useful for checking software protocols andresource management at compile time. Linearity provides powerful reasoning about state changes, but at the price of restrictions on aliasing. The hard division between linear and nonlinear types forces the programmer to make a trade-off between checking a protocol on an object and aliasing the object. Most onerous is the restriction that any type with a linear component must itself be linear. Because of this, checking a protocol on an object imposes aliasing restrictions on any data structure that directly or indirectly points to the object. We propose a new type system that reduces these restrictions with the adoption and focus constructs. Adoption safely allows a programmer to alias objects on which she is checking protocols, and focus allows the reverse. A programmer can alias data structures that point to linear objects and use focus for safe access to those objects. We discuss how we implemented these ideas in the Vault programming language."
            },
            "slug": "Adoption-and-focus:-practical-linear-types-for-F\u00e4hndrich-DeLine",
            "title": {
                "fragments": [],
                "text": "Adoption and focus: practical linear types for imperative programming"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "A new type system that reduces restrictions on aliasing with the adoption and focus constructs is proposed, which safely allows a programmer to alias objects on which she is checking protocols, and focus allows the reverse."
            },
            "venue": {
                "fragments": [],
                "text": "PLDI '02"
            },
            "year": 2002
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1756389"
                        ],
                        "name": "T. Grosser",
                        "slug": "T.-Grosser",
                        "structuredName": {
                            "firstName": "Tobias",
                            "lastName": "Grosser",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "T. Grosser"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1883512"
                        ],
                        "name": "Justin Holewinski",
                        "slug": "Justin-Holewinski",
                        "structuredName": {
                            "firstName": "Justin",
                            "lastName": "Holewinski",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Justin Holewinski"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293384"
                        ],
                        "name": "P. Sadayappan",
                        "slug": "P.-Sadayappan",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Sadayappan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Sadayappan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1772079"
                        ],
                        "name": "Sven Verdoolaege",
                        "slug": "Sven-Verdoolaege",
                        "structuredName": {
                            "firstName": "Sven",
                            "lastName": "Verdoolaege",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sven Verdoolaege"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 142,
                                "start": 138
                            }
                        ],
                        "text": "In comparison to Futhark, imperative analyses [55, 56] are superior at performing all kinds of tiling, for example hexagonal time tilling [26] and achieving memory coalescing by semantically transposing arrays on the fly (via tiling)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 57,
                                "start": 53
                            }
                        ],
                        "text": "Rodinia\u2019s implementation of HotSpot uses time tiling [26], which seems to pay off on the NVIDIA GPU, but not on AMD."
                    },
                    "intents": []
                }
            ],
            "corpusId": 14200644,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "618fa1c14e3c6008eb047002311d21cae412eebc",
            "isKey": false,
            "numCitedBy": 107,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "Time-tiling is necessary for the efficient execution of iterative stencil computations. Classical hyper-rectangular tiles cannot be used due to the combination of backward and forward dependences along space dimensions. Existing techniques trade temporal data reuse for inefficiencies in other areas, such as load imbalance, redundant computations, or increased control flow overhead, therefore making it challenging for use with GPUs.\n We propose a time-tiling method for iterative stencil computations on GPUs. Our method does not involve redundant computations. It favors coalesced global-memory accesses, data reuse in local/shared-memory or cache, avoidance of thread divergence, and concurrency, combining hexagonal tile shapes along the time and one spatial dimension with classical tiling along the other spatial dimensions. Hexagonal tiles expose multi-level parallelism as well as data reuse. Experimental results demonstrate significant performance improvements over existing stencil compilers."
            },
            "slug": "Hybrid-Hexagonal/Classical-Tiling-for-GPUs-Grosser-Cohen",
            "title": {
                "fragments": [],
                "text": "Hybrid Hexagonal/Classical Tiling for GPUs"
            },
            "tldr": {
                "abstractSimilarityScore": 47,
                "text": "A time-tiling method for iterative stencil computations on GPUs that favors coalesced global-memory accesses, data reuse in local/shared-memory or cache, avoidance of thread divergence, and concurrency, combining hexagonal tile shapes along the time and one spatial dimension with classical tiling along the other spatial dimensions is proposed."
            },
            "venue": {
                "fragments": [],
                "text": "CGO '14"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1793611"
                        ],
                        "name": "L. Pouchet",
                        "slug": "L.-Pouchet",
                        "structuredName": {
                            "firstName": "Louis-No\u00ebl",
                            "lastName": "Pouchet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "L. Pouchet"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1751936"
                        ],
                        "name": "Uday Bondhugula",
                        "slug": "Uday-Bondhugula",
                        "structuredName": {
                            "firstName": "Uday",
                            "lastName": "Bondhugula",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Uday Bondhugula"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1769333"
                        ],
                        "name": "C. Bastoul",
                        "slug": "C.-Bastoul",
                        "structuredName": {
                            "firstName": "C\u00e9dric",
                            "lastName": "Bastoul",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Bastoul"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145509576"
                        ],
                        "name": "Albert Cohen",
                        "slug": "Albert-Cohen",
                        "structuredName": {
                            "firstName": "Albert",
                            "lastName": "Cohen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Albert Cohen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145981817"
                        ],
                        "name": "J. Ramanujam",
                        "slug": "J.-Ramanujam",
                        "structuredName": {
                            "firstName": "J.",
                            "lastName": "Ramanujam",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Ramanujam"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145293384"
                        ],
                        "name": "P. Sadayappan",
                        "slug": "P.-Sadayappan",
                        "structuredName": {
                            "firstName": "P.",
                            "lastName": "Sadayappan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Sadayappan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1800919"
                        ],
                        "name": "Nicolas Vasilache",
                        "slug": "Nicolas-Vasilache",
                        "structuredName": {
                            "firstName": "Nicolas",
                            "lastName": "Vasilache",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Nicolas Vasilache"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 198,
                                "start": 190
                            }
                        ],
                        "text": "Imperative GPU compilation techniques rely on low-level index analysis ranging from pattern-matching heuristics [22, 56] to general modeling of affine transformations by polyhedral analysis [44, 55]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 13949046,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "493c0286a097005b626f8f978c6f475d3f05ca43",
            "isKey": false,
            "numCitedBy": 126,
            "numCiting": 65,
            "paperAbstract": {
                "fragments": [],
                "text": "High-level loop transformations are a key instrument in mapping computational kernels to effectively exploit the resources in modern processor architectures. Nevertheless, selecting required compositions of loop transformations to achieve this remains a significantly challenging task; current compilers may be off by orders of magnitude in performance compared to hand-optimized programs. To address this fundamental challenge, we first present a convex characterization of all distinct, semantics-preserving, multidimensional affine transformations. We then bring together algebraic, algorithmic, and performance analysis results to design a tractable optimization algorithm over this highly expressive space. Our framework has been implemented and validated experimentally on a representative set of benchmarks running on state-of-the-art multi-core platforms."
            },
            "slug": "Loop-transformations:-convexity,-pruning-and-Pouchet-Bondhugula",
            "title": {
                "fragments": [],
                "text": "Loop transformations: convexity, pruning and optimization"
            },
            "tldr": {
                "abstractSimilarityScore": 41,
                "text": "This work first presents a convex characterization of all distinct, semantics-preserving, multidimensional affine transformations, then brings together algebraic, algorithmic, and performance analysis results to design a tractable optimization algorithm over this highly expressive space."
            },
            "venue": {
                "fragments": [],
                "text": "POPL '11"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1911509"
                        ],
                        "name": "M. Elsman",
                        "slug": "M.-Elsman",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Elsman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Elsman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3311458"
                        ],
                        "name": "M. Dybdal",
                        "slug": "M.-Dybdal",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Dybdal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Dybdal"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 47
                            }
                        ],
                        "text": "Such a usage was demonstrated by an experiment [23, 31] in which a subset of APL was compiled to Futhark, executed on GPU, and used from Python for visualization purposes."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 9538419,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "edba3503214cff319dbe23a9871d322265d18d3f",
            "isKey": false,
            "numCitedBy": 18,
            "numCiting": 30,
            "paperAbstract": {
                "fragments": [],
                "text": "We present a compiler and a typed intermediate language for a subset of APL. The intermediate language treats all numeric data as multi-dimensional arrays and the type system makes explicit the ranks of arrays. Primitive operators are polymorphic in rank and in the type of the underlying data operated on. The frontend of the APL compiler deals with much of the gory details of the APL language, including infix resolution, resolution of identity items for reduce operations, resolution of default element values for empty arrays, scalar extensions, and resolution of certain kinds of overloading. We demonstrate the usefulness of the intermediate language by showing that it can be compiled efficiently, using known techniques, such as delayed arrays, into a C-like language. We also demonstrate that the language is sufficiently expressive that some primitive operators, such as APL's inner product operator, which works on arrays of arbitrary dimensions, can be compiled using more primitive operators."
            },
            "slug": "Compiling-a-Subset-of-APL-Into-a-Typed-Intermediate-Elsman-Dybdal",
            "title": {
                "fragments": [],
                "text": "Compiling a Subset of APL Into a Typed Intermediate Language"
            },
            "tldr": {
                "abstractSimilarityScore": 63,
                "text": "This work presents a compiler and a typed intermediate language for a subset of APL that is sufficiently expressive that some primitive operators, such as APL's inner product operator, can be compiled using more primitive operators."
            },
            "venue": {
                "fragments": [],
                "text": "ARRAY@PLDI"
            },
            "year": 2014
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1773596"
                        ],
                        "name": "J. Stratton",
                        "slug": "J.-Stratton",
                        "structuredName": {
                            "firstName": "John",
                            "lastName": "Stratton",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Stratton"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2012705"
                        ],
                        "name": "C. Rodrigues",
                        "slug": "C.-Rodrigues",
                        "structuredName": {
                            "firstName": "Christopher",
                            "lastName": "Rodrigues",
                            "middleNames": [
                                "I."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Rodrigues"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "38699517"
                        ],
                        "name": "I-Jui Sung",
                        "slug": "I-Jui-Sung",
                        "structuredName": {
                            "firstName": "I-Jui",
                            "lastName": "Sung",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "I-Jui Sung"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2409502"
                        ],
                        "name": "N. Obeid",
                        "slug": "N.-Obeid",
                        "structuredName": {
                            "firstName": "Nady",
                            "lastName": "Obeid",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Obeid"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48319011"
                        ],
                        "name": "Li-Wen Chang",
                        "slug": "Li-Wen-Chang",
                        "structuredName": {
                            "firstName": "Li-Wen",
                            "lastName": "Chang",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Li-Wen Chang"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "48798569"
                        ],
                        "name": "N. Anssari",
                        "slug": "N.-Anssari",
                        "structuredName": {
                            "firstName": "Nasser",
                            "lastName": "Anssari",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "N. Anssari"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2109614818"
                        ],
                        "name": "Geng Liu",
                        "slug": "Geng-Liu",
                        "structuredName": {
                            "firstName": "Geng",
                            "lastName": "Liu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Geng Liu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "143668320"
                        ],
                        "name": "W. Hwu",
                        "slug": "W.-Hwu",
                        "structuredName": {
                            "firstName": "Wen-mei",
                            "lastName": "Hwu",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "W. Hwu"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 134,
                                "start": 127
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0.6\u00d7 (slower) on FinPar\u2019s LocVolCalib benchmark to 16\u00d7 (faster) on Rodinia\u2019s NN benchmark."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 139,
                                "start": 135
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 79,
                                "start": 72
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark.10 The three former consist of handwritten OpenCL programs, while Accelerate is an established Haskell DSL for GPU computation."
                    },
                    "intents": []
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 84,
                                "start": 80
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 87,
                                "start": 80
                            }
                        ],
                        "text": "Our speedup on K-means is due to Ro-\n10 We have selected the MRI-Q benchmark from Parboil mainly to demonstrate tiling."
                    },
                    "intents": []
                }
            ],
            "corpusId": 497928,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "5f3cce1bc739ebfc03e003010d3438bb318efc14",
            "isKey": true,
            "numCitedBy": 667,
            "numCiting": 17,
            "paperAbstract": {
                "fragments": [],
                "text": "The Parboil benchmarks are a set of throughput computing applications useful for studying the performance of throughput computing architecture and compilers. The name comes from the culinary term for a partial cooking process, which represents our belief that useful throughput computing benchmarks must be \u201ccooked\u201d, or preselected to implement a scalable algorithm with fine-grained paralle l tasks. But useful benchmarks for this field cannot be \u201cfully cooked\u201d, because the architectures and programming models and supporting tools are evolving rapidly enough that static benchmark codes will lose relevance very quickly. We have collected benchmarks from throughput computing application researchers in many different scientific and commercial fields including image processing, biomolec ular simulation, fluid dynamics, and astronomy. Each benchmark includes several implementations. Some implementations we provide as readable base implementations from which new optimization efforts can begin, and others as examples of the current state-of-the-art targeting specific CPU and GPU architectures. As we continue to optimiz e these benchmarks for new and existing architectures ourselves, we will also gladly accept new implementations and benchmark contributions from developers to recognize those at the frontier of performance optimization on each architecture. Finally, by including versions of varying levels of optimization of the same fundamental algorithm, the benchmarks present opportunities to demonstrate tools and architectures that help programmers get the most out of their parallel hardware. Less optimized versions are presented as challenges to the compiler and architecture research communities: to develop the technology that automatically raises the performance of simpler implementations to the performance level of sophisticated programmer-optimized implementations, or demonstrate any other performance or programmability improvements. We hope that these benchmarks will facilitate effective demonstrations of such technology."
            },
            "slug": "Parboil:-A-Revised-Benchmark-Suite-for-Scientific-Stratton-Rodrigues",
            "title": {
                "fragments": [],
                "text": "Parboil: A Revised Benchmark Suite for Scientific and Commercial Throughput Computing"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "By including versions of varying levels of optimization of the same fundamental algorithm, the Parboil benchmarks present opportunities to demonstrate tools and architectures that help programmers get the most out of their parallel hardware."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1897982"
                        ],
                        "name": "Bo Joel Svensson",
                        "slug": "Bo-Joel-Svensson",
                        "structuredName": {
                            "firstName": "Bo",
                            "lastName": "Svensson",
                            "middleNames": [
                                "Joel"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Bo Joel Svensson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 135,
                                "start": 123
                            }
                        ],
                        "text": "The downside is that some of these languages do not support inplace updates or explicit indexing inside parallel operators [15, 48, 52], and none of them systematically utilizes (imperfectly) nested parallelism."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 95
                            }
                        ],
                        "text": "On the other side, there are a number of embedded (morally functional) data-parallel languages [2, 15, 35, 48, 51, 52] that express parallelism explicitly by means of bulk operators, which allow the compiler to reason at a higher level about restructuring the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 61600974,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "72c9c373a71f97f8873bc028b8034c909bb37d4c",
            "isKey": false,
            "numCitedBy": 23,
            "numCiting": 43,
            "paperAbstract": {
                "fragments": [],
                "text": "Graphics Processing Units (GPUs) are evolving into powerful general purpose computing platforms. At first, GPU performance was driven by the requirements of 3D graphics computer games. To fit this workload, a GPU is a many-core processor suitable for the data-parallel programming paradigm. Today, GPUs come with hundreds of processing elements and a theoretical single precision floating point performance in the teraflop range. \nBecause of the computing power of modern GPUs, programmers are increasingly inter- ested in making use of them for non-graphics applications. This desire has given rise to the research field that studies General Purpose Computations on GPUs (GPGPU). The manufacturers of GPUs are also acknowledging this trend and are tailoring their GPUs to meet both the desires of those playing games and the GPGPU community. \nCUDA is NVIDIA\u2019s tool-set for GPGPU programming on their GPUs. CUDA is a big improvement for the GPGPU programmer compared to what was available before. In the early days, the GPGPU programmer was forced to express the algorithm being im- plemented as a computer graphics computation. CUDA provides a C compiler and a set of libraries for general purpose programming on the GPU, freeing the programmer from graphics APIs. In CUDA, the programmer decomposes the problem into a set of kernels. A kernel is an isolated data-parallel program executed by a number of threads on the GPU. CUDA has some problems. For example, CUDA is a very low level interface to the GPU capabilities and there is also the issue that CUDA kernels are not easily composable. \nObsidian is an embedded language for implementing kernels in the functional programming language Haskell. From higher level descriptions of algorithms based on combinators, CUDA code is generated. Using this approach, Obsidian kernels are more compositional and also relieve the programmer from inventing the typically complex index arithmetic expressions that are used to load and store data in data-parallel algorithms. The indexing arithmetic is hidden away from the programmer in the set of combinators provided as a library. \nThe performance obtained from the kernels generated using Obsidian is decent. It does not compare to optimized handwritten code but if the implementation effort is taken into consideration performance is good. Obsidian allows the programmer to think about the problem at hand, rather than being weighed down by the lower level details. \nIn this thesis, two different implementations of Obsidian are shown. The first of these implementations is based on monads and the second on arrows, two concepts familiar to functional programmers. A number of applications are presented, expressed using the arrow based version."
            },
            "slug": "Obsidian:-GPU-Kernel-Programming-in-Haskell-Svensson",
            "title": {
                "fragments": [],
                "text": "Obsidian: GPU Kernel Programming in Haskell"
            },
            "tldr": {
                "abstractSimilarityScore": 43,
                "text": "Obsidian is an embedded language for implementing kernels in the functional programming language Haskell that relieves the programmer from inventing the typically complex index arithmetic expressions that are used to load and store data in data-parallel algorithms."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717462"
                        ],
                        "name": "G. Blelloch",
                        "slug": "G.-Blelloch",
                        "structuredName": {
                            "firstName": "Guy",
                            "lastName": "Blelloch",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Blelloch"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 81,
                                "start": 77
                            }
                        ],
                        "text": "5 For example, a map-nest ending in a scan corresponds to a \u201csegmented\u201d scan [10], which is implemented as a scan with a modified (associative) operator."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 15020969,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3c019693f59a32bf2fe5e99e93372c2816705139",
            "isKey": false,
            "numCitedBy": 559,
            "numCiting": 51,
            "paperAbstract": {
                "fragments": [],
                "text": "A study of the effects of adding two scan primitives as unit-time primitives to PRAM (parallel random access machine) models is presented. It is shown that the primitives improve the asymptotic running time of many algorithms by an O(log n) factor, greatly simplifying the description of many algorithms, and are significantly easier to implement than memory references. It is argued that the algorithm designer should feel free to use these operations as if they were as cheap as a memory reference. The author describes five algorithms that clearly illustrate how the scan primitives can be used in algorithm design: a radix-sort algorithm, a quicksort algorithm, a minimum-spanning-tree algorithm, a line-drawing algorithm, and a merging algorithm. These all run on an EREW (exclusive read, exclusive write) PRAM with the addition of two scan primitives and are either simpler or more efficient than their pure PRAM counterparts. The scan primitives have been implemented in microcode on the Connection Machine system, are available in PARIS (the parallel instruction set of the machine). >"
            },
            "slug": "Scans-as-Primitive-Parallel-Operations-Blelloch",
            "title": {
                "fragments": [],
                "text": "Scans as Primitive Parallel Operations"
            },
            "tldr": {
                "abstractSimilarityScore": 96,
                "text": "A study of the effects of adding two scan primitives as unit-time primitives to PRAM (parallel random access machine) models is presented and it is shown that the primitives improve the asymptotic running time of many algorithms by an O(log n) factor, greatly simplifying the description of many technologies."
            },
            "venue": {
                "fragments": [],
                "text": "ICPP"
            },
            "year": 1987
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2965025"
                        ],
                        "name": "Troels Henriksen",
                        "slug": "Troels-Henriksen",
                        "structuredName": {
                            "firstName": "Troels",
                            "lastName": "Henriksen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Troels Henriksen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3311458"
                        ],
                        "name": "M. Dybdal",
                        "slug": "M.-Dybdal",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Dybdal",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Dybdal"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3460174"
                        ],
                        "name": "Henrik Urms",
                        "slug": "Henrik-Urms",
                        "structuredName": {
                            "firstName": "Henrik",
                            "lastName": "Urms",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Henrik Urms"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3462524"
                        ],
                        "name": "Anna Sofie Kiehn",
                        "slug": "Anna-Sofie-Kiehn",
                        "structuredName": {
                            "firstName": "Anna",
                            "lastName": "Kiehn",
                            "middleNames": [
                                "Sofie"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Anna Sofie Kiehn"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2075147212"
                        ],
                        "name": "Daniel Gavin",
                        "slug": "Daniel-Gavin",
                        "structuredName": {
                            "firstName": "Daniel",
                            "lastName": "Gavin",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Daniel Gavin"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3461183"
                        ],
                        "name": "Hjalte Abelskov",
                        "slug": "Hjalte-Abelskov",
                        "structuredName": {
                            "firstName": "Hjalte",
                            "lastName": "Abelskov",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Hjalte Abelskov"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1911509"
                        ],
                        "name": "M. Elsman",
                        "slug": "M.-Elsman",
                        "structuredName": {
                            "firstName": "M.",
                            "lastName": "Elsman",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Elsman"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1943909"
                        ],
                        "name": "C. Oancea",
                        "slug": "C.-Oancea",
                        "structuredName": {
                            "firstName": "Cosmin",
                            "lastName": "Oancea",
                            "middleNames": [
                                "Eugen"
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Oancea"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 55,
                                "start": 47
                            }
                        ],
                        "text": "Such a usage was demonstrated by an experiment [23, 31] in which a subset of APL was compiled to Futhark, executed on GPU, and used from Python for visualization purposes."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 8522809,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "82beaafe9aad86b01cdd1be5cdbbf9add9ada445",
            "isKey": false,
            "numCitedBy": 15,
            "numCiting": 18,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper demonstrates translation schemes by which programs written in a functional subset of APL can be compiled to code that is run efficiently on general purpose graphical processing units (GPGPUs). Furthermore, the generated programs can be straightforwardly interoperated with mainstream programming environments, such as Python, for example for purposes of visualization and user interaction. Finally, empirical evaluation shows that the GPGPU translation achieves speedups up to hundreds of times faster than sequential C compiled code."
            },
            "slug": "APL-on-GPUs:-a-TAIL-from-the-past,-scribbled-in-Henriksen-Dybdal",
            "title": {
                "fragments": [],
                "text": "APL on GPUs: a TAIL from the past, scribbled in Futhark"
            },
            "tldr": {
                "abstractSimilarityScore": 100,
                "text": "This paper demonstrates translation schemes by which programs written in a functional subset of APL can be compiled to code that is run efficiently on general purpose graphical processing units (GPGPUs)."
            },
            "venue": {
                "fragments": [],
                "text": "FHPC@ICFP"
            },
            "year": 2016
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1717462"
                        ],
                        "name": "G. Blelloch",
                        "slug": "G.-Blelloch",
                        "structuredName": {
                            "firstName": "Guy",
                            "lastName": "Blelloch",
                            "middleNames": [
                                "E."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "G. Blelloch"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [],
            "corpusId": 1610858,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "8b60de2f86b890a04ac59bebb0c9c104504feb1d",
            "isKey": false,
            "numCitedBy": 631,
            "numCiting": 167,
            "paperAbstract": {
                "fragments": [],
                "text": "\"Vector Models for Data-Parallel Computing \"describes a model of parallelism that extends and formalizes the Data-Parallel model on which the Connection Machine and other supercomputers are based. It presents many algorithms based on the model, ranging from graph algorithms to numerical algorithms, and argues that data-parallel models are not only practical and can be applied to a surprisingly wide variety of problems, they are also well suited for very-high-level languages and lead to a concise and clear description of algorithms and their complexity. Many of the author's ideas have been incorporated into the instruction set and into algorithms currently running on the Connection Machine.The book includes the definition of a parallel vector machine; an extensive description of the uses of the scan (also called parallel-prefix) operations; the introduction of segmented vector operations; parallel data structures for trees, graphs, and grids; many parallel computational-geometry, graph, numerical and sorting algorithms; techniques for compiling nested parallelism; a compiler for Paralation Lisp; and details on the implementation of the scan operations.Guy E. Blelloch is an Assistant Professor of Computer Science and a Principal Investigator with the Super Compiler and Advanced Language project at Carnegie Mellon University.Contents: Introduction. Parallel Vector Models. The Scan Primitives. Computational-Geometry Algorithms. Graph Algorithms. Numerical Algorithms. Languages and Compilers. Correction-Oriented Languages. Flattening Nested Parallelism. A Compiler for Paralation Lisp. Paralation-Lisp Code. The Scan Vector Model. Data Structures. Implementing Parallel Vector Models. Implementing the Scan Operations. Conclusions. Glossary."
            },
            "slug": "Vector-Models-for-Data-Parallel-Computing-Blelloch",
            "title": {
                "fragments": [],
                "text": "Vector Models for Data-Parallel Computing"
            },
            "tldr": {
                "abstractSimilarityScore": 66,
                "text": "A model of parallelism that extends and formalizes the Data-Parallel model on which the Connection Machine and other supercomputers are based is described, and it is argued that data-parallel models are not only practical and can be applied to a surprisingly wide variety of problems, they are also well suited for very-high-level languages and lead to a concise and clear description of algorithms and their complexity."
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 1990
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "11372918"
                        ],
                        "name": "Shuai Che",
                        "slug": "Shuai-Che",
                        "structuredName": {
                            "firstName": "Shuai",
                            "lastName": "Che",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Shuai Che"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144535607"
                        ],
                        "name": "Michael Boyer",
                        "slug": "Michael-Boyer",
                        "structuredName": {
                            "firstName": "Michael",
                            "lastName": "Boyer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Michael Boyer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "36758880"
                        ],
                        "name": "Jiayuan Meng",
                        "slug": "Jiayuan-Meng",
                        "structuredName": {
                            "firstName": "Jiayuan",
                            "lastName": "Meng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Jiayuan Meng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2924393"
                        ],
                        "name": "D. Tarjan",
                        "slug": "D.-Tarjan",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Tarjan",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Tarjan"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1733020"
                        ],
                        "name": "J. Sheaffer",
                        "slug": "J.-Sheaffer",
                        "structuredName": {
                            "firstName": "Jeremy",
                            "lastName": "Sheaffer",
                            "middleNames": [
                                "W."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Sheaffer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2144574990"
                        ],
                        "name": "Sang-Ha Lee",
                        "slug": "Sang-Ha-Lee",
                        "structuredName": {
                            "firstName": "Sang-Ha",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Sang-Ha Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1735065"
                        ],
                        "name": "K. Skadron",
                        "slug": "K.-Skadron",
                        "structuredName": {
                            "firstName": "Kevin",
                            "lastName": "Skadron",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Skadron"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 108,
                                "start": 104
                            }
                        ],
                        "text": "Finally, we present an evaluation of Futhark-generated OpenCL code on 16 benchmarks ported from Rodinia [17], Accelerate [39], Parboil [50], and FinPar [1], that demonstrates performance competitive to reference implementations on AMD and NVIDIA GPUs: speedup ranges from about 0."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 171,
                                "start": 167
                            }
                        ],
                        "text": "This section demonstrates several Futhark features, including in-place updates and the stream_red SOAC, and shows how they are used to implement efficiently Rodinia\u2019s [17] K-means clustering of n d-dimensional points, for arbitrary k, n, d > 0."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 54
                            }
                        ],
                        "text": "We have manually translated programs from the Rodinia [17], FinPar [1], Parboil [50], and Accelerate [15] benchmark suites to Futhark."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 206915521,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "419f49c47f6fddae7235fb7c72335bccc1a3b743",
            "isKey": false,
            "numCitedBy": 2448,
            "numCiting": 33,
            "paperAbstract": {
                "fragments": [],
                "text": "This paper presents and characterizes Rodinia, a benchmark suite for heterogeneous computing. To help architects study emerging platforms such as GPUs (Graphics Processing Units), Rodinia includes applications and kernels which target multi-core CPU and GPU platforms. The choice of applications is inspired by Berkeley's dwarf taxonomy. Our characterization shows that the Rodinia benchmarks cover a wide range of parallel communication patterns, synchronization techniques and power consumption, and has led to some important architectural insight, such as the growing importance of memory-bandwidth limitations and the consequent importance of data layout."
            },
            "slug": "Rodinia:-A-benchmark-suite-for-heterogeneous-Che-Boyer",
            "title": {
                "fragments": [],
                "text": "Rodinia: A benchmark suite for heterogeneous computing"
            },
            "tldr": {
                "abstractSimilarityScore": 44,
                "text": "This characterization shows that the Rodinia benchmarks cover a wide range of parallel communication patterns, synchronization techniques and power consumption, and has led to some important architectural insight, such as the growing importance of memory-bandwidth limitations and the consequent importance of data layout."
            },
            "venue": {
                "fragments": [],
                "text": "2009 IEEE International Symposium on Workload Characterization (IISWC)"
            },
            "year": 2009
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "40504399"
                        ],
                        "name": "J. Price",
                        "slug": "J.-Price",
                        "structuredName": {
                            "firstName": "James",
                            "lastName": "Price",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "J. Price"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1404541971"
                        ],
                        "name": "S. McIntosh-Smith",
                        "slug": "S.-McIntosh-Smith",
                        "structuredName": {
                            "firstName": "Simon",
                            "lastName": "McIntosh-Smith",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. McIntosh-Smith"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 25,
                                "start": 21
                            }
                        ],
                        "text": "The work on Oclgrind [45] has proven invaluable in the development of the Futhark compiler."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 19017414,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "034e9be98a1ea62764cad5d610e1dec7d86ba0f2",
            "isKey": false,
            "numCitedBy": 34,
            "numCiting": 10,
            "paperAbstract": {
                "fragments": [],
                "text": "We describe Oclgrind, a platform designed to enable the creation of developer tools for analysis and debugging of OpenCL programs. Oclgrind simulates how OpenCL kernels execute with respect to the OpenCL standard, adhering to the execution and memory models that it defines. A simple plugin interface allows developer tools to observe the simulation and collect execution information to provide useful analysis, or catch bugs that would be otherwise difficult to spot when running the application on a real device. We give details about the implementation of the simulator, and describe how it can be extended with plugins that provide useful developer tools. We also present several example use-cases that have already been created using this platform, motivated by real-world problems that OpenCL developers face."
            },
            "slug": "Oclgrind:-an-extensible-OpenCL-device-simulator-Price-McIntosh-Smith",
            "title": {
                "fragments": [],
                "text": "Oclgrind: an extensible OpenCL device simulator"
            },
            "tldr": {
                "abstractSimilarityScore": 42,
                "text": "Oclgrind simulates how OpenCL kernels execute with respect to the OpenCL standard, adhering to the execution and memory models that it defines."
            },
            "venue": {
                "fragments": [],
                "text": "IWOCL"
            },
            "year": 2015
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2189877"
                        ],
                        "name": "E. Barendsen",
                        "slug": "E.-Barendsen",
                        "structuredName": {
                            "firstName": "Erik",
                            "lastName": "Barendsen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Barendsen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2943414"
                        ],
                        "name": "S. Smetsers",
                        "slug": "S.-Smetsers",
                        "structuredName": {
                            "firstName": "Sjaak",
                            "lastName": "Smetsers",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Smetsers"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 45,
                                "start": 39
                            }
                        ],
                        "text": "More elaborate and powerful uniqueness [4, 5], linear [24] and affine [54] type systems than Futhark\u2019s exist."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 47,
                                "start": 41
                            }
                        ],
                        "text": "The extension builds on uniqueness types [4, 5] and is formalized, including alias analysis, by inference rules in Section 3."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 157,
                                "start": 151
                            }
                        ],
                        "text": "In-place updates are supported in Futhark through a typesystem feature called uniqueness types, which is similar to, but simpler than the one of Clean [4, 5], where the primary motivation is modeling IO."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 27,
                                "start": 24
                            }
                        ],
                        "text": "For example, the array [[4],[1,0]] is illegal; when static verification fails\u2014for example because we cannot determine in general whether all iterations of a map produce a value of the same shape\u2014dynamic checks (much like bounds checks) are automatically inserted inside the map, but they can often be sliced/hoisted out of the map itself and checked in advance [29]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 76,
                                "start": 70
                            }
                        ],
                        "text": "\u2022 The introduction of a simple type system (based on uniqueness types [4, 5]) supporting race-free in-place updates in a purely-functional, data-parallel language."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14189617,
            "fieldsOfStudy": [
                "Computer Science",
                "Mathematics"
            ],
            "id": "7e0b0f87f42f3f543af5f1a576082ea318ab8ca9",
            "isKey": true,
            "numCitedBy": 119,
            "numCiting": 26,
            "paperAbstract": {
                "fragments": [],
                "text": "In this paper we describe a Curry-like type system for graphs and extend it with uniqueness information to indicate that certain objects are only \u2018locally accessible\u2019. The correctness of type assignment guarantees that no external access on such an object will take place in the future. We prove that types are preserved under reduction (for both type systems) for a large class of rewrite systems. Adding uniqueness information provides a solution to two problems in implementations of functional languages: efficient space behaviour and interfacing with non-functional operations."
            },
            "slug": "Conventional-and-Uniqueness-Typing-in-Graph-Rewrite-Barendsen-Smetsers",
            "title": {
                "fragments": [],
                "text": "Conventional and Uniqueness Typing in Graph Rewrite Systems"
            },
            "tldr": {
                "abstractSimilarityScore": 69,
                "text": "A Curry-like type system for graphs is described and extended with uniqueness information to indicate that certain objects are only \u2018locally accessible\u2019 and it is proved that types are preserved under reduction for a large class of rewrite systems."
            },
            "venue": {
                "fragments": [],
                "text": "FSTTCS"
            },
            "year": 1993
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "145943815"
                        ],
                        "name": "E. Meijer",
                        "slug": "E.-Meijer",
                        "structuredName": {
                            "firstName": "Erik",
                            "lastName": "Meijer",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Meijer"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714906"
                        ],
                        "name": "M. Fokkinga",
                        "slug": "M.-Fokkinga",
                        "structuredName": {
                            "firstName": "Maarten",
                            "lastName": "Fokkinga",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "M. Fokkinga"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144478079"
                        ],
                        "name": "R. Paterson",
                        "slug": "R.-Paterson",
                        "structuredName": {
                            "firstName": "Ross",
                            "lastName": "Paterson",
                            "middleNames": [
                                "A."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Paterson"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 171,
                                "start": 167
                            }
                        ],
                        "text": "Fusion and fission transformations are based on the universal properties of fold; for example, horizontal (parallel) fusion is expressed by the \u201cbanana split theorem\u201d [40], read as a transformation from right to left:"
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 11666139,
            "fieldsOfStudy": [
                "Mathematics"
            ],
            "id": "5db3c6793c07285bf0f5e95fe5a25f53e7488051",
            "isKey": false,
            "numCitedBy": 668,
            "numCiting": 55,
            "paperAbstract": {
                "fragments": [],
                "text": "We develop a calculus for lazy functional programming based on recursion operators associated with data type definitions. For these operators we derive various algebraic laws that are useful in deriving and manipulating programs. We shall show that all example functions in Bird and Wadler's Introduction to Functional Programming can be expressed using these operators."
            },
            "slug": "Functional-Programming-with-Bananas,-Lenses,-and-Meijer-Fokkinga",
            "title": {
                "fragments": [],
                "text": "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
            },
            "tldr": {
                "abstractSimilarityScore": 64,
                "text": "A calculus for lazy functional programming based on recursion operators associated with data type definitions is developed and it is shown that all example functions in Bird and Wadler's Introduction to Functional Programming can be expressed using these operators."
            },
            "venue": {
                "fragments": [],
                "text": "FPCA"
            },
            "year": 1991
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2939803"
                        ],
                        "name": "Ronan Collobert",
                        "slug": "Ronan-Collobert",
                        "structuredName": {
                            "firstName": "Ronan",
                            "lastName": "Collobert",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Ronan Collobert"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2645384"
                        ],
                        "name": "K. Kavukcuoglu",
                        "slug": "K.-Kavukcuoglu",
                        "structuredName": {
                            "firstName": "Koray",
                            "lastName": "Kavukcuoglu",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Kavukcuoglu"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2256269"
                        ],
                        "name": "C. Farabet",
                        "slug": "C.-Farabet",
                        "structuredName": {
                            "firstName": "Cl\u00e9ment",
                            "lastName": "Farabet",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "C. Farabet"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 120,
                                "start": 116
                            }
                        ],
                        "text": "Imperative solutions include Copperhead [14], Accelerator [53], and deeplearning DSLs, such as Theano [6] and Torch [20]."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 14365368,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "3449b65008b27f6e60a73d80c1fd990f0481126b",
            "isKey": false,
            "numCitedBy": 1494,
            "numCiting": 3,
            "paperAbstract": {
                "fragments": [],
                "text": "Torch7 is a versatile numeric computing framework and machine learning library that extends Lua. Its goal is to provide a flexible environment to design and train learning machines. Flexibility is obtained via Lua, an extremely lightweight scripting language. High performance is obtained via efficient OpenMP/SSE and CUDA implementations of low-level numeric routines. Torch7 can easily be interfaced to third-party software thanks to Lua\u2019s light interface."
            },
            "slug": "Torch7:-A-Matlab-like-Environment-for-Machine-Collobert-Kavukcuoglu",
            "title": {
                "fragments": [],
                "text": "Torch7: A Matlab-like Environment for Machine Learning"
            },
            "tldr": {
                "abstractSimilarityScore": 71,
                "text": "Torch7 is a versatile numeric computing framework and machine learning library that extends Lua that can easily be interfaced to third-party software thanks to Lua\u2019s light interface."
            },
            "venue": {
                "fragments": [],
                "text": "NIPS 2011"
            },
            "year": 2011
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2189877"
                        ],
                        "name": "E. Barendsen",
                        "slug": "E.-Barendsen",
                        "structuredName": {
                            "firstName": "Erik",
                            "lastName": "Barendsen",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "E. Barendsen"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "2943414"
                        ],
                        "name": "S. Smetsers",
                        "slug": "S.-Smetsers",
                        "structuredName": {
                            "firstName": "Sjaak",
                            "lastName": "Smetsers",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "S. Smetsers"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 76,
                                "start": 70
                            }
                        ],
                        "text": "\u2022 The introduction of a simple type system (based on uniqueness types [4, 5]) supporting race-free in-place updates in a purely-functional, data-parallel language."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 157,
                                "start": 151
                            }
                        ],
                        "text": "In-place updates are supported in Futhark through a typesystem feature called uniqueness types, which is similar to, but simpler than the one of Clean [4, 5], where the primary motivation is modeling IO."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 45,
                                "start": 39
                            }
                        ],
                        "text": "More elaborate and powerful uniqueness [4, 5], linear [24] and affine [54] type systems than Futhark\u2019s exist."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 47,
                                "start": 41
                            }
                        ],
                        "text": "The extension builds on uniqueness types [4, 5] and is formalized, including alias analysis, by inference rules in Section 3."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "corpusId": 36401305,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "13d5e19862bff67c4ce926a10d97ec63f0ecbb1d",
            "isKey": true,
            "numCitedBy": 62,
            "numCiting": 11,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Uniqueness-Typing-for-Functional-Languages-with-Barendsen-Smetsers",
            "title": {
                "fragments": [],
                "text": "Uniqueness Typing for Functional Languages with Graph Rewriting Semantics"
            },
            "venue": {
                "fragments": [],
                "text": "Math. Struct. Comput. Sci."
            },
            "year": 1996
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "3224333"
                        ],
                        "name": "Christophe Dubach",
                        "slug": "Christophe-Dubach",
                        "structuredName": {
                            "firstName": "Christophe",
                            "lastName": "Dubach",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Christophe Dubach"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "35977213"
                        ],
                        "name": "P. Cheng",
                        "slug": "P.-Cheng",
                        "structuredName": {
                            "firstName": "Perry",
                            "lastName": "Cheng",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "P. Cheng"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1714477"
                        ],
                        "name": "R. Rabbah",
                        "slug": "R.-Rabbah",
                        "structuredName": {
                            "firstName": "Rodric",
                            "lastName": "Rabbah",
                            "middleNames": [
                                "M."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Rabbah"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1678228"
                        ],
                        "name": "D. Bacon",
                        "slug": "D.-Bacon",
                        "structuredName": {
                            "firstName": "David",
                            "lastName": "Bacon",
                            "middleNames": [
                                "F."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "D. Bacon"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "33802916"
                        ],
                        "name": "Stephen J. Fink",
                        "slug": "Stephen-J.-Fink",
                        "structuredName": {
                            "firstName": "Stephen",
                            "lastName": "Fink",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Stephen J. Fink"
                    }
                ]
            ],
            "badges": [],
            "citationContexts": [],
            "corpusId": 65242764,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "93f34b62de8cc1d9b86a6b7665b870859b6625f9",
            "isKey": false,
            "numCitedBy": 1,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Proceedings-of-the-33rd-ACM-SIGPLAN-conference-on-Dubach-Cheng",
            "title": {
                "fragments": [],
                "text": "Proceedings of the 33rd ACM SIGPLAN conference on Programming Language Design and Implementation"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2012
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1734824"
                        ],
                        "name": "R. Bird",
                        "slug": "R.-Bird",
                        "structuredName": {
                            "firstName": "Richard",
                            "lastName": "Bird",
                            "middleNames": [
                                "S."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "R. Bird"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 89,
                                "start": 86
                            }
                        ],
                        "text": "The theoretical foundation of Futhark are the list homomorphisms of Bird and Meertens [9], realised in the form of purely functional parallel second-order array combinators (SOACs)."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 26492457,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "53f849dbc33bfa84de04105eddc606a4b2f8bd06",
            "isKey": false,
            "numCitedBy": 126,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "Algebraic-Identities-for-Program-Calculation-Bird",
            "title": {
                "fragments": [],
                "text": "Algebraic Identities for Program Calculation"
            },
            "venue": {
                "fragments": [],
                "text": "Comput. J."
            },
            "year": 1989
        },
        {
            "authors": [
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1706327"
                        ],
                        "name": "Arvind K. Sujeeth",
                        "slug": "Arvind-K.-Sujeeth",
                        "structuredName": {
                            "firstName": "Arvind",
                            "lastName": "Sujeeth",
                            "middleNames": [
                                "K."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Arvind K. Sujeeth"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "144806284"
                        ],
                        "name": "Kevin J. Brown",
                        "slug": "Kevin-J.-Brown",
                        "structuredName": {
                            "firstName": "Kevin",
                            "lastName": "Brown",
                            "middleNames": [
                                "J."
                            ]
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Kevin J. Brown"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "34946720"
                        ],
                        "name": "HyoukJoong Lee",
                        "slug": "HyoukJoong-Lee",
                        "structuredName": {
                            "firstName": "HyoukJoong",
                            "lastName": "Lee",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "HyoukJoong Lee"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1712987"
                        ],
                        "name": "Tiark Rompf",
                        "slug": "Tiark-Rompf",
                        "structuredName": {
                            "firstName": "Tiark",
                            "lastName": "Rompf",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Tiark Rompf"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1694512"
                        ],
                        "name": "H. Chafi",
                        "slug": "H.-Chafi",
                        "structuredName": {
                            "firstName": "Hassan",
                            "lastName": "Chafi",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "H. Chafi"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1795826"
                        ],
                        "name": "Martin Odersky",
                        "slug": "Martin-Odersky",
                        "structuredName": {
                            "firstName": "Martin",
                            "lastName": "Odersky",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "Martin Odersky"
                    }
                ],
                [
                    {
                        "bitmap$0": false,
                        "ids": [
                            "1746638"
                        ],
                        "name": "K. Olukotun",
                        "slug": "K.-Olukotun",
                        "structuredName": {
                            "firstName": "Kunle",
                            "lastName": "Olukotun",
                            "middleNames": []
                        }
                    },
                    {
                        "fragments": [],
                        "text": "K. Olukotun"
                    }
                ]
            ],
            "badges": [
                {
                    "id": "OPEN_ACCESS"
                }
            ],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 11,
                                "start": 7
                            }
                        ],
                        "text": "Delite [51] and Lime [2] are impure languages that use effect systems to ensure that side effects cannot inhibit safe parallelisation, although Delite does permit a potentially unsafe parallel foreach."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                },
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 118,
                                "start": 95
                            }
                        ],
                        "text": "On the other side, there are a number of embedded (morally functional) data-parallel languages [2, 15, 35, 48, 51, 52] that express parallelism explicitly by means of bulk operators, which allow the compiler to reason at a higher level about restructuring the program."
                    },
                    "intents": [
                        {
                            "id": "background"
                        }
                    ]
                }
            ],
            "corpusId": 8944267,
            "fieldsOfStudy": [
                "Computer Science"
            ],
            "id": "25635a854dc2055a0339235bba7b863c7c6df31a",
            "isKey": false,
            "numCitedBy": 169,
            "numCiting": 49,
            "paperAbstract": {
                "fragments": [],
                "text": "Developing high-performance software is a difficult task that requires the use of low-level, architecture-specific programming models (e.g., OpenMP for CMPs, CUDA for GPUs, MPI for clusters). It is typically not possible to write a single application that can run efficiently in different environments, leading to multiple versions and increased complexity. Domain-Specific Languages (DSLs) are a promising avenue to enable programmers to use high-level abstractions and still achieve good performance on a variety of hardware. This is possible because DSLs have higher-level semantics and restrictions than general-purpose languages, so DSL compilers can perform higher-level optimization and translation. However, the cost of developing performance-oriented DSLs is a substantial roadblock to their development and adoption. In this article, we present an overview of the Delite compiler framework and the DSLs that have been developed with it. Delite simplifies the process of DSL development by providing common components, like parallel patterns, optimizations, and code generators, that can be reused in DSL implementations. Delite DSLs are embedded in Scala, a general-purpose programming language, but use metaprogramming to construct an Intermediate Representation (IR) of user programs and compile to multiple languages (including Cpp, CUDA, and OpenCL). DSL programs are automatically parallelized and different parts of the application can run simultaneously on CPUs and GPUs. We present Delite DSLs for machine learning, data querying, graph analysis, and scientific computing and show that they all achieve performance competitive to or exceeding Cpp code."
            },
            "slug": "Delite:-A-Compiler-Architecture-for-Embedded-Sujeeth-Brown",
            "title": {
                "fragments": [],
                "text": "Delite: A Compiler Architecture for Performance-Oriented Embedded Domain-Specific Languages"
            },
            "tldr": {
                "abstractSimilarityScore": 39,
                "text": "An overview of the Delite compiler framework and DSLs that have been developed with it is presented and it is shown that they all achieve performance competitive to or exceeding Cpp code."
            },
            "venue": {
                "fragments": [],
                "text": "ACM Trans. Embed. Comput. Syst."
            },
            "year": 2014
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Rust Programming Language"
            },
            "venue": {
                "fragments": [],
                "text": ""
            }
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "Scans as Primitive Parallel Operations. Computers"
            },
            "venue": {
                "fragments": [],
                "text": "IEEE Transactions"
            },
            "year": 1989
        },
        {
            "authors": [],
            "badges": [],
            "citationContexts": [
                {
                    "context": {
                        "fragments": [
                            {
                                "end": 58,
                                "start": 54
                            }
                        ],
                        "text": "Our use is reminiscent of the ownership types of Rust [33]."
                    },
                    "intents": [
                        {
                            "id": "methodology"
                        }
                    ]
                }
            ],
            "fieldsOfStudy": [],
            "isKey": false,
            "numCitedBy": 0,
            "numCiting": 0,
            "paperAbstract": {
                "fragments": [],
                "text": ""
            },
            "slug": "+",
            "title": {
                "fragments": [],
                "text": "The Rust Programming"
            },
            "venue": {
                "fragments": [],
                "text": ""
            },
            "year": 2013
        }
    ],
    "meta_info": {
        "citationIntent": "all",
        "citationIntentCount": {
            "background": 41,
            "methodology": 24
        },
        "citationType": "citedPapers",
        "pageNumber": 1,
        "requestedPageSize": 10,
        "sort": "relevance",
        "totalCitations": 59,
        "totalPages": 6
    },
    "page_url": "https://www.semanticscholar.org/paper/Futhark:-purely-functional-GPU-programming-with-and-Henriksen-Serup/f463b6d692704baf9463e7d8b39e6032c23c4ec9?sort=total-citations"
}